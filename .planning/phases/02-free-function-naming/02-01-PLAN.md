---
phase: 02-free-function-naming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/quiver/c/database.h
  - include/quiver/c/element.h
  - src/c/database_read.cpp
  - src/c/element.cpp
  - tests/test_c_api_element.cpp
  - bindings/julia/src/c_api.jl
  - bindings/dart/lib/src/ffi/bindings.dart
  - bindings/python/src/quiverdb/_declarations.py
autonomous: true
requirements:
  - NAME-01
  - NAME-02
must_haves:
  truths:
    - "quiver_database_free_string() is declared in include/quiver/c/database.h"
    - "quiver_database_free_string() is implemented in src/c/database_read.cpp alongside other free functions"
    - "quiver_element_free_string() does not exist in any C header or implementation file"
    - "quiver_element_to_string comment references quiver_database_free_string"
    - "test_c_api_element.cpp calls quiver_database_free_string instead of quiver_element_free_string"
    - "C++ library, C API library, and all C/C++ tests build successfully"
    - "Generated bindings (c_api.jl, bindings.dart, _declarations.py) contain quiver_database_free_string and not quiver_element_free_string"
  artifacts:
    - path: "include/quiver/c/database.h"
      provides: "quiver_database_free_string declaration"
      contains: "quiver_database_free_string"
    - path: "src/c/database_read.cpp"
      provides: "quiver_database_free_string implementation"
      contains: "quiver_database_free_string"
    - path: "bindings/julia/src/c_api.jl"
      provides: "Generated Julia FFI wrapper with new function"
      contains: "quiver_database_free_string"
    - path: "bindings/dart/lib/src/ffi/bindings.dart"
      provides: "Generated Dart FFI binding with new function"
      contains: "quiver_database_free_string"
  key_links:
    - from: "src/c/database_read.cpp"
      to: "include/quiver/c/database.h"
      via: "quiver_database_free_string declaration/implementation"
      pattern: "quiver_database_free_string"
    - from: "tests/test_c_api_element.cpp"
      to: "include/quiver/c/database.h"
      via: "quiver_database_free_string call in element toString tests"
      pattern: "quiver_database_free_string"
---

<objective>
Add `quiver_database_free_string()` to the C API, remove `quiver_element_free_string()` from headers and implementation, update C API tests, build, and re-run all three binding generators.

Purpose: Fix entity-scope violation where strings allocated by database operations were freed through an element-scoped function. After this plan, the C layer is correct and all generated binding files reflect the rename.

Output: Updated C headers, C implementation, C API test. Three regenerated binding files (Julia, Dart, Python). C++ and C API tests pass.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-free-function-naming/02-CONTEXT.md
@.planning/phases/02-free-function-naming/02-RESEARCH.md

<interfaces>
<!-- Current quiver_element_free_string in include/quiver/c/element.h (line 44-46): -->
```c
// Pretty print (caller must free returned string with quiver_element_free_string)
QUIVER_C_API quiver_error_t quiver_element_to_string(quiver_element_t* element, char** out_string);
QUIVER_C_API quiver_error_t quiver_element_free_string(char* str);
```

<!-- Current implementation in src/c/element.cpp (lines 157-160): -->
```cpp
QUIVER_C_API quiver_error_t quiver_element_free_string(char* str) {
    delete[] str;
    return QUIVER_OK;
}
```

<!-- Existing free functions in include/quiver/c/database.h (near line 342): -->
```c
QUIVER_C_API quiver_error_t quiver_database_free_integer_array(int64_t* values);
QUIVER_C_API quiver_error_t quiver_database_free_float_array(double* values);
QUIVER_C_API quiver_error_t quiver_database_free_string_array(char** values, size_t count);
```

<!-- Existing free function implementations in src/c/database_read.cpp (near line 78): -->
```cpp
QUIVER_C_API quiver_error_t quiver_database_free_string_array(char** values, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        delete[] values[i];
    }
    delete[] values;
    return QUIVER_OK;
}
```

<!-- test_c_api_element.cpp call sites (lines 244, 254): -->
```cpp
quiver_element_free_string(str);          // line 244
quiver_element_free_string(nullptr);       // line 254
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add quiver_database_free_string to C API and remove quiver_element_free_string</name>
  <files>
    include/quiver/c/database.h
    include/quiver/c/element.h
    src/c/database_read.cpp
    src/c/element.cpp
    tests/test_c_api_element.cpp
  </files>
  <action>
**include/quiver/c/database.h** -- Add new declaration after the existing `quiver_database_free_string_array` declaration (near line 342):

```c
QUIVER_C_API quiver_error_t quiver_database_free_string(char* str);
```

Place it immediately after `quiver_database_free_string_array`. Add a comment: `// Memory cleanup for single string returned by query/read-by-id operations`

**src/c/database_read.cpp** -- Add new implementation after the existing `quiver_database_free_string_array` function (co-location with other free functions):

```cpp
QUIVER_C_API quiver_error_t quiver_database_free_string(char* str) {
    delete[] str;
    return QUIVER_OK;
}
```

No `QUIVER_REQUIRE(str)` -- `delete[] nullptr` is a no-op in C++. This matches the existing behavior of `quiver_element_free_string`.

**include/quiver/c/element.h** -- Two changes:

1. Update comment on `quiver_element_to_string` (line 44): Change "caller must free returned string with quiver_element_free_string" to "caller must free returned string with quiver_database_free_string".

2. Remove the `quiver_element_free_string` declaration line entirely (line 46).

**src/c/element.cpp** -- Remove the `quiver_element_free_string` function implementation entirely (lines 157-160).

**tests/test_c_api_element.cpp** -- Three changes:

1. Verify `#include "quiver/c/database.h"` exists. If missing, add it alongside the existing element.h include.

2. Line 244: Change `quiver_element_free_string(str)` to `quiver_database_free_string(str)`.

3. Line 254: Change `quiver_element_free_string(nullptr)` to `quiver_database_free_string(nullptr)`. Also update the test name or surrounding context if it references the old function name.
  </action>
  <verify>
    <automated>cmake --build build --config Debug --target quiver --target quiver_c --target quiver_tests --target quiver_c_tests 2>&1 | tail -5</automated>
  </verify>
  <done>quiver_database_free_string is declared in database.h and implemented in database_read.cpp. quiver_element_free_string is gone from element.h and element.cpp. test_c_api_element.cpp compiles with the new function. All four build targets compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Build C++ library and run all three binding generators</name>
  <files>
    bindings/julia/src/c_api.jl
    bindings/dart/lib/src/ffi/bindings.dart
    bindings/python/src/quiverdb/_declarations.py
  </files>
  <action>
**Build the C++ library** (required before Julia generator, which loads the DLL):

```bash
cmake --build build --config Debug
```

This exports `quiver_database_free_string` and stops exporting `quiver_element_free_string` from the DLL.

**Run all three generators** (order does not matter between them, but all must run AFTER the build):

```bash
bindings/julia/generator/generator.bat
bindings/dart/generator/generator.bat
bindings/python/generator/generator.bat
```

**Verify generated output** after each generator:

1. `bindings/julia/src/c_api.jl` -- must contain `quiver_database_free_string` and NOT contain `quiver_element_free_string`.
2. `bindings/dart/lib/src/ffi/bindings.dart` -- must contain `quiver_database_free_string` and NOT contain `quiver_element_free_string`.
3. `bindings/python/src/quiverdb/_declarations.py` -- must contain `quiver_database_free_string` and NOT contain `quiver_element_free_string`.

If any generator fails or output is unexpected, rebuild the C++ library first and retry.

**Run C++ and C API tests** to validate the C layer is correct before Plan 02 touches bindings:

```bash
./build/bin/quiver_tests.exe
./build/bin/quiver_c_tests.exe
```

Both test suites must pass.
  </action>
  <verify>
    <automated>./build/bin/quiver_tests.exe 2>&1 | tail -3 && ./build/bin/quiver_c_tests.exe 2>&1 | tail -3</automated>
  </verify>
  <done>C++ library built with new symbol. All three generators have run. Generated files contain quiver_database_free_string and do not contain quiver_element_free_string. C++ tests and C API tests pass.</done>
</task>

</tasks>

<verification>
1. `grep "quiver_database_free_string" include/quiver/c/database.h` returns a match
2. `grep "quiver_element_free_string" include/quiver/c/element.h src/c/element.cpp` returns zero matches
3. `grep "quiver_database_free_string" src/c/database_read.cpp` returns a match
4. `grep "quiver_database_free_string" bindings/julia/src/c_api.jl` returns a match
5. `grep "quiver_database_free_string" bindings/dart/lib/src/ffi/bindings.dart` returns a match
6. `grep "quiver_element_free_string" bindings/julia/src/c_api.jl bindings/dart/lib/src/ffi/bindings.dart` returns zero matches
7. C++ tests and C API tests pass
</verification>

<success_criteria>
- `cmake --build build --config Debug` succeeds
- `./build/bin/quiver_tests.exe` passes all tests
- `./build/bin/quiver_c_tests.exe` passes all tests
- `grep -r "quiver_element_free_string" include/ src/ tests/ bindings/julia/src/c_api.jl bindings/dart/lib/src/ffi/bindings.dart bindings/python/src/quiverdb/_declarations.py` returns zero matches
- `grep "quiver_database_free_string" include/quiver/c/database.h src/c/database_read.cpp` returns matches in both files
</success_criteria>

<output>
After completion, create `.planning/phases/02-free-function-naming/02-01-SUMMARY.md`
</output>
