# Phase 6: Julia Bindings Standardization - Research

**Researched:** 2026-02-10
**Domain:** Julia wrapper function naming conventions and error handling standardization
**Confidence:** HIGH

## Summary

Phase 6 standardizes the Julia bindings layer to ensure all wrapper functions use idiomatic Julia `snake_case` naming, map predictably from C API names, and surface C API error messages without crafting custom error strings in Julia code. The Julia bindings consist of two layers: (1) the FFI layer (`c_api.jl`) which mirrors C API function names exactly, and (2) the wrapper layer (`database.jl`, `database_*.jl`, `element.jl`, `lua_runner.jl`) which provides idiomatic Julia functions.

The good news: the Julia wrapper naming is already ~95% correct. Functions already use `snake_case`, already strip the `quiver_database_` prefix from C API names, and already use the `!` suffix convention for mutating operations. The primary issues are: (1) **one naming inconsistency** -- `delete_element_by_id!` should be `delete_element!` to match the C API rename from Phase 5, and (2) **11 custom error messages** defined in Julia code that violate ERRH-03 (error messages should come from the C API, not be crafted in bindings). The error handling issue is more significant than the naming one.

**Primary recommendation:** Rename `delete_element_by_id!` to `delete_element!`, remove all custom `DatabaseException` strings crafted in Julia wrapper code (replace with calls through `check()` that surface C API errors), and ensure `LuaRunner` error handling uses `check()` consistently.

## Standard Stack

Not applicable -- this phase involves no new libraries, only refactoring existing Julia wrapper code. All tools are already in the project (Julia 1.12, CEnum.jl, JuliaFormatter).

## Architecture Patterns

### Julia Bindings Architecture

The Julia bindings use a two-layer architecture:

```
src/
  Quiver.jl              # Module entry point, exports
  c_api.jl               # Layer 1: FFI layer (mirrors C API 1:1)
  exceptions.jl          # check() function, DatabaseException type
  date_time.jl           # DateTime conversion helpers
  element.jl             # Element wrapper (Base.setindex! overloads)
  database.jl            # Database struct + lifecycle functions
  database_create.jl     # create_element!, update_scalar_relation!
  database_csv.jl        # export_csv, import_csv
  database_delete.jl     # delete_element_by_id! (NEEDS RENAME)
  database_metadata.jl   # get_*, list_*, has_*, parse_* functions
  database_query.jl      # query_string, query_integer, query_float, query_date_time
  database_read.jl       # All read functions + composite read_all_* functions
  database_update.jl     # All update functions
  lua_runner.jl          # LuaRunner struct + run!, close!
```

**Layer 1 (FFI -- c_api.jl):** Auto-generated by Clang.jl, wrapped in `module C`. Functions have exact C API names (e.g., `C.quiver_database_read_scalar_integers`). This layer is NOT touched by Phase 6.

**Layer 2 (Wrappers):** Hand-written Julia functions that call Layer 1. These strip the `quiver_database_` prefix, use Julia types, and handle memory management. The `check()` function in `exceptions.jl` converts C API error codes into Julia exceptions by calling `quiver_get_last_error()`.

### Current Julia Function Name Mapping

The naming convention strips `quiver_database_` prefix for database operations and uses `!` suffix for mutating operations:

| C API Name | Julia Wrapper Name | Convention | Status |
|------------|-------------------|------------|--------|
| `quiver_database_from_schema` | `from_schema` | strip prefix | OK |
| `quiver_database_from_migrations` | `from_migrations` | strip prefix | OK |
| `quiver_database_close` | `close!` | strip prefix + `!` | OK |
| `quiver_database_current_version` | `current_version` | strip prefix | OK |
| `quiver_database_describe` | `describe` | strip prefix | OK |
| `quiver_database_create_element` | `create_element!` | strip prefix + `!` | OK |
| `quiver_database_update_element` | `update_element!` | strip prefix + `!` | OK |
| `quiver_database_delete_element` | `delete_element_by_id!` | **WRONG** -- still has `_by_id` from before Phase 5 | **RENAME** |
| `quiver_database_update_scalar_relation` | `update_scalar_relation!` | strip prefix + `!` | OK |
| `quiver_database_read_scalar_relation` | `read_scalar_relation` | strip prefix | OK |
| `quiver_database_read_scalar_integers` | `read_scalar_integers` | strip prefix | OK |
| `quiver_database_read_scalar_floats` | `read_scalar_floats` | strip prefix | OK |
| `quiver_database_read_scalar_strings` | `read_scalar_strings` | strip prefix | OK |
| `quiver_database_read_scalar_integer_by_id` | `read_scalar_integer_by_id` | strip prefix | OK |
| `quiver_database_read_scalar_float_by_id` | `read_scalar_float_by_id` | strip prefix | OK |
| `quiver_database_read_scalar_string_by_id` | `read_scalar_string_by_id` | strip prefix | OK |
| `quiver_database_read_vector_integers` | `read_vector_integers` | strip prefix | OK |
| `quiver_database_read_vector_floats` | `read_vector_floats` | strip prefix | OK |
| `quiver_database_read_vector_strings` | `read_vector_strings` | strip prefix | OK |
| `quiver_database_read_vector_integers_by_id` | `read_vector_integers_by_id` | strip prefix | OK |
| `quiver_database_read_vector_floats_by_id` | `read_vector_floats_by_id` | strip prefix | OK |
| `quiver_database_read_vector_strings_by_id` | `read_vector_strings_by_id` | strip prefix | OK |
| `quiver_database_read_set_integers` | `read_set_integers` | strip prefix | OK |
| `quiver_database_read_set_floats` | `read_set_floats` | strip prefix | OK |
| `quiver_database_read_set_strings` | `read_set_strings` | strip prefix | OK |
| `quiver_database_read_set_integers_by_id` | `read_set_integers_by_id` | strip prefix | OK |
| `quiver_database_read_set_floats_by_id` | `read_set_floats_by_id` | strip prefix | OK |
| `quiver_database_read_set_strings_by_id` | `read_set_strings_by_id` | strip prefix | OK |
| `quiver_database_read_element_ids` | `read_element_ids` | strip prefix | OK |
| `quiver_database_get_scalar_metadata` | `get_scalar_metadata` | strip prefix | OK |
| `quiver_database_get_vector_metadata` | `get_vector_metadata` | strip prefix | OK |
| `quiver_database_get_set_metadata` | `get_set_metadata` | strip prefix | OK |
| `quiver_database_get_time_series_metadata` | `get_time_series_metadata` | strip prefix | OK |
| `quiver_database_list_scalar_attributes` | `list_scalar_attributes` | strip prefix | OK |
| `quiver_database_list_vector_groups` | `list_vector_groups` | strip prefix | OK |
| `quiver_database_list_set_groups` | `list_set_groups` | strip prefix | OK |
| `quiver_database_list_time_series_groups` | `list_time_series_groups` | strip prefix | OK |
| `quiver_database_has_time_series_files` | `has_time_series_files` | strip prefix | OK |
| `quiver_database_list_time_series_files_columns` | `list_time_series_files_columns` | strip prefix | OK |
| `quiver_database_read_time_series_files` | `read_time_series_files` | strip prefix | OK |
| `quiver_database_update_time_series_files` | `update_time_series_files!` | strip prefix + `!` | OK |
| `quiver_database_update_scalar_integer` | `update_scalar_integer!` | strip prefix + `!` | OK |
| `quiver_database_update_scalar_float` | `update_scalar_float!` | strip prefix + `!` | OK |
| `quiver_database_update_scalar_string` | `update_scalar_string!` | strip prefix + `!` | OK |
| `quiver_database_update_vector_integers` | `update_vector_integers!` | strip prefix + `!` | OK |
| `quiver_database_update_vector_floats` | `update_vector_floats!` | strip prefix + `!` | OK |
| `quiver_database_update_vector_strings` | `update_vector_strings!` | strip prefix + `!` | OK |
| `quiver_database_update_set_integers` | `update_set_integers!` | strip prefix + `!` | OK |
| `quiver_database_update_set_floats` | `update_set_floats!` | strip prefix + `!` | OK |
| `quiver_database_update_set_strings` | `update_set_strings!` | strip prefix + `!` | OK |
| `quiver_database_read_time_series_group` | `read_time_series_group` | strip prefix | OK |
| `quiver_database_update_time_series_group` | `update_time_series_group!` | strip prefix + `!` | OK |
| `quiver_database_export_csv` | `export_csv` | strip prefix | OK |
| `quiver_database_import_csv` | `import_csv` | strip prefix | OK |
| `quiver_database_query_string` | `query_string` | strip prefix | OK |
| `quiver_database_query_integer` | `query_integer` | strip prefix | OK |
| `quiver_database_query_float` | `query_float` | strip prefix | OK |

**Additional Julia-only functions (no direct C API mapping):**

| Julia Function | Purpose | Status |
|----------------|---------|--------|
| `read_scalar_date_time_by_id` | Reads string, converts to DateTime | OK -- convenience wrapper |
| `read_vector_date_time_by_id` | Reads string vector, converts to DateTimes | OK |
| `read_set_date_time_by_id` | Reads string set, converts to DateTimes | OK |
| `read_all_scalars_by_id` | Composite: reads all scalar attributes for one element | OK |
| `read_all_vectors_by_id` | Composite: reads all vector groups for one element | OK |
| `read_all_sets_by_id` | Composite: reads all set groups for one element | OK |
| `read_vector_group_by_id` | Composite: reads all columns in a vector group for one element | OK |
| `read_set_group_by_id` | Composite: reads all columns in a set group for one element | OK |
| `query_date_time` | Reads string query result, converts to DateTime | OK |
| `marshal_params` | Internal helper for parameterized queries | OK (prefixed with implicit internal) |
| `parse_scalar_metadata` | Internal helper for metadata parsing | OK |
| `parse_group_metadata` | Internal helper for metadata parsing | OK |
| `_get_value_data_type` | Internal helper (underscore prefix) | OK |

### Naming Issue: Only 1 Function Needs Renaming

| Current Name | C API Name | Expected Julia Name | Issue |
|-------------|------------|--------------------|----|
| `delete_element_by_id!` | `quiver_database_delete_element` | `delete_element!` | Phase 5 renamed C API from `_by_id`; Julia wrapper still has old name |

### Julia Naming Convention (Codified from existing practice)

The Julia wrapper naming convention is:

1. **Strip `quiver_database_` prefix** from C API function names
2. **Append `!` suffix** for functions that mutate state (Julia convention for mutating functions)
3. **Use `snake_case`** (Julia standard)
4. **`_by_id` suffix preserved** only where the C API has it (read operations with both "all" and "single" variants)
5. **Element functions** strip `quiver_element_` prefix, use `destroy!`, `clear!`, `Base.setindex!`
6. **LuaRunner functions** use `LuaRunner()` constructor, `run!`, `close!`

### Error Handling Audit: Custom Error Messages in Julia

**ERRH-03 Requirement:** Julia bindings surface C API errors uniformly -- no custom error messages defined in Julia code.

**Current error handling pattern (correct):**
```julia
# exceptions.jl -- the check() function retrieves C API errors
function check(err)
    if err != C.QUIVER_OK
        detail = unsafe_string(C.quiver_get_last_error())
        if isempty(detail)
            @warn "check: C API returned error but quiver_get_last_error() is empty"
            throw(DatabaseException("Unknown error"))
        end
        throw(DatabaseException(detail))
    end
    return nothing
end
```

This is correct -- it retrieves the error message from C API and surfaces it. The `"Unknown error"` fallback is acceptable as a safety net.

**Custom error messages that VIOLATE ERRH-03:**

| File | Line | Custom Message | Category |
|------|------|---------------|----------|
| `element.jl:85` | `throw(DatabaseException("Empty array not allowed for '$name'"))` | Crafted in Julia | Should come from C API |
| `element.jl:96` | `error("Unsupported array element type for '$name': $(typeof(first_val))")` | Uses `error()` not `DatabaseException` | Julia-side type dispatch error |
| `database_read.jl:417` | `throw(DatabaseException("Unsupported scalar data type for '$collection.$name'"))` | Crafted in Julia | Logic in binding |
| `database_read.jl:437` | `throw(DatabaseException("Unsupported vector data type for '$collection.$name'"))` | Crafted in Julia | Logic in binding |
| `database_read.jl:457` | `throw(DatabaseException("Unsupported set data type for '$collection.$name'"))` | Crafted in Julia | Logic in binding |
| `database_read.jl:474` | `throw(DatabaseException("Vector group '$group' not found in collection '$collection'"))` | Crafted in Julia | Duplicates C API validation |
| `database_read.jl:497` | `throw(DatabaseException("Unknown data type: $(col.data_type)"))` | Crafted in Julia | Logic in binding |
| `database_read.jl:528` | `throw(DatabaseException("Set group '$group' not found in collection '$collection'"))` | Crafted in Julia | Duplicates C API validation |
| `database_read.jl:551` | `throw(DatabaseException("Unknown data type: $(col.data_type)"))` | Crafted in Julia | Logic in binding |
| `lua_runner.jl:11-12` | `"Failed to create LuaRunner"` / `"$context: $detail"` | Wraps C API error with custom prefix | Should just surface C API error |
| `lua_runner.jl:26` | `throw(DatabaseException("Lua error: $error_msg"))` | Wraps Lua error with custom prefix | Should just surface the error |
| `lua_runner.jl:28` | `throw(DatabaseException("Lua script execution failed"))` | Crafted in Julia | Fallback when no error msg |

**Total: 12 custom error message sites across 3 files.**

### Error Message Categories and Remediation

**Category 1: Julia-side type dispatch (element.jl lines 85, 96)**
These occur when Julia code handles `Vector{Any}` with an empty array or unsupported element type. The C API would also reject these, but the Julia code intercepts first.

**Remediation:** The empty array check in `element.jl:85` currently throws a custom message. However, the C API `quiver_element_set_array_*` functions would accept an empty array and the C++ layer would throw the error. The Julia code should let the call through to C++ and surface its error. For `element.jl:96` (unsupported type), this is a genuine Julia-side dispatch issue -- the code cannot determine which C function to call. This is an `ArgumentError`, not a `DatabaseException`. Change from `error()` to `throw(ArgumentError(...))` to distinguish it from database errors.

**Category 2: Composite function logic (database_read.jl lines 417, 437, 457, 474, 497, 528, 551)**
The composite functions `read_all_scalars_by_id`, `read_all_vectors_by_id`, `read_all_sets_by_id`, `read_vector_group_by_id`, and `read_set_group_by_id` contain Julia-side logic that dispatches based on metadata types. When they encounter an unknown data type or missing group, they throw custom errors. The "not found" errors (lines 474, 528) duplicate validation already in the C API.

**Remediation for "not found" errors (lines 474, 528):** These check if a group exists before reading. The C API would also throw if the group doesn't exist. However, these are composite operations that iterate over metadata to find a matching group -- the C API doesn't have a single-call equivalent. These errors are inherent to the Julia-side logic. The principle says "no custom error messages defined in Julia code" -- so these should either (a) call the C API `get_vector_metadata` / `get_set_metadata` which would throw a proper C API error if the group doesn't exist, or (b) be accepted as a necessary exception since these are Julia-only composite operations.

**Recommendation:** Replace the manual group lookup with a call to `get_vector_metadata(db, collection, group)` / `get_set_metadata(db, collection, group)` which will throw a C API error if the group doesn't exist.

**Remediation for "unsupported data type" errors (lines 417, 437, 457, 497, 551):** These are exhaustive type dispatch branches. They should never be reached if the C API reports valid data types. These are defensive `else` branches. Converting to `ArgumentError` (not `DatabaseException`) is appropriate since they indicate a programming error, not a database error.

**Category 3: LuaRunner error wrapping (lua_runner.jl lines 11-12, 26, 28)**
The LuaRunner constructor and `run!` function bypass the standard `check()` pattern. They manually call `C.quiver_lua_runner_*` and craft custom error messages instead of using `check()`.

**Remediation for LuaRunner constructor (line 11-12):** Replace the manual error handling with `check()`. The C API `quiver_lua_runner_new` sets `quiver_set_last_error` on failure, so `check()` will retrieve the correct message.

**Remediation for `run!` (lines 19-32):** The `run!` function handles errors specially because Lua errors are retrieved via `quiver_lua_runner_get_error`, not `quiver_get_last_error`. This is architecturally different from database operations. However, the C API `quiver_lua_runner_run` DOES call `quiver_set_last_error` in its catch block (verified in Phase 5 research -- lua_runner.cpp uses try-catch-set_last_error). So `check()` SHOULD work for the run error case. The separate `quiver_lua_runner_get_error` call is redundant if the C API already stores the error via `quiver_set_last_error`.

**Important caveat:** Need to verify whether `quiver_lua_runner_run` sets `quiver_set_last_error` with the Lua error message. If it only catches std::exception but Lua errors go through a different path, the Lua-specific error retrieval may be necessary. Given Phase 5 normalized lua_runner.cpp to use the standard pattern, `check()` should work. If it doesn't, the fallback is to use `check()` first and only call `quiver_lua_runner_get_error` if `check()` gives an empty message.

### Complete Remediation Plan

| File | Line(s) | Current | Proposed | Impact |
|------|---------|---------|----------|--------|
| `database_delete.jl:1` | `delete_element_by_id!` | Rename to `delete_element!` | Function name + all test call sites |
| `element.jl:85` | `throw(DatabaseException("Empty array not allowed for '$name'"))` | Remove check; let C++ handle via `check()` on the C API call | Tests that expect this specific error |
| `element.jl:96` | `error("Unsupported array element type...")` | `throw(ArgumentError("Unsupported array element type..."))` | Not a database error; ArgumentError is appropriate |
| `database_read.jl:417,437,457` | `throw(DatabaseException("Unsupported ... data type..."))` | Convert to unreachable assertion or `ArgumentError` | These are defensive else branches |
| `database_read.jl:474` | `throw(DatabaseException("Vector group '$group' not found..."))` | Call `get_vector_metadata(db, collection, group)` instead of manual lookup | C API error surfaces via `check()` |
| `database_read.jl:497,551` | `throw(DatabaseException("Unknown data type..."))` | Convert to `ArgumentError` | Defensive else branches |
| `database_read.jl:528` | `throw(DatabaseException("Set group '$group' not found..."))` | Call `get_set_metadata(db, collection, group)` instead of manual lookup | C API error surfaces via `check()` |
| `lua_runner.jl:8-17` | LuaRunner constructor with manual error handling | Use `check()` pattern | Remove custom "Failed to create LuaRunner" message |
| `lua_runner.jl:19-32` | `run!` with manual error handling | Use `check()` pattern if C API stores Lua errors in last_error | Remove custom "Lua error:" prefix and "Lua script execution failed" fallback |

### Files Affected (Complete List)

**Source files to modify:**
- `bindings/julia/src/database_delete.jl` -- rename function
- `bindings/julia/src/element.jl` -- fix error handling for empty arrays and unsupported types
- `bindings/julia/src/database_read.jl` -- fix composite function error handling (7 sites)
- `bindings/julia/src/lua_runner.jl` -- standardize error handling to use `check()`

**Test files to update (for `delete_element_by_id!` -> `delete_element!` rename):**
- `bindings/julia/test/test_database_delete.jl` -- 5 call sites of `delete_element_by_id!`

**Test files to verify (error message changes may affect assertions):**
- `bindings/julia/test/test_element.jl` -- tests `@test_throws Quiver.DatabaseException el["values"] = Any[]`
- `bindings/julia/test/test_lua_runner.jl` -- tests `@test_throws Quiver.DatabaseException Quiver.run!(lua, ...)`
- All other test files -- verify no test asserts on specific error message strings

**Files NOT touched:**
- `bindings/julia/src/c_api.jl` -- already correct from Phase 5 (uses `quiver_database_delete_element` not `_by_id`)
- `bindings/julia/src/Quiver.jl` -- no changes needed
- `bindings/julia/src/exceptions.jl` -- `check()` function is correct
- `bindings/julia/src/date_time.jl` -- no changes needed
- `bindings/julia/src/database.jl` -- all names correct
- `bindings/julia/src/database_create.jl` -- all names correct
- `bindings/julia/src/database_csv.jl` -- all names correct
- `bindings/julia/src/database_metadata.jl` -- all names correct
- `bindings/julia/src/database_query.jl` -- all names correct
- `bindings/julia/src/database_update.jl` -- all names correct

### Julia Idiomatic Conventions (Verified)

Julia naming conventions relevant to this phase:

1. **`snake_case` for functions** -- All Julia functions use lowercase with underscores. Already followed.
2. **`!` suffix for mutating functions** -- Functions that modify their first argument or external state use `!`. Already followed for `create_element!`, `update_element!`, `close!`, etc.
3. **`PascalCase` for types** -- `Database`, `Element`, `LuaRunner`, `DatabaseException`, `ScalarMetadata`, `GroupMetadata`. Already followed.
4. **`SCREAMING_SNAKE_CASE` for constants** -- `QUIVER_DATA_TYPE_INTEGER`, etc. Already followed.
5. **Method dispatch on first argument type** -- All database functions take `db::Database` as first argument. Already followed.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| C API error retrieval | Custom error checking per function | `check()` from `exceptions.jl` | Single centralized error path; guaranteed to surface C API errors |
| Group existence validation | Manual iteration over group list | `get_vector_metadata()` / `get_set_metadata()` C API call | C API already validates and provides proper error messages |
| FFI binding names | Manual edits to c_api.jl | Re-run generator if C API changes | c_api.jl is auto-generated |

**Key insight:** The `check()` function is the correct and only mechanism for converting C API errors to Julia exceptions. Any code path that bypasses `check()` and crafts its own error messages violates ERRH-03.

## Common Pitfalls

### Pitfall 1: Breaking Test Assertions on Error Messages
**What goes wrong:** Tests that assert `@test_throws DatabaseException` continue to pass, but tests that check the specific error message string break.
**Why it happens:** Changing error handling changes what message appears in the exception.
**How to avoid:** Grep all test files for string comparisons on error messages. Current tests use `@test_throws Quiver.DatabaseException` without checking message content, so this risk is LOW.
**Warning signs:** Tests that were passing before start failing with unexpected exception types.

### Pitfall 2: Empty Array Behavior Change
**What goes wrong:** Currently, `el["values"] = Any[]` throws `DatabaseException("Empty array not allowed for '$name'")` from Julia. If we remove this check and let the C API handle it, the behavior depends on what happens when `quiver_element_set_array_*` is called with count=0. The Julia code currently short-circuits before calling the C API.
**Why it happens:** The Julia binding adds validation that may not exist in the C API.
**How to avoid:** Test what the C API does with empty arrays before removing the Julia-side check. If the C++ layer rejects empty arrays with a proper error message, the Julia check is redundant and can be removed. If the C++ layer accepts empty arrays silently, the Julia check serves a purpose.
**Warning signs:** Empty array test (`test_element.jl` "Empty Array Rejected" testset) behavior changes.

### Pitfall 3: LuaRunner Error Path Regression
**What goes wrong:** Switching LuaRunner from manual error handling to `check()` may lose Lua-specific error details if the C API doesn't store them via `quiver_set_last_error`.
**Why it happens:** Lua errors may flow through a different path than database errors in the C layer.
**How to avoid:** Before changing LuaRunner error handling, verify that `quiver_lua_runner_run` stores the Lua error message via `quiver_set_last_error()`. Test with an intentionally failing Lua script and confirm the error message is retrievable.
**Warning signs:** LuaRunner error tests pass but with generic "Unknown error" instead of the actual Lua error message.

### Pitfall 4: ArgumentError vs DatabaseException Confusion
**What goes wrong:** Changing some exceptions from `DatabaseException` to `ArgumentError` breaks tests that catch `DatabaseException`.
**Why it happens:** Tests may use `@test_throws Quiver.DatabaseException` for errors that are about to become `ArgumentError`.
**How to avoid:** Check each test that catches errors from the affected functions. Update test assertions to match the new exception type.
**Warning signs:** `@test_throws` failures because wrong exception type is thrown.

### Pitfall 5: Composite Functions Changing Behavior
**What goes wrong:** Replacing manual group lookup with `get_vector_metadata()` / `get_set_metadata()` in `read_vector_group_by_id` / `read_set_group_by_id` changes the error message when a group is not found.
**Why it happens:** The C API "group not found" error message format may differ from the Julia-crafted message.
**How to avoid:** This is actually desirable -- the C API message is the authoritative one. Verify the C API message is clear and informative.
**Warning signs:** None -- this is the intended behavior change.

## Code Examples

### Naming Rename Pattern (Only 1 function)

```julia
# BEFORE (database_delete.jl):
function delete_element_by_id!(db::Database, collection::String, id::Int64)
    check(C.quiver_database_delete_element(db.ptr, collection, id))
    return nothing
end

# AFTER (database_delete.jl):
function delete_element!(db::Database, collection::String, id::Int64)
    check(C.quiver_database_delete_element(db.ptr, collection, id))
    return nothing
end
```

### Error Handling Fix: LuaRunner Constructor

```julia
# BEFORE (lua_runner.jl):
function LuaRunner(db::Database)
    out_runner = Ref{Ptr{C.quiver_lua_runner}}(C_NULL)
    err = C.quiver_lua_runner_new(db.ptr, out_runner)
    if err != C.QUIVER_OK
        detail = unsafe_string(C.quiver_get_last_error())
        context = "Failed to create LuaRunner"
        throw(DatabaseException(isempty(detail) ? context : "$context: $detail"))
    end
    runner = LuaRunner(out_runner[], db)
    finalizer(r -> r.ptr != C_NULL && C.quiver_lua_runner_free(r.ptr), runner)
    return runner
end

# AFTER (lua_runner.jl):
function LuaRunner(db::Database)
    out_runner = Ref{Ptr{C.quiver_lua_runner}}(C_NULL)
    check(C.quiver_lua_runner_new(db.ptr, out_runner))
    runner = LuaRunner(out_runner[], db)
    finalizer(r -> r.ptr != C_NULL && C.quiver_lua_runner_free(r.ptr), runner)
    return runner
end
```

### Error Handling Fix: LuaRunner run!

```julia
# BEFORE (lua_runner.jl):
function run!(runner::LuaRunner, script::String)
    err = C.quiver_lua_runner_run(runner.ptr, script)
    if err != C.QUIVER_OK
        out_error = Ref{Ptr{Cchar}}(C_NULL)
        get_err = C.quiver_lua_runner_get_error(runner.ptr, out_error)
        if get_err == C.QUIVER_OK && out_error[] != C_NULL
            error_msg = unsafe_string(out_error[])
            throw(DatabaseException("Lua error: $error_msg"))
        else
            throw(DatabaseException("Lua script execution failed"))
        end
    end
    return nothing
end

# AFTER (lua_runner.jl):
function run!(runner::LuaRunner, script::String)
    check(C.quiver_lua_runner_run(runner.ptr, script))
    return nothing
end
```

### Error Handling Fix: Composite Group Functions

```julia
# BEFORE (database_read.jl, read_vector_group_by_id):
function read_vector_group_by_id(db::Database, collection::String, group::String, id::Int64)
    all_groups = list_vector_groups(db, collection)
    metadata = nothing
    for g in all_groups
        if g.group_name == group
            metadata = g
            break
        end
    end
    if metadata === nothing
        throw(DatabaseException("Vector group '$group' not found in collection '$collection'"))
    end
    # ... read columns based on metadata ...
end

# AFTER (database_read.jl, read_vector_group_by_id):
function read_vector_group_by_id(db::Database, collection::String, group::String, id::Int64)
    metadata = get_vector_metadata(db, collection, group)  # C API throws if not found
    columns = metadata.value_columns
    # ... read columns based on metadata ...
end
```

### Error Handling Fix: Defensive Type Branches

```julia
# BEFORE (database_read.jl):
if attribute.data_type == C.QUIVER_DATA_TYPE_INTEGER
    result[name] = read_scalar_integer_by_id(db, collection, name, id)
# ...
else
    throw(DatabaseException("Unsupported scalar data type for '$collection.$name'"))
end

# AFTER (database_read.jl):
if attribute.data_type == C.QUIVER_DATA_TYPE_INTEGER
    result[name] = read_scalar_integer_by_id(db, collection, name, id)
# ...
else
    throw(ArgumentError("Unsupported scalar data type $(attribute.data_type) for '$collection.$name'"))
end
```

## State of the Art

Not applicable -- this is internal refactoring of binding wrapper code, not adoption of external technology.

## Open Questions

### 1. Should the empty array check in element.jl be removed or kept?

**What we know:** `element.jl` line 83-98 handles `Vector{Any}` by checking for empty arrays and throwing `DatabaseException("Empty array not allowed for '$name'")`. This prevents the call from reaching the C API.

**What's unclear:** Whether the C++ layer properly rejects empty arrays with a clear error message.

**Recommendation:** Test the C++ behavior with empty arrays. If C++ throws `"Cannot create_element: element must have at least one scalar attribute"` or similar, the Julia check is redundant and should be removed. If C++ silently accepts empty arrays (which would be a bug), keep the Julia check temporarily and file a note to fix the C++ layer. Confidence: MEDIUM -- need to verify C++ behavior.

### 2. Does `quiver_lua_runner_run` store errors via `quiver_set_last_error`?

**What we know:** Phase 5 normalized lua_runner.cpp to use `extern "C"` and `QUIVER_C_API`. The try-catch pattern in lua_runner.cpp catches exceptions and calls `quiver_set_last_error(e.what())`.

**What's unclear:** Whether Lua script errors specifically (not just C++ exceptions) are stored in `quiver_set_last_error`. The Lua error path in the C++ code may use `quiver_lua_runner_get_error` to store a Lua-specific error and `quiver_set_last_error` to store a generic "script failed" message.

**Recommendation:** Before switching `run!` to use `check()`, manually test: (1) run an invalid Lua script, (2) call `quiver_get_last_error()` to see what message is stored. If the Lua error details are in `last_error`, `check()` is sufficient. If not, a hybrid approach is needed. Confidence: MEDIUM -- need runtime verification.

### 3. Should Julia-only composite functions (`read_all_*`, `read_*_group_by_id`) keep defensive type branches?

**What we know:** These functions dispatch based on `data_type` enum values. The `else` branch catches unknown types.

**What's unclear:** Whether `QUIVER_DATA_TYPE_DATE_TIME` and `QUIVER_DATA_TYPE_NULL` (values 3 and 4 of the enum) can appear in metadata results from the C API.

**Recommendation:** Keep the defensive branches but change the exception type from `DatabaseException` to `ArgumentError`. These are programming errors (exhaustiveness check), not database errors. Confidence: HIGH.

## Sources

### Primary (HIGH confidence)
- Direct source code analysis of all `bindings/julia/src/*.jl` files -- complete function inventory, error message catalog
- Direct source code analysis of all `bindings/julia/test/*.jl` files -- test call sites, error assertions
- Direct source code analysis of `bindings/julia/src/c_api.jl` -- FFI layer function names (post-Phase 5)
- Phase 5 Research (`05-RESEARCH.md`) -- C API naming decisions, cascade analysis
- Phase 3 Research (`03-RESEARCH.md`) -- C++ naming conventions, `_by_id` rules
- CLAUDE.md -- project principles ("Error Messages: All error messages are defined in the C++/C API layer. Bindings retrieve and surface them -- they never craft their own.")

### Secondary (MEDIUM confidence)
- Julia language documentation -- naming conventions (`!` suffix, `snake_case`, `PascalCase` for types)
- `bindings/julia/Project.toml` -- Julia 1.12 requirement, dependencies

## Metadata

**Confidence breakdown:**
- Naming audit: HIGH -- every Julia wrapper function cataloged, only 1 rename needed
- Error handling audit: HIGH -- every custom error message site found via grep, all 12 categorized
- C API mapping: HIGH -- every wrapper function mapped to its C API counterpart, verified from c_api.jl
- Remediation plan: MEDIUM -- LuaRunner error path needs runtime verification before implementing

**Research date:** 2026-02-10
**Valid until:** 2026-03-10 (stable -- internal refactoring, no external dependencies)
