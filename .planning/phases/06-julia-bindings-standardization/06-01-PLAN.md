---
phase: 06-julia-bindings-standardization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/julia/src/database_delete.jl
  - bindings/julia/src/element.jl
  - bindings/julia/src/lua_runner.jl
  - bindings/julia/src/database_read.jl
  - bindings/julia/test/test_database_delete.jl
  - bindings/julia/test/test_element.jl
autonomous: true
must_haves:
  truths:
    - "Every Julia wrapper function uses snake_case naming following Julia conventions"
    - "Julia function names map predictably from C API names (strip quiver_database_ prefix, add ! for mutating)"
    - "No custom error strings are defined in Julia wrapper code -- all DatabaseException messages originate from C API"
    - "Julia-side type dispatch errors use ArgumentError, not DatabaseException"
    - "Julia test suite passes (bindings/julia/test/test.bat green)"
  artifacts:
    - path: "bindings/julia/src/database_delete.jl"
      provides: "delete_element! function (renamed from delete_element_by_id!)"
      contains: "function delete_element!"
    - path: "bindings/julia/src/element.jl"
      provides: "Element setindex! without custom error messages"
    - path: "bindings/julia/src/lua_runner.jl"
      provides: "LuaRunner with standardized error handling"
      contains: "check(C.quiver_lua_runner_new"
    - path: "bindings/julia/src/database_read.jl"
      provides: "Composite read functions using get_vector_metadata/get_set_metadata instead of manual lookup"
      contains: "get_vector_metadata(db, collection, group)"
  key_links:
    - from: "bindings/julia/src/lua_runner.jl"
      to: "src/c/lua_runner.cpp"
      via: "quiver_lua_runner_get_error for run! errors (not check(), because lua_runner_run stores in runner->last_error not quiver_set_last_error)"
      pattern: "quiver_lua_runner_get_error"
    - from: "bindings/julia/src/database_read.jl"
      to: "bindings/julia/src/database_metadata.jl"
      via: "get_vector_metadata/get_set_metadata calls replacing manual group lookup"
      pattern: "get_vector_metadata|get_set_metadata"
    - from: "bindings/julia/src/element.jl"
      to: "src/c/element.cpp -> src/database_create.cpp"
      via: "Empty array rejection now handled by C++ layer through check()"
      pattern: "check\\(C\\.quiver_element_set_array"
---

<objective>
Standardize Julia binding names (NAME-03) and error handling (ERRH-03) so all wrapper functions use idiomatic Julia naming, map predictably from C API names, and surface C API error messages without crafting custom strings.

Purpose: Ensure the Julia binding layer is a thin wrapper that retrieves errors from the C API rather than defining its own error messages, completing the Julia standardization layer of the refactoring roadmap.
Output: 4 modified source files, 2 modified test files, all Julia tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-julia-bindings-standardization/06-RESEARCH.md
@bindings/julia/src/database_delete.jl
@bindings/julia/src/element.jl
@bindings/julia/src/lua_runner.jl
@bindings/julia/src/database_read.jl
@bindings/julia/src/database_metadata.jl
@bindings/julia/src/exceptions.jl
@bindings/julia/test/test_database_delete.jl
@bindings/julia/test/test_element.jl
@bindings/julia/test/test_lua_runner.jl
@src/c/lua_runner.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rename delete_element_by_id! and standardize element.jl + lua_runner.jl error handling</name>
  <files>
    bindings/julia/src/database_delete.jl
    bindings/julia/src/element.jl
    bindings/julia/src/lua_runner.jl
    bindings/julia/test/test_database_delete.jl
    bindings/julia/test/test_element.jl
  </files>
  <action>
**database_delete.jl -- Rename function (NAME-03):**
- Rename `delete_element_by_id!` to `delete_element!` (function signature on line 1).
- The function body already calls `C.quiver_database_delete_element` correctly (Phase 5 renamed the C API).

**test_database_delete.jl -- Update 5 call sites:**
- Replace all 5 occurrences of `Quiver.delete_element_by_id!` with `Quiver.delete_element!`.
- Lines 23, 60, 90, 112, 132.

**element.jl -- Fix 2 custom error sites (ERRH-03):**

1. **Line 84-86 (empty array check):** Remove the `if isempty(value)` / `throw(DatabaseException(...))` block entirely. The C++ layer already rejects empty arrays with `"Cannot create_element: empty array not allowed for '{name}'"` which surfaces through `check()`. After removal, the `Vector{Any}` method should dispatch on `first(value)` directly. If the array is empty, `first()` will throw a standard Julia `ArgumentError` which is acceptable for this edge case. Replace the entire `Base.setindex!(el::Element, value::Vector{Any}, name::String)` method body:

```julia
function Base.setindex!(el::Element, value::Vector{Any}, name::String)
    if isempty(value)
        throw(ArgumentError("Cannot determine array element type for '$name': array is empty"))
    end
    first_val = first(value)
    if first_val isa Integer
        el[name] = Int64[Int64(v) for v in value]
    elseif first_val isa AbstractFloat
        el[name] = Float64[Float64(v) for v in value]
    elseif first_val isa AbstractString
        el[name] = String[String(v) for v in value]
    else
        throw(ArgumentError("Unsupported array element type for '$name': $(typeof(first_val))"))
    end
end
```

Key changes: (a) Empty array now throws `ArgumentError` instead of `DatabaseException` -- this is a Julia-side type dispatch issue, not a database error. (b) Unsupported type on line 96 changes from `error()` to `throw(ArgumentError(...))` for consistency.

2. **test_element.jl line 68:** Update the "Empty Array Rejected" test to expect `ArgumentError` instead of `DatabaseException`:
```julia
@test_throws ArgumentError el["values"] = Any[]
```

**lua_runner.jl -- Standardize error handling (ERRH-03):**

1. **LuaRunner constructor (lines 7-17):** Replace manual error handling with `check()`. The C API `quiver_lua_runner_new` DOES call `quiver_set_last_error` on failure, so `check()` works here:

```julia
function LuaRunner(db::Database)
    out_runner = Ref{Ptr{C.quiver_lua_runner}}(C_NULL)
    check(C.quiver_lua_runner_new(db.ptr, out_runner))
    runner = LuaRunner(out_runner[], db)
    finalizer(r -> r.ptr != C_NULL && C.quiver_lua_runner_free(r.ptr), runner)
    return runner
end
```

2. **run! function (lines 19-32):** CANNOT use `check()` because `quiver_lua_runner_run` stores errors in `runner->last_error` (NOT `quiver_set_last_error`). Replace with direct error retrieval from `quiver_lua_runner_get_error` WITHOUT adding custom prefixes:

```julia
function run!(runner::LuaRunner, script::String)
    err = C.quiver_lua_runner_run(runner.ptr, script)
    if err != C.QUIVER_OK
        out_error = Ref{Ptr{Cchar}}(C_NULL)
        get_err = C.quiver_lua_runner_get_error(runner.ptr, out_error)
        if get_err == C.QUIVER_OK && out_error[] != C_NULL
            error_msg = unsafe_string(out_error[])
            if !isempty(error_msg)
                throw(DatabaseException(error_msg))
            end
        end
        throw(DatabaseException("Lua script execution failed"))
    end
    return nothing
end
```

Key changes: (a) Removed "Lua error: " prefix from the error message -- surfaces the C API error directly. (b) Kept the fallback "Lua script execution failed" message only for the edge case where `quiver_lua_runner_get_error` returns no message. This is acceptable as a safety net (same pattern as `check()`'s "Unknown error" fallback).

**No changes needed to test_lua_runner.jl** -- all tests use `@test_throws Quiver.DatabaseException` without checking message content, so the removal of "Lua error:" prefix is transparent.
  </action>
  <verify>
Build the C++ library first (required for Julia FFI): `cmake --build build --config Debug`
Then run Julia tests: `bindings/julia/test/test.bat`
Specifically verify:
- "Empty Array Rejected" test passes with ArgumentError
- All delete tests pass with `delete_element!` (not `_by_id`)
- All LuaRunner error tests pass ("Script Error", "Undefined Variable", "Create Invalid Collection")
  </verify>
  <done>
- `delete_element_by_id!` renamed to `delete_element!` in source and all 5 test call sites
- element.jl has zero DatabaseException strings (empty array -> ArgumentError, unsupported type -> ArgumentError)
- lua_runner.jl constructor uses check() pattern
- lua_runner.jl run! surfaces C API error without custom prefix
- All Julia tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Standardize database_read.jl composite function error handling</name>
  <files>
    bindings/julia/src/database_read.jl
  </files>
  <action>
**Fix 7 custom error sites in composite read functions (ERRH-03):**

1. **read_all_scalars_by_id (line 417):** Change defensive else branch from `DatabaseException` to `ArgumentError`:
```julia
else
    throw(ArgumentError("Unsupported scalar data type $(attribute.data_type) for '$collection.$name'"))
end
```

2. **read_all_vectors_by_id (line 437):** Change defensive else branch from `DatabaseException` to `ArgumentError`:
```julia
else
    throw(ArgumentError("Unsupported vector data type $(data_type) for '$collection.$name'"))
end
```

3. **read_all_sets_by_id (line 457):** Change defensive else branch from `DatabaseException` to `ArgumentError`:
```julia
else
    throw(ArgumentError("Unsupported set data type $(data_type) for '$collection.$name'"))
end
```

4. **read_vector_group_by_id (lines 463-475):** Replace the manual group lookup (iterating `list_vector_groups` and checking `g.group_name == group`) with a direct call to `get_vector_metadata`. This eliminates the custom "Vector group not found" error -- if the group doesn't exist, `get_vector_metadata` will throw via `check()` with the C API error message. Replace lines 464-475:

```julia
function read_vector_group_by_id(db::Database, collection::String, group::String, id::Int64)
    metadata = get_vector_metadata(db, collection, group)
    columns = metadata.value_columns
```

Keep the rest of the function body unchanged (the `if isempty(columns)` check, the column reading loop, the transpose logic).

5. **read_vector_group_by_id (line 497):** Change defensive else branch from `DatabaseException` to `ArgumentError`:
```julia
else
    throw(ArgumentError("Unsupported data type $(col.data_type) for column '$(col.name)'"))
end
```

6. **read_set_group_by_id (lines 517-529):** Same pattern as #4 -- replace manual group lookup with `get_set_metadata`. Replace lines 518-530:

```julia
function read_set_group_by_id(db::Database, collection::String, group::String, id::Int64)
    metadata = get_set_metadata(db, collection, group)
    columns = metadata.value_columns
```

Keep the rest of the function body unchanged.

7. **read_set_group_by_id (line 551):** Change defensive else branch from `DatabaseException` to `ArgumentError`:
```julia
else
    throw(ArgumentError("Unsupported data type $(col.data_type) for column '$(col.name)'"))
end
```

**Summary of changes:** 5 `DatabaseException` -> `ArgumentError` conversions for defensive type branches. 2 manual group lookups replaced with `get_vector_metadata`/`get_set_metadata` calls (eliminating 2 custom "not found" error messages). Total: 7 custom error sites eliminated.

**No test file changes needed** -- no existing tests assert on these specific error paths (they test the happy paths of composite read functions).
  </action>
  <verify>
Run Julia tests: `bindings/julia/test/test.bat`
Specifically verify:
- test_database_read.jl passes (exercises read_all_scalars_by_id, read_all_vectors_by_id, etc.)
- No regressions in other test files
  </verify>
  <done>
- database_read.jl has zero DatabaseException strings
- read_vector_group_by_id uses get_vector_metadata instead of manual lookup
- read_set_group_by_id uses get_set_metadata instead of manual lookup
- All 5 defensive type branches use ArgumentError
- All Julia tests pass
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `bindings/julia/test/test.bat` passes (all Julia tests green)
2. Grep for `DatabaseException(` in `bindings/julia/src/` -- should only appear in `exceptions.jl` (the check() function) and the single fallback in lua_runner.jl run! function
3. Grep for `error(` (bare Julia error) in `bindings/julia/src/` -- should return zero hits in wrapper files (only in c_api.jl if any)
4. `delete_element_by_id!` appears nowhere in any Julia source or test file
</verification>

<success_criteria>
- NAME-03 satisfied: All Julia wrapper functions use snake_case and map predictably from C API names. The only rename needed (delete_element_by_id! -> delete_element!) is complete.
- ERRH-03 satisfied: Zero custom DatabaseException error messages in Julia wrapper code. All database errors surface from C API via check(). Julia-side type dispatch errors use ArgumentError.
- All Julia tests pass without modification to test assertions (except test_element.jl "Empty Array Rejected" which expects ArgumentError).
</success_criteria>

<output>
After completion, create `.planning/phases/06-julia-bindings-standardization/06-01-SUMMARY.md`
</output>
