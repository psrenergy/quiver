---
phase: 03-python-datatype-constants
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/python/src/quiverdb/metadata.py
  - bindings/python/src/quiverdb/__init__.py
  - bindings/python/src/quiverdb/database.py
  - bindings/python/tests/test_database_metadata.py
autonomous: true
requirements:
  - PY-02
must_haves:
  truths:
    - "DataType IntEnum exists with values INTEGER=0, FLOAT=1, STRING=2, DATE_TIME=3, NULL=4"
    - "No bare integer literals 0/1/2/3/4 remain in database.py for data type dispatch"
    - "ScalarMetadata.data_type returns a DataType enum value, not a plain int"
    - "DataType is importable from quiverdb package top-level"
    - "Python test suite passes with all DataType replacements"
  artifacts:
    - path: "bindings/python/src/quiverdb/metadata.py"
      provides: "DataType IntEnum definition"
      contains: "class DataType(IntEnum)"
    - path: "bindings/python/src/quiverdb/__init__.py"
      provides: "DataType in public exports"
      contains: "DataType"
    - path: "bindings/python/src/quiverdb/database.py"
      provides: "All magic integers replaced with DataType members"
    - path: "bindings/python/tests/test_database_metadata.py"
      provides: "Test validating DataType values match C API constants"
  key_links:
    - from: "bindings/python/src/quiverdb/metadata.py"
      to: "bindings/python/src/quiverdb/database.py"
      via: "from quiverdb.metadata import DataType"
      pattern: "from quiverdb\\.metadata import.*DataType"
    - from: "bindings/python/src/quiverdb/metadata.py"
      to: "bindings/python/src/quiverdb/__init__.py"
      via: "re-export DataType in __all__"
      pattern: "DataType"
---

<objective>
Replace all hardcoded magic integer literals (0, 1, 2, 3, 4) used for data type dispatch in the Python binding with a `DataType` IntEnum, and update `ScalarMetadata.data_type` to return an enum value.

Purpose: Eliminates ~30 magic integers across database.py, making type dispatch self-documenting and consistent with how Julia and Dart reference C API data type constants.

Output: DataType IntEnum in metadata.py, all magic integers replaced in database.py, public export in __init__.py, validation test in test_database_metadata.py.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-python-datatype-constants/03-RESEARCH.md

@bindings/python/src/quiverdb/metadata.py
@bindings/python/src/quiverdb/__init__.py
@bindings/python/src/quiverdb/database.py
@bindings/python/tests/test_database_metadata.py

<interfaces>
<!-- Current metadata.py structure (will be modified) -->
From bindings/python/src/quiverdb/metadata.py:
```python
@dataclass(frozen=True)
class ScalarMetadata:
    name: str
    data_type: int          # Change to DataType
    not_null: bool
    primary_key: bool
    default_value: str | None
    is_foreign_key: bool
    references_collection: str | None
    references_column: str | None
```

From bindings/python/src/quiverdb/__init__.py:
```python
from quiverdb.metadata import CSVOptions, GroupMetadata, ScalarMetadata
__all__ = ["CSVOptions", "Database", "DatabaseCSVExport", "DatabaseCSVImport", "GroupMetadata", "QuiverError", "ScalarMetadata", "version"]
```

From bindings/python/src/quiverdb/database.py (line 13):
```python
from quiverdb.metadata import GroupMetadata, ScalarMetadata
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define DataType IntEnum and update exports</name>
  <files>
    bindings/python/src/quiverdb/metadata.py
    bindings/python/src/quiverdb/__init__.py
    bindings/python/src/quiverdb/database.py
  </files>
  <action>
**Step 1: Add DataType IntEnum to metadata.py**

Add `from enum import IntEnum` at the top of `metadata.py` (after `from dataclasses import dataclass, field`).

Define `DataType(IntEnum)` class BEFORE the `ScalarMetadata` dataclass (since ScalarMetadata references it). Values must exactly match C API `quiver_data_type_t`:

```python
class DataType(IntEnum):
    """Data type constants matching C API quiver_data_type_t."""
    INTEGER = 0
    FLOAT = 1
    STRING = 2
    DATE_TIME = 3
    NULL = 4
```

Change `ScalarMetadata.data_type` type annotation from `int` to `DataType`.

**Step 2: Update __init__.py exports**

Add `DataType` to the import line:
```python
from quiverdb.metadata import CSVOptions, DataType, GroupMetadata, ScalarMetadata
```

Add `"DataType"` to the `__all__` list (in alphabetical position, after `"CSVOptions"`).

**Step 3: Update database.py import**

Change line 13 from:
```python
from quiverdb.metadata import GroupMetadata, ScalarMetadata
```
to:
```python
from quiverdb.metadata import DataType, GroupMetadata, ScalarMetadata
```
  </action>
  <verify>
    <automated>cd C:/Development/DatabaseTmp/quiver4/bindings/python && set "PATH=%cd%\..\..\build\bin;%PATH%" && uv run python -c "from quiverdb import DataType; assert DataType.INTEGER == 0; assert DataType.NULL == 4; print('DataType import OK')"</automated>
  </verify>
  <done>DataType IntEnum exists in metadata.py with correct values, ScalarMetadata.data_type annotated as DataType, DataType exported from quiverdb package.</done>
</task>

<task type="auto">
  <name>Task 2: Replace all magic integers in database.py and add validation test</name>
  <files>
    bindings/python/src/quiverdb/database.py
    bindings/python/tests/test_database_metadata.py
  </files>
  <action>
**Step 1: Replace magic integers in database.py**

This is a mechanical replacement across ~30 sites in 7 code contexts. Use the research inventory (03-RESEARCH.md "Inventory of Magic Integer Sites") as the authoritative checklist.

**Context 1 -- ScalarMetadata construction** (`_parse_scalar_metadata` function):
- Change `data_type=int(meta.data_type)` to `data_type=DataType(int(meta.data_type))`

**Context 2 -- Composite read dispatch** (5 methods):
In `read_scalars_by_id`, `read_vectors_by_id`, `read_sets_by_id`, `read_vector_group_by_id`, `read_set_group_by_id`:
- Replace `== 0` with `== DataType.INTEGER`
- Replace `== 1` with `== DataType.FLOAT`
- Replace `== 3` with `== DataType.DATE_TIME`
- The `else` branches already handle STRING (value 2) -- leave them as `else` (no change needed since STRING is the fallback)

**Context 3 -- Time series read dispatch** (`read_time_series_group`):
- Replace `ctype == 0` with `ctype == DataType.INTEGER`
- Replace `ctype == 1` with `ctype == DataType.FLOAT`
- The `else` branch handles STRING/DATE_TIME -- leave as `else`

**Context 4 -- Param marshaling** (`_marshal_params` function):
- Replace `c_types[i] = 4` with `c_types[i] = DataType.NULL`
- Replace `c_types[i] = 0` with `c_types[i] = DataType.INTEGER`
- Replace `c_types[i] = 1` with `c_types[i] = DataType.FLOAT`
- Replace `c_types[i] = 2` with `c_types[i] = DataType.STRING`

**Context 5 -- Time series write marshaling** (`_marshal_time_series_columns`):
- Replace hardcoded `2` in `columns.append((metadata.dimension_column, 2))` with `DataType.STRING`
- Replace `col_type == 0` with `col_type == DataType.INTEGER` (validation block)
- Replace `col_type == 1` with `col_type == DataType.FLOAT` (validation block)
- Replace `col_type == 0` with `col_type == DataType.INTEGER` (data build block)
- Replace `col_type == 1` with `col_type == DataType.FLOAT` (data build block)
- Leave `else` branches as-is (handle STRING/DATE_TIME as fallback)

**IMPORTANT:** IntEnum is-a int. Do NOT add unnecessary `int()` casts around DataType members. They pass directly to CFFI arrays.

**IMPORTANT:** Do NOT change any `isinstance` checks in `_marshal_params`. Only replace the `c_types[i] = N` assignments.

**Step 2: Add DataType validation test to test_database_metadata.py**

Add a test function to `test_database_metadata.py` that validates DataType enum values match the C API constants:

```python
def test_datatype_values_match_c_api():
    """Verify DataType enum values match CFFI quiver_data_type_t constants."""
    from quiverdb import DataType
    from quiverdb._c_api import get_lib

    lib = get_lib()
    assert DataType.INTEGER == lib.QUIVER_DATA_TYPE_INTEGER
    assert DataType.FLOAT == lib.QUIVER_DATA_TYPE_FLOAT
    assert DataType.STRING == lib.QUIVER_DATA_TYPE_STRING
    assert DataType.DATE_TIME == lib.QUIVER_DATA_TYPE_DATE_TIME
    assert DataType.NULL == lib.QUIVER_DATA_TYPE_NULL
```

Also add a test that verifies `ScalarMetadata.data_type` returns a `DataType` instance (not a plain int). This can be added to an existing metadata test or as a new function:

```python
def test_scalar_metadata_data_type_is_datatype_enum(db):
    """Verify ScalarMetadata.data_type returns DataType enum, not plain int."""
    from quiverdb import DataType

    meta = db.get_scalar_metadata("Items", "label")
    assert isinstance(meta.data_type, DataType)
    assert meta.data_type == DataType.STRING
```

Use an appropriate `db` fixture -- check existing tests in the file for the fixture pattern used.

**Step 3: Verify no bare magic integers remain**

After all replacements, search database.py for any remaining bare `== 0`, `== 1`, `== 2`, `== 3`, `== 4` comparisons that relate to data type dispatch. There should be none (legitimate integer comparisons for other purposes like vector_index are fine).
  </action>
  <verify>
    <automated>cd C:/Development/DatabaseTmp/quiver4/bindings/python && set "PATH=%cd%\..\..\build\bin;%PATH%" && uv run pytest tests/ -x -v</automated>
  </verify>
  <done>All ~30 magic integers in database.py replaced with DataType members. test_datatype_values_match_c_api and test_scalar_metadata_data_type_is_datatype_enum pass. Full Python test suite passes with zero regressions.</done>
</task>

</tasks>

<verification>
1. `from quiverdb import DataType` works and DataType has 5 members (INTEGER, FLOAT, STRING, DATE_TIME, NULL)
2. `ScalarMetadata.data_type` returns a `DataType` instance, not a plain `int`
3. No bare integer literals (0, 1, 2, 3, 4) remain in database.py for data type dispatch
4. Full Python test suite passes: `bindings/python/tests/test.bat`
5. DataType validation test confirms enum values match C API `quiver_data_type_t` constants
</verification>

<success_criteria>
- DataType IntEnum defined in metadata.py with values matching C API (INTEGER=0, FLOAT=1, STRING=2, DATE_TIME=3, NULL=4)
- ScalarMetadata.data_type annotated as DataType, returns DataType on construction
- All ~30 magic integers in database.py replaced with DataType members across all 7 contexts
- DataType exported in __init__.py __all__
- Test validates DataType values match CFFI lib constants
- Test validates ScalarMetadata.data_type is a DataType instance
- Full Python test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-python-datatype-constants/03-01-SUMMARY.md`
</output>
