---
phase: 06-csv-and-convenience-helpers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/python/src/quiver/_c_api.py
  - bindings/python/src/quiver/metadata.py
  - bindings/python/src/quiver/database.py
  - bindings/python/src/quiver/__init__.py
  - bindings/python/tests/conftest.py
  - bindings/python/tests/test_database_csv.py
  - .planning/REQUIREMENTS.md
autonomous: true
requirements:
  - CSV-01
  - CSV-02

must_haves:
  truths:
    - "export_csv(collection, group, path, options) writes a CSV file with correct scalar data"
    - "CSVExportOptions with enum_labels maps integer values to string labels in CSV output"
    - "CSVExportOptions with date_time_format formats datetime columns in CSV output"
    - "export_csv with default options (no enum, no date format) produces correct unformatted CSV"
    - "import_csv(table, path) exists as a Python method that raises NotImplementedError with a clear message"
  artifacts:
    - path: "bindings/python/src/quiver/_c_api.py"
      provides: "CFFI cdef for quiver_csv_export_options_t struct and quiver_database_export_csv"
      contains: "quiver_csv_export_options_t"
    - path: "bindings/python/src/quiver/metadata.py"
      provides: "CSVExportOptions frozen dataclass"
      contains: "class CSVExportOptions"
    - path: "bindings/python/src/quiver/database.py"
      provides: "export_csv method, import_csv stub, and _marshal_csv_export_options helper"
      contains: "_marshal_csv_export_options"
    - path: "bindings/python/tests/test_database_csv.py"
      provides: "CSV export tests"
  key_links:
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "_marshal_csv_export_options builds C struct, export_csv calls lib.quiver_database_export_csv"
      pattern: "quiver_database_export_csv"
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/metadata.py"
      via: "import CSVExportOptions"
      pattern: "from quiver.metadata import.*CSVExportOptions"
---

<objective>
Bind the C API CSV export function to Python with full CSVExportOptions struct marshaling, and bind import_csv as a stub that raises NotImplementedError (C++ implementation is a no-op stub, but user decision requires the binding to exist in this phase).

Purpose: Completes CSV export/import capability in the Python binding, the only FFI work in Phase 6.
Output: Working `export_csv` method with CSVExportOptions dataclass, `import_csv` stub method, CFFI declarations, marshaling helper, and tests.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-csv-and-convenience-helpers/06-RESEARCH.md

@bindings/python/src/quiver/_c_api.py
@bindings/python/src/quiver/metadata.py
@bindings/python/src/quiver/database.py
@bindings/python/src/quiver/__init__.py
@bindings/python/tests/conftest.py
@include/quiver/c/options.h
@tests/schemas/valid/csv_export.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CFFI declarations, CSVExportOptions dataclass, marshaling helper, and export_csv method</name>
  <files>
    bindings/python/src/quiver/_c_api.py
    bindings/python/src/quiver/metadata.py
    bindings/python/src/quiver/database.py
    bindings/python/src/quiver/__init__.py
  </files>
  <action>
1. Add CFFI cdef declarations to `_c_api.py` for CSV export. Append to the existing `ffi.cdef(...)` string, before the closing `""")`:

```
// CSV export options
typedef struct {
    const char* date_time_format;
    const char** enum_attribute_names;
    const size_t* enum_entry_counts;
    const int64_t* enum_values;
    const char** enum_labels;
    size_t enum_attribute_count;
} quiver_csv_export_options_t;

quiver_csv_export_options_t quiver_csv_export_options_default(void);

quiver_error_t quiver_database_export_csv(quiver_database_t* db,
    const char* collection, const char* group, const char* path,
    const quiver_csv_export_options_t* opts);
```

Note: Use `const char**` (not `const char* const*`) per project decision [04-01] -- CFFI ABI-mode ignores const qualifiers and `const char* const*` may cause parser errors.

2. Add `CSVExportOptions` frozen dataclass to `metadata.py`:
```python
from dataclasses import dataclass, field

@dataclass(frozen=True)
class CSVExportOptions:
    """Options for CSV export operations."""
    date_time_format: str = ""
    enum_labels: dict[str, dict[int, str]] = field(default_factory=dict)
```

3. Add module-level `_marshal_csv_export_options` function to `database.py` (after the existing `_marshal_time_series_columns` function). Follow the established `_marshal_params` / `_marshal_time_series_columns` keepalive pattern exactly:

```python
def _marshal_csv_export_options(options: CSVExportOptions) -> tuple:
    """Marshal CSVExportOptions into C API struct pointer.

    Returns (keepalive, c_opts) where keepalive must stay referenced
    during the C API call.
    """
    keepalive: list = []
    c_opts = ffi.new("quiver_csv_export_options_t*")

    # date_time_format
    dtf_buf = ffi.new("char[]", options.date_time_format.encode("utf-8"))
    keepalive.append(dtf_buf)
    c_opts.date_time_format = dtf_buf

    if not options.enum_labels:
        c_opts.enum_attribute_names = ffi.NULL
        c_opts.enum_entry_counts = ffi.NULL
        c_opts.enum_values = ffi.NULL
        c_opts.enum_labels = ffi.NULL
        c_opts.enum_attribute_count = 0
        return keepalive, c_opts

    attr_count = len(options.enum_labels)
    c_attr_names = ffi.new("const char*[]", attr_count)
    keepalive.append(c_attr_names)
    c_entry_counts = ffi.new("size_t[]", attr_count)
    keepalive.append(c_entry_counts)

    total_entries = sum(len(entries) for entries in options.enum_labels.values())
    c_values = ffi.new("int64_t[]", total_entries)
    keepalive.append(c_values)
    c_labels = ffi.new("const char*[]", total_entries)
    keepalive.append(c_labels)

    entry_idx = 0
    for attr_idx, (attr_name, entries) in enumerate(options.enum_labels.items()):
        name_buf = ffi.new("char[]", attr_name.encode("utf-8"))
        keepalive.append(name_buf)
        c_attr_names[attr_idx] = name_buf
        c_entry_counts[attr_idx] = len(entries)
        for val, label in entries.items():
            c_values[entry_idx] = val
            label_buf = ffi.new("char[]", label.encode("utf-8"))
            keepalive.append(label_buf)
            c_labels[entry_idx] = label_buf
            entry_idx += 1

    c_opts.enum_attribute_names = c_attr_names
    c_opts.enum_entry_counts = c_entry_counts
    c_opts.enum_values = c_values
    c_opts.enum_labels = c_labels
    c_opts.enum_attribute_count = attr_count

    return keepalive, c_opts
```

4. Add `export_csv` method to the `Database` class in `database.py`. Place it after the `update_time_series_files` method, before `__repr__`. Signature: `export_csv(self, collection: str, group: str, path: str, options: CSVExportOptions | None = None)`. When `options is None`, default to `CSVExportOptions()`.

```python
def export_csv(
    self, collection: str, group: str, path: str,
    options: CSVExportOptions | None = None,
) -> None:
    """Export a collection or group to CSV file."""
    self._ensure_open()
    lib = get_lib()
    if options is None:
        options = CSVExportOptions()
    keepalive, c_opts = _marshal_csv_export_options(options)
    check(lib.quiver_database_export_csv(
        self._ptr, collection.encode("utf-8"), group.encode("utf-8"),
        path.encode("utf-8"), c_opts))
```

5. Add `import_csv` stub method to the `Database` class, immediately after `export_csv`. This binding exists per user decision — the C++ implementation is a no-op stub, so the Python method raises `NotImplementedError` with a clear message:

```python
def import_csv(self, table: str, path: str) -> None:
    """Import CSV data into a table.

    Not yet implemented — the C++ implementation is a no-op stub.
    Will be functional when the C++ layer implements import_csv.
    """
    raise NotImplementedError(
        "import_csv is not yet implemented: the C++ implementation is a no-op stub"
    )
```

6. Update `database.py` import line to include `CSVExportOptions`:
Change `from quiver.metadata import GroupMetadata, ScalarMetadata` to `from quiver.metadata import CSVExportOptions, GroupMetadata, ScalarMetadata`.

7. Update `__init__.py` to export `CSVExportOptions`:
Add `CSVExportOptions` to the import line and `__all__` list.
  </action>
  <verify>
Run `python -c "from quiver import CSVExportOptions; print(CSVExportOptions())"` to confirm import works and defaults are correct. Run `python -c "from quiver import Database; assert hasattr(Database, 'import_csv')"` to confirm import_csv stub exists.
  </verify>
  <done>CSVExportOptions dataclass is importable with correct defaults. export_csv method exists on Database. import_csv stub method exists on Database and raises NotImplementedError. CFFI declarations parse without error. _marshal_csv_export_options follows keepalive pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Add CSV export tests and update REQUIREMENTS.md to defer CSV-02</name>
  <files>
    bindings/python/tests/conftest.py
    bindings/python/tests/test_database_csv.py
    .planning/REQUIREMENTS.md
  </files>
  <action>
1. Add `csv_export_schema_path` and `csv_db` fixtures to `conftest.py`:
```python
@pytest.fixture
def csv_export_schema_path(schemas_path: Path) -> Path:
    """Return the path to the CSV export test schema."""
    return schemas_path / "valid" / "csv_export.sql"

@pytest.fixture
def csv_db(csv_export_schema_path: Path, tmp_path: Path) -> Generator[Database, None, None]:
    """Create a test database with the CSV export schema."""
    database = Database.from_schema(str(tmp_path / "csv.db"), str(csv_export_schema_path))
    yield database
    database.close()
```

2. Create `test_database_csv.py` with tests covering:
   - **test_export_csv_scalars_default**: Create elements with scalar data (name, status integer, price float, date_created, notes), export with `group=""` (scalars) and default options. Read the CSV file and verify header and data rows.
   - **test_export_csv_with_enum_labels**: Create elements with integer `status` values, export with `CSVExportOptions(enum_labels={"status": {1: "Active", 2: "Inactive"}})`. Verify the CSV contains "Active"/"Inactive" instead of "1"/"2".
   - **test_export_csv_with_date_format**: Create elements with `date_created` ISO strings, export with `CSVExportOptions(date_time_format="%Y-%m-%d")`. Verify the datetime is formatted per strftime.
   - **test_export_csv_with_enum_and_date**: Both options combined.
   - **test_export_csv_group**: Create elements with vector measurements, export with `group="measurements"`. Verify CSV contains group data.
   - **test_export_csv_null_values**: Create element with NULL optional fields, export. Verify NULLs appear correctly (empty fields in CSV).

   Each test should:
   - Create test data via `Element().set(...)` and `create_element`
   - Call `db.export_csv("Items", group, str(tmp_path / "output.csv"), options)`
   - Read the CSV file with Python's `csv` module and assert on content

3. Add a test for `import_csv` stub: `test_import_csv_raises_not_implemented` — call `db.import_csv("Items", "any.csv")`, assert it raises `NotImplementedError` with message containing "not yet implemented".

4. Update `.planning/REQUIREMENTS.md`:
   - Change CSV-02 line to `- [ ] **CSV-02**: import_csv stub bound (raises NotImplementedError — C++ implementation is a no-op stub)`
   - Update traceability table: change CSV-02 status from `Pending` to `Stub`
  </action>
  <verify>
Run `bindings/python/test/test.bat` or `python -m pytest bindings/python/tests/test_database_csv.py -v` to verify all CSV tests pass. Verify REQUIREMENTS.md shows CSV-02 as Deferred.
  </verify>
  <done>All CSV export tests pass covering default export, enum labels, date formatting, combined options, group export, and NULL handling. import_csv stub test passes (NotImplementedError raised). REQUIREMENTS.md updated to show CSV-02 as stub bound.</done>
</task>

</tasks>

<verification>
1. `python -m pytest bindings/python/tests/test_database_csv.py -v` -- all CSV export tests pass (including import_csv stub test)
2. `python -c "from quiver import CSVExportOptions; o = CSVExportOptions(date_time_format='%Y', enum_labels={'status': {1: 'Active'}}); print(o)"` -- dataclass constructs correctly
3. `python -c "from quiver import Database; d = Database.__new__(Database); d.import_csv('t', 'p')"` -- raises NotImplementedError
4. REQUIREMENTS.md shows CSV-02 as Stub with explanation
</verification>

<success_criteria>
- CSVExportOptions dataclass is importable from `quiver` package
- export_csv method writes correct CSV files with scalar and group data
- Enum label resolution replaces integer values with string labels in CSV output
- DateTime formatting applies strftime format to datetime columns
- All CFFI keepalive references prevent premature GC during C API calls
- import_csv(table, path) exists on Database and raises NotImplementedError with clear message
- CSV-02 marked as Stub in REQUIREMENTS.md
</success_criteria>

<output>
After completion, create `.planning/phases/06-csv-and-convenience-helpers/06-01-SUMMARY.md`
</output>
