---
phase: 02-loader-rewrite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/python/src/quiverdb/_loader.py
  - CMakeLists.txt
autonomous: true
requirements: [LOAD-01, LOAD-02, LOAD-03]

must_haves:
  truths:
    - "Bundled _libs/ directory is discovered relative to _loader.py using Path(__file__)"
    - "When bundled libs exist but fail to load, RuntimeError is raised immediately (no dev fallback)"
    - "When _libs/ is missing or empty, dev-mode fallback loads from system PATH"
    - "os.add_dll_directory() is called on Windows for the bundled lib directory"
    - "Module-level _load_source attribute indicates which strategy succeeded"
    - "Linux RPATH $ORIGIN is set on libquiver_c for SKBUILD builds"
  artifacts:
    - path: "bindings/python/src/quiverdb/_loader.py"
      provides: "Bundled-first library discovery with dev-mode fallback"
      contains: "_load_source"
    - path: "CMakeLists.txt"
      provides: "INSTALL_RPATH $ORIGIN for libquiver_c in SKBUILD builds"
      contains: "INSTALL_RPATH"
  key_links:
    - from: "bindings/python/src/quiverdb/_loader.py"
      to: "bindings/python/src/quiverdb/_c_api.py"
      via: "load_library(ffi) called from get_lib()"
      pattern: "load_library"
    - from: "CMakeLists.txt"
      to: "bindings/python/src/quiverdb/_loader.py"
      via: "RPATH ensures libquiver_c.so finds libquiver.so at runtime"
      pattern: "INSTALL_RPATH"
---

<objective>
Rewrite `_loader.py` with bundled-first library discovery and add Linux RPATH for wheel builds.

Purpose: When installed from a wheel, `import quiverdb` must load native libraries from the `_libs/` subdirectory without any PATH configuration. Development mode must still work via system PATH fallback.

Output: Rewritten `_loader.py` with two-step fallback chain, diagnostic error messages, `_load_source` attribute, and CMake RPATH addition for Linux SKBUILD builds.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-loader-rewrite/02-CONTEXT.md
@.planning/phases/02-loader-rewrite/02-RESEARCH.md
@.planning/phases/01-build-system-migration/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite _loader.py with bundled-first discovery and dev-mode fallback</name>
  <files>bindings/python/src/quiverdb/_loader.py</files>
  <action>
Rewrite `bindings/python/src/quiverdb/_loader.py` in place. Delete all existing code and replace with the new loader. The new loader must:

**Module-level constants:**
- `_PACKAGE_DIR = Path(__file__).resolve().parent`
- `_LIBS_DIR = _PACKAGE_DIR / "_libs"`
- `_EXT = ".dll" if sys.platform == "win32" else ".so"` (runtime-derived, no hardcoding)
- `_LIB_CORE = f"libquiver{_EXT}"`
- `_LIB_C_API = f"libquiver_c{_EXT}"`
- `_load_source: str = ""` (module-level attribute set after successful load)
- `_dll_dir_handle = None` (Windows DLL directory handle, kept alive for process lifetime)

**`load_library(ffi: FFI)` function — two-step fallback chain:**

Step 1 — Bundled mode (primary path for wheel installs):
- Check if `_LIBS_DIR / _LIB_C_API` exists (not just directory existence — per Pitfall 3 from research)
- If exists:
  - On Windows (`sys.platform == "win32"`): call `os.add_dll_directory(str(_LIBS_DIR))` and store the returned handle in `_dll_dir_handle` at module level (per Pitfall 5 — handle must survive garbage collection)
  - Pre-load `libquiver` with `ffi.dlopen(str(core_path))` using absolute path (per Pitfall 4)
  - Load `libquiver_c` with `ffi.dlopen(str(c_api_path))` using absolute path
  - Set `_load_source = "bundled"` and return the lib handle
  - On OSError: raise `RuntimeError(f"Cannot load bundled native libraries: {e}. Searched: {_LIBS_DIR}")` with `from None` — do NOT fall through to dev mode (per user decision: fail-fast on corrupt bundled libs)

Step 2 — Dev mode (fallback when `_libs/` missing or empty):
- Pre-load `libquiver` by bare name: `"libquiver"` on Windows, `"libquiver.so"` on Linux. Swallow exceptions (may be statically linked or already loaded).
- Load `libquiver_c` by bare name: `"libquiver_c"` on Windows, `"libquiver_c.so"` on Linux.
- Set `_load_source = "development"` and return the lib handle
- On OSError: raise `RuntimeError(f"Cannot load native libraries. Searched: {_LIBS_DIR} (not found), system PATH. Missing: {_LIB_C_API}")` with `from None`

**Diagnostic mode (`if __name__ == "__main__"`):**
Add a `__main__` block that imports ffi from `_c_api`, calls `load_library(ffi)`, and prints:
- `OK: loaded via '{_load_source}'`
- `_libs dir: {_LIBS_DIR}`
- `_libs exists: {_LIBS_DIR.is_dir()}`
On failure: print `FAIL: {e}` and exit with code 1.

**Strip all macOS/darwin code paths.** Only Windows and Linux supported.
**No logging on success** — silent operation per user decision.
**Use `from __future__ import annotations`** at the top.
**Import only:** `sys`, `os` (conditionally for Windows), `pathlib.Path`, `cffi.FFI` (type hint only).

The function signature `load_library(ffi: FFI)` must remain unchanged — `_c_api.py` calls it as `load_library(ffi)`.
  </action>
  <verify>
    <automated>cd C:/Development/DatabaseTmp/quiver2 && bindings/python/tests/test.bat</automated>
    <manual>All 203 existing Python tests pass — loader works in dev mode (test.bat sets PATH to build/bin)</manual>
    <sampling_rate>run after this task commits</sampling_rate>
  </verify>
  <done>
_loader.py rewritten with bundled-first discovery, dev-mode fallback, _load_source attribute, diagnostic __main__ block, and no macOS code. All existing Python tests pass in dev mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Linux RPATH $ORIGIN for libquiver_c in SKBUILD builds</name>
  <files>CMakeLists.txt</files>
  <action>
In the root `CMakeLists.txt`, inside the existing `if(DEFINED SKBUILD)` block (which currently contains the install targets at lines 113-118), add an RPATH override for Linux:

```cmake
if(DEFINED SKBUILD)
    install(TARGETS quiver quiver_c
        LIBRARY DESTINATION quiverdb/_libs
        RUNTIME DESTINATION quiverdb/_libs
    )
    # On Linux, set RPATH so libquiver_c.so finds libquiver.so in same directory
    if(NOT WIN32)
        set_target_properties(quiver_c PROPERTIES
            INSTALL_RPATH "$ORIGIN"
        )
    endif()
endif()
```

This overrides the default `CMAKE_INSTALL_RPATH` of `$ORIGIN/../lib` (set in `cmake/Platform.cmake`) to `$ORIGIN` for SKBUILD builds only. This way `libquiver_c.so` finds `libquiver.so` in the same `_libs/` directory inside the installed wheel, rather than looking in `../lib/`.

The `if(NOT WIN32)` guard is important — RPATH is a Unix concept, irrelevant on Windows.

Do NOT modify `cmake/Platform.cmake` or `src/CMakeLists.txt` — the change belongs in the root SKBUILD block where the install targets are.
  </action>
  <verify>
    <automated>cd C:/Development/DatabaseTmp/quiver2 && bindings/python/tests/test.bat</automated>
    <manual>CMake RPATH addition is in the SKBUILD block, guarded by NOT WIN32. Existing tests still pass.</manual>
    <sampling_rate>run after this task commits</sampling_rate>
  </verify>
  <done>
CMakeLists.txt SKBUILD block includes INSTALL_RPATH "$ORIGIN" for libquiver_c on Linux. Normal builds unaffected. All existing Python tests pass.
  </done>
</task>

</tasks>

<verification>
1. All 203 existing Python tests pass via `bindings/python/tests/test.bat` (dev-mode PATH discovery)
2. `_loader.py` contains `_load_source` module-level attribute
3. `_loader.py` contains `os.add_dll_directory` call guarded by `sys.platform == "win32"`
4. `_loader.py` checks for `_LIB_C_API` file existence inside `_libs/` (not just directory existence)
5. `_loader.py` raises `RuntimeError` with searched paths on failure
6. `CMakeLists.txt` SKBUILD block contains `INSTALL_RPATH "$ORIGIN"` guarded by `NOT WIN32`
7. No macOS/darwin code paths exist in `_loader.py`
</verification>

<success_criteria>
- `_loader.py` discovers bundled libs from `_libs/` when present, falls back to PATH when not
- `os.add_dll_directory()` is called on Windows for bundled lib directory
- Linux RPATH `$ORIGIN` set on libquiver_c for SKBUILD builds
- All existing Python tests pass (no regression)
- `_load_source` attribute exposed at module level
</success_criteria>

<output>
After completion, create `.planning/phases/02-loader-rewrite/02-01-SUMMARY.md`
</output>
