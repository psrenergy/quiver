---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - bindings/python/src/quiver/database.py
  - bindings/python/src/quiver/element.py
  - bindings/python/src/quiver/__init__.py
  - bindings/python/test/test.bat
  - bindings/python/tests/conftest.py
  - bindings/python/tests/test_database_lifecycle.py
  - bindings/python/tests/test_element.py
autonomous: true
requirements:
  - LIFE-01
  - LIFE-02
  - LIFE-03
  - LIFE-04
  - LIFE-05
  - INFRA-06

must_haves:
  truths:
    - "`Database.from_schema()` opens a database and `db.close()` closes it without error"
    - "`with Database.from_schema(...) as db:` automatically closes the database on exit"
    - "`Database.from_migrations()` opens a database using a migrations directory"
    - "`db.path()`, `db.current_version()`, and `db.is_healthy()` return correct values"
    - "`db.describe()` prints schema inspection output without error"
    - "A C API error (e.g., opening nonexistent schema) raises QuiverError with the exact C++ error message"
    - "`Element().set('label', 'x').set('value', 42)` creates an element with fluent chaining"
    - "Element handles int, float, str, None, bool (as int), and list types correctly"
    - "`test.bat` runs the Python test suite and all tests pass"
  artifacts:
    - path: "bindings/python/src/quiver/database.py"
      provides: "Database class with factory methods, lifecycle, properties, describe"
      contains: "class Database"
      min_lines: 60
    - path: "bindings/python/src/quiver/element.py"
      provides: "Element builder class with fluent set() API"
      contains: "class Element"
      min_lines: 50
    - path: "bindings/python/test/test.bat"
      provides: "Test runner script with PATH setup for DLLs"
      contains: "uv run pytest"
    - path: "bindings/python/tests/conftest.py"
      provides: "Test fixtures for schema path, database, temp directories"
      contains: "def db"
    - path: "bindings/python/tests/test_database_lifecycle.py"
      provides: "Database lifecycle tests: factory methods, close, context manager, properties, describe, errors"
      min_lines: 30
    - path: "bindings/python/tests/test_element.py"
      provides: "Element builder tests: set types, fluent chaining, arrays, destroy"
      min_lines: 30
  key_links:
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "imports ffi, get_lib for C API calls"
      pattern: "from.*_c_api import"
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/_helpers.py"
      via: "uses check() for error handling, decode_string for results"
      pattern: "from.*_helpers import"
    - from: "bindings/python/src/quiver/element.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "imports ffi, get_lib for C API calls"
      pattern: "from.*_c_api import"
    - from: "bindings/python/src/quiver/__init__.py"
      to: "bindings/python/src/quiver/database.py"
      via: "re-exports Database class"
      pattern: "from.*database import Database"
    - from: "bindings/python/src/quiver/__init__.py"
      to: "bindings/python/src/quiver/element.py"
      via: "re-exports Element class"
      pattern: "from.*element import Element"
    - from: "bindings/python/tests/test_database_lifecycle.py"
      to: "bindings/python/src/quiver/database.py"
      via: "imports Database, tests factory methods and lifecycle"
      pattern: "from quiver import Database"
---

<objective>
Implement the Database and Element classes, update __init__.py to re-export them, create the test runner script, and write comprehensive lifecycle tests.

Purpose: Complete the Phase 1 Python binding with working Database lifecycle (factory methods, close, context manager, properties, describe) and Element builder (fluent .set() API with type dispatch), fully tested.
Output: Working Database and Element classes, test.bat runner, passing test suite.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@CLAUDE.md
@include/quiver/c/common.h
@include/quiver/c/database.h
@include/quiver/c/element.h
@bindings/python/src/quiver/_c_api.py
@bindings/python/src/quiver/_helpers.py
@bindings/python/src/quiver/exceptions.py
@bindings/julia/src/database.jl
@bindings/dart/lib/src/database.dart
@bindings/julia/src/element.jl
@bindings/dart/lib/src/element.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database class and Element class</name>
  <files>
    bindings/python/src/quiver/database.py
    bindings/python/src/quiver/element.py
    bindings/python/src/quiver/__init__.py
  </files>
  <action>
**1. Create `database.py`:**

Reference Julia's `database.jl` and Dart's `database.dart` for patterns. The Python Database class is a thin wrapper around the C API handle.

```python
class Database:
    def __init__(self, ptr) -> None:
        self._ptr = ptr
        self._closed = False
```

**Factory methods (LIFE-01):**
- `@staticmethod from_schema(db_path: str, schema_path: str) -> Database`: Allocate `ffi.new("quiver_database_options_t*")`, set to `lib.quiver_database_options_default()`, allocate `ffi.new("quiver_database_t**")`, call `quiver_database_from_schema(db_path.encode("utf-8"), schema_path.encode("utf-8"), options, out_db)`, check error, return `Database(out_db[0])`
- `@staticmethod from_migrations(db_path: str, migrations_path: str) -> Database`: Same pattern using `quiver_database_from_migrations`

**Lifecycle (LIFE-02):**
- `close() -> None`: If already closed, return silently (idempotent). Otherwise call `quiver_database_close(self._ptr)`, check error, set `self._ptr = ffi.NULL`, `self._closed = True`
- `_ensure_open() -> None`: If `self._closed`, raise `QuiverError("Database has been closed")`
- `__enter__() -> Database`: Return `self`
- `__exit__(*args) -> None`: Call `self.close()`
- `__del__() -> None`: If not closed, emit `warnings.warn("Database was not closed explicitly", ResourceWarning, stacklevel=2)` and call `self.close()`. Import `warnings` at module level.

**Properties as methods (LIFE-03):**
- Per user decision: regular methods, NOT @property
- `path() -> str`: `_ensure_open()`, allocate `ffi.new("const char**")`, call `quiver_database_path(self._ptr, out)`, check, return `ffi.string(out[0]).decode("utf-8")`. Note: the returned `const char*` is borrowed (non-owned), do NOT free it.
- `current_version() -> int`: `_ensure_open()`, allocate `ffi.new("int64_t*")`, call `quiver_database_current_version(self._ptr, out)`, check, return `out[0]`
- `is_healthy() -> bool`: `_ensure_open()`, allocate `ffi.new("int*")`, call `quiver_database_is_healthy(self._ptr, out)`, check, return `bool(out[0])`

**Describe (LIFE-04):**
- `describe() -> None`: `_ensure_open()`, call `quiver_database_describe(self._ptr)`, check. Prints to stdout (C++ side handles output).

**__repr__:**
- `__repr__() -> str`: If closed, return `"Database(closed)"`. Otherwise return `f"Database(path={self.path()!r})"`.

**Full type hints on all parameters and return types. Import `from __future__ import annotations` for forward references.**

**2. Create `element.py`:**

Reference Dart's `element.dart` for the type-dispatch pattern.

```python
class Element:
    def __init__(self) -> None:
        out = ffi.new("quiver_element_t**")
        check(lib.quiver_element_create(out))
        self._ptr = out[0]
        self._destroyed = False
```

**Fluent builder (LIFE-05):**
- `set(self, name: str, value: ...) -> Element`: Type-dispatch using isinstance:
  1. `value is None` -> `_set_null(name)`
  2. `isinstance(value, bool)` -> `_set_integer(name, int(value))` -- MUST check bool before int (bool is subclass of int in Python)
  3. `isinstance(value, int)` -> `_set_integer(name, value)`
  4. `isinstance(value, float)` -> `_set_float(name, value)`
  5. `isinstance(value, str)` -> `_set_string(name, value)`
  6. `isinstance(value, list)` -> `_set_array(name, value)` -- delegate to array type dispatch
  7. Otherwise -> `raise TypeError(f"Unsupported type {type(value).__name__} for Element.set('{name}')")`
  - Return `self` for fluent chaining

- Private setters:
  - `_set_integer(name: str, value: int)`: `check(lib.quiver_element_set_integer(self._ptr, name.encode("utf-8"), value))`
  - `_set_float(name: str, value: float)`: `check(lib.quiver_element_set_float(self._ptr, name.encode("utf-8"), value))`
  - `_set_string(name: str, value: str)`: `check(lib.quiver_element_set_string(self._ptr, name.encode("utf-8"), value.encode("utf-8")))`
  - `_set_null(name: str)`: `check(lib.quiver_element_set_null(self._ptr, name.encode("utf-8")))`

- `_set_array(name: str, values: list)`:
  - If empty list: call `quiver_element_set_array_integer(self._ptr, name.encode("utf-8"), ffi.NULL, 0)` (empty array, type doesn't matter)
  - Determine type from first element:
    - `int` (check bool first) -> `_set_array_integer(name, values)`
    - `float` -> `_set_array_float(name, values)`
    - `str` -> `_set_array_string(name, values)`
    - Otherwise -> raise TypeError

- `_set_array_integer(name: str, values: list[int])`:
  - `c_arr = ffi.new("int64_t[]", values)`
  - `check(lib.quiver_element_set_array_integer(self._ptr, name.encode("utf-8"), c_arr, len(values)))`

- `_set_array_float(name: str, values: list[float])`:
  - `c_arr = ffi.new("double[]", values)`
  - `check(lib.quiver_element_set_array_float(self._ptr, name.encode("utf-8"), c_arr, len(values)))`

- `_set_array_string(name: str, values: list[str])`:
  - Keep all encoded strings alive: `encoded = [v.encode("utf-8") for v in values]`
  - `c_strings = [ffi.new("char[]", e) for e in encoded]`
  - `c_arr = ffi.new("const char*[]", c_strings)`
  - `check(lib.quiver_element_set_array_string(self._ptr, name.encode("utf-8"), c_arr, len(values)))`

- `_ensure_valid()`: If `self._destroyed`, raise `QuiverError("Element has been destroyed")`
- `destroy() -> None`: If already destroyed, return. Call `lib.quiver_element_destroy(self._ptr)`, check, set `self._ptr = ffi.NULL`, `self._destroyed = True`
- `clear() -> None`: `_ensure_valid()`, call `lib.quiver_element_clear(self._ptr)`, check
- `__repr__() -> str`: If destroyed, return `"Element(destroyed)"`. Otherwise call `quiver_element_to_string` to get a human-readable representation, free the string with `quiver_element_free_string`, return the decoded string.
- `__del__() -> None`: If not destroyed, call `self.destroy()` silently (no warning for Element, it's a builder object)

**3. Update `__init__.py`:**
- Add imports: `from quiver.database import Database` and `from quiver.element import Element`
- Add to `__all__`: `"Database"`, `"Element"`
- Keep existing `version` and `QuiverError` exports
  </action>
  <verify>
- `cd bindings/python && uv run python -c "from quiver import Database, Element; print(Database, Element)"` -- both importable
- `cd bindings/python && uv run python -c "from quiver import Element; e = Element().set('label', 'test').set('value', 42); print(repr(e)); e.destroy()"` -- fluent chaining works
  </verify>
  <done>
- Database class has from_schema(), from_migrations(), close(), context manager, path(), current_version(), is_healthy(), describe(), __repr__
- Element class has set() with type dispatch (int, float, str, None, bool, list), fluent chaining, destroy(), clear(), __repr__
- Both classes imported and re-exported from quiver.__init__
- All methods have full type hints
  </done>
</task>

<task type="auto">
  <name>Task 2: Test runner and lifecycle tests</name>
  <files>
    bindings/python/test/test.bat
    bindings/python/tests/conftest.py
    bindings/python/tests/test_database_lifecycle.py
    bindings/python/tests/test_element.py
  </files>
  <action>
**1. Create `test/test.bat` (INFRA-06):**
```batch
@echo off
pushd %~dp0..
set PATH=%~dp0..\..\..\build\bin;%PATH%
uv run pytest tests/ %*
popd
```
- Mirrors Julia/Dart test.bat pattern
- Prepends `build/bin/` to PATH so DLLs are findable
- `pushd` to the `bindings/python/` directory so pytest finds the package
- Passes through any extra arguments (e.g., `-v`, `-k "test_name"`)
- Note: the `test/` directory is separate from `tests/` (test/ has the runner script, tests/ has the test files) -- this matches Dart's pattern

**2. Update `tests/conftest.py`:**
- Delete `bindings/python/tests/unit/` directory if it exists (old empty structure)
- Provide fixtures:
  - `@pytest.fixture` `tests_path() -> Path`: Return `Path(__file__).resolve().parent` (the tests/ directory)
  - `@pytest.fixture` `schemas_path() -> Path`: Return the shared schemas directory: `Path(__file__).resolve().parent.parent.parent.parent / "tests" / "schemas"`
  - `@pytest.fixture` `valid_schema_path(schemas_path) -> Path`: Return `schemas_path / "valid" / "basic_schema.sql"` -- the standard test schema
  - `@pytest.fixture` `db(valid_schema_path, tmp_path) -> Generator[Database, None, None]`: Create a database using `Database.from_schema(str(tmp_path / "test.db"), str(valid_schema_path))`, yield it, then close it. Use `yield` for cleanup.
- Import Database from quiver
- Check which schema files exist in `tests/schemas/valid/` to pick the right one for the basic fixture

**3. Create `tests/test_database_lifecycle.py`:**
Test all lifecycle operations. Tests should mirror Julia's `test_database_lifecycle.jl` and Dart's `database_lifecycle_test.dart`.

Tests to include:
- `test_from_schema_creates_database(valid_schema_path, tmp_path)`: Create DB via from_schema, verify it's not None, close it
- `test_from_schema_context_manager(valid_schema_path, tmp_path)`: Use `with Database.from_schema(...) as db:`, verify db works inside, verify closed after exiting
- `test_from_migrations_creates_database(schemas_path, tmp_path)`: Create DB via from_migrations (use migrations dir path), verify, close
- `test_close_is_idempotent(db)`: Call db.close() twice without error
- `test_operations_after_close_raise(valid_schema_path, tmp_path)`: Create, close, then try db.path() -- should raise QuiverError
- `test_path_returns_string(db)`: Verify db.path() returns a string containing the db filename
- `test_current_version_returns_int(db)`: Verify db.current_version() returns an int >= 0
- `test_is_healthy_returns_true(db)`: Verify db.is_healthy() returns True for a valid database
- `test_describe_runs_without_error(db)`: Call db.describe() -- should not raise (output goes to stdout)
- `test_version_returns_string()`: Call `quiver.version()`, verify it's a non-empty string
- `test_error_on_nonexistent_schema(tmp_path)`: Try Database.from_schema with nonexistent schema file, verify QuiverError is raised with an error message
- `test_repr_open_database(db)`: Verify repr(db) contains "Database(path="
- `test_repr_closed_database(valid_schema_path, tmp_path)`: Create, close, verify repr(db) == "Database(closed)"

**4. Create `tests/test_element.py`:**
Tests for Element builder.

Tests to include:
- `test_element_set_integer()`: `Element().set("value", 42)` -- no error, destroy
- `test_element_set_float()`: `Element().set("value", 3.14)` -- no error, destroy
- `test_element_set_string()`: `Element().set("label", "hello")` -- no error, destroy
- `test_element_set_null()`: `Element().set("optional", None)` -- no error, destroy
- `test_element_set_bool_as_integer()`: `Element().set("flag", True)` -- stores as integer, no error
- `test_element_fluent_chaining()`: `e = Element().set("label", "x").set("value", 42).set("name", "test")` -- returns Element, all sets work
- `test_element_set_array_integer()`: `Element().set("values", [1, 2, 3])` -- no error
- `test_element_set_array_float()`: `Element().set("values", [1.0, 2.0])` -- no error
- `test_element_set_array_string()`: `Element().set("tags", ["a", "b"])` -- no error
- `test_element_set_empty_array()`: `Element().set("values", [])` -- no error
- `test_element_set_unsupported_type_raises()`: `Element().set("bad", {})` -- raises TypeError
- `test_element_destroy_is_idempotent()`: Create, destroy, destroy again -- no error
- `test_element_repr()`: Create element, verify repr is non-empty string, destroy
- `test_element_clear()`: Create element, set values, clear, set new values -- no error
- `test_element_create_element_roundtrip(db)`: Create an Element with label + value, call `create_element` via C API directly (or through Database if we add the method -- but create_element is Phase 3's WRITE-01, so just test Element construction and destruction here)

All tests use try/finally to ensure Element.destroy() is called, OR use the __del__ safety net.
  </action>
  <verify>
- `cd bindings/python && test/test.bat -v` -- all tests pass
- `cd bindings/python && test/test.bat -v -k "test_database"` -- lifecycle tests pass
- `cd bindings/python && test/test.bat -v -k "test_element"` -- element tests pass
  </verify>
  <done>
- test.bat exists and runs pytest with correct PATH setup
- conftest.py has fixtures for schemas_path, valid_schema_path, and db (database fixture)
- test_database_lifecycle.py has tests for from_schema, from_migrations, close, context manager, path, current_version, is_healthy, describe, version, error handling, repr
- test_element.py has tests for all set() type variants, fluent chaining, arrays, destroy, clear, repr
- All tests pass when run via test/test.bat
  </done>
</task>

</tasks>

<verification>
1. `cd bindings/python && test/test.bat -v` -- full test suite passes
2. `cd bindings/python && uv run python -c "import quiver; print(quiver.version())"` -- prints version
3. `cd bindings/python && uv run python -c "from quiver import Database; db = Database.from_schema(':memory:', 'path/to/schema.sql')"` -- opens database (use real schema path from tests/schemas/valid/)
4. `cd bindings/python && uv run python -c "from quiver import Element; e = Element().set('label', 'x').set('value', 42); print(repr(e)); e.destroy()"` -- fluent API works
5. Verify test.bat is usable: `bindings/python/test/test.bat` matches Julia/Dart runner pattern
</verification>

<success_criteria>
- Database.from_schema() and from_migrations() open databases successfully
- Database context manager (`with` statement) closes automatically
- Database methods (path, current_version, is_healthy, describe) return correct values
- C API errors raise QuiverError with exact C++ error messages
- Element fluent builder works with all types (int, float, str, None, bool, list)
- test.bat runs the test suite with proper DLL PATH setup
- All lifecycle and element tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
