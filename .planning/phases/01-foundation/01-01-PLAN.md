---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/python/pyproject.toml
  - bindings/python/src/quiver/__init__.py
  - bindings/python/src/quiver/py.typed
  - bindings/python/src/quiver/exceptions.py
  - bindings/python/src/quiver/_c_api.py
  - bindings/python/src/quiver/_loader.py
  - bindings/python/src/quiver/_helpers.py
  - bindings/python/generator/generator.py
  - bindings/python/generator/generator.bat
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - INFRA-03
  - INFRA-04
  - INFRA-05
  - LIFE-06

must_haves:
  truths:
    - "`import quiver` succeeds after `uv pip install -e .` in the bindings/python directory"
    - "`quiver.version()` returns a non-empty version string from the C library"
    - "A deliberate C API error (e.g., opening nonexistent schema) raises QuiverError with the exact C++ error message"
    - "DLL loading works on Windows by pre-loading libquiver.dll before libquiver_c.dll"
  artifacts:
    - path: "bindings/python/pyproject.toml"
      provides: "Package metadata with name='quiver', cffi dependency, hatchling build"
      contains: 'name = "quiver"'
    - path: "bindings/python/src/quiver/__init__.py"
      provides: "Public API re-exports including version()"
      contains: "version"
    - path: "bindings/python/src/quiver/_c_api.py"
      provides: "CFFI ffi instance, cdef declarations, lazy-loaded lib handle"
      contains: "ffi.cdef"
    - path: "bindings/python/src/quiver/_loader.py"
      provides: "DLL path resolution with Windows dependency chain handling"
      contains: "dlopen"
    - path: "bindings/python/src/quiver/exceptions.py"
      provides: "QuiverError exception class"
      contains: "class QuiverError"
    - path: "bindings/python/src/quiver/_helpers.py"
      provides: "check() error handler and string encoding helpers"
      contains: "def check"
    - path: "bindings/python/generator/generator.py"
      provides: "CFFI declaration generator that reads C API headers"
      contains: "def generate"
  key_links:
    - from: "bindings/python/src/quiver/_c_api.py"
      to: "bindings/python/src/quiver/_loader.py"
      via: "load_library() call to get lib handle"
      pattern: "load_library"
    - from: "bindings/python/src/quiver/_helpers.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "imports ffi and lib for check() and string helpers"
      pattern: "from.*_c_api import"
    - from: "bindings/python/src/quiver/__init__.py"
      to: "bindings/python/src/quiver/_helpers.py"
      via: "version() uses lib.quiver_version()"
      pattern: "version"
---

<objective>
Set up the Python binding package infrastructure: rename from "margaux" to "quiver", add CFFI dependency, create the module structure with DLL loading, CFFI declarations for Phase 1 functions, error handling (check + QuiverError), string encoding helpers, the version() function, and a declaration generator script.

Purpose: Establish the entire FFI foundation so that Plan 02 can build Database and Element classes on top of working C API bindings.
Output: An installable `quiver` Python package that loads the C DLLs and can call `quiver_version()` successfully.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@CLAUDE.md
@include/quiver/c/common.h
@include/quiver/c/options.h
@include/quiver/c/database.h
@include/quiver/c/element.h
@bindings/python/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Package restructure and CFFI declarations</name>
  <files>
    bindings/python/pyproject.toml
    bindings/python/src/quiver/__init__.py
    bindings/python/src/quiver/py.typed
    bindings/python/src/quiver/exceptions.py
    bindings/python/src/quiver/_c_api.py
  </files>
  <action>
**1. Restructure the package:**
- Delete `bindings/python/src/__init__.py` (the old margaux placeholder with `hello_world()`)
- Create `bindings/python/src/quiver/` directory
- Move `bindings/python/src/py.typed` to `bindings/python/src/quiver/py.typed` (empty PEP 561 marker)

**2. Update `pyproject.toml`:**
- Change `name = "margaux"` to `name = "quiver"`
- Add `cffi>=2.0.0` to `dependencies`
- Change `packages = ["src"]` to `packages = ["src/quiver"]` under `[tool.hatch.build.targets.wheel]`
- Keep all existing dev dependencies (pytest, ruff, dotenv)
- Keep `requires-python = ">=3.13"` and hatchling build backend

**3. Create `exceptions.py`:**
```python
class QuiverError(Exception):
    """Error from the Quiver C API."""
    pass
```
- Single exception class, inherits from Exception (per user decision: no hierarchy)
- Add `__repr__` that shows the message: `QuiverError(message)`

**4. Create `_c_api.py`:**
- Import `FFI` from cffi
- Create `ffi = FFI()` instance at module level
- Call `ffi.cdef(...)` with C declarations for ALL Phase 1 functions (lifecycle subset). Copy declarations from the C API headers EXACTLY to avoid ABI struct layout mismatch. Include:
  - From `common.h`: `quiver_error_t` enum (QUIVER_OK=0, QUIVER_ERROR=1), `quiver_version()`, `quiver_get_last_error()`, `quiver_clear_last_error()`
  - From `options.h`: `quiver_log_level_t` enum, `quiver_database_options_t` struct
  - From `database.h`: `quiver_database_t` opaque type (via `typedef struct quiver_database quiver_database_t;`), `quiver_database_options_default()`, `quiver_database_from_schema()`, `quiver_database_from_migrations()`, `quiver_database_close()`, `quiver_database_is_healthy()`, `quiver_database_path()`, `quiver_database_current_version()`, `quiver_database_describe()`, `quiver_database_create_element()` (needed for Element tests in Plan 02)
  - From `element.h`: `quiver_element_t` opaque type, `quiver_element_create()`, `quiver_element_destroy()`, `quiver_element_clear()`, `quiver_element_set_integer()`, `quiver_element_set_float()`, `quiver_element_set_string()`, `quiver_element_set_null()`, `quiver_element_set_array_integer()`, `quiver_element_set_array_float()`, `quiver_element_set_array_string()`, `quiver_element_to_string()`, `quiver_element_free_string()`, `quiver_element_has_scalars()`, `quiver_element_has_arrays()`, `quiver_element_scalar_count()`, `quiver_element_array_count()`
- CRITICAL: Do NOT use `...` (ellipsis) in cdef -- ABI mode requires full explicit declarations
- CRITICAL: Use exact field order from C headers for structs (`quiver_database_options_t` has `int read_only; quiver_log_level_t console_level;`)
- Lazy library loading: module-level `_lib = None` with `get_lib()` function that calls `_load_library()` from `_loader.py` on first access
- Export `ffi` and `get_lib` for use by other modules

**5. Create `__init__.py`:**
- Import and re-export: `QuiverError` from `exceptions`, `Database` (placeholder, will be added in Plan 02), `Element` (placeholder, will be added in Plan 02)
- Define `version()` function at module level: calls `get_lib()`, then `ffi.string(lib.quiver_version()).decode("utf-8")`
- Use `__all__` to declare public API
- For now, only export `version`, `QuiverError` (Database and Element added in Plan 02)
  </action>
  <verify>
- `cd bindings/python && uv sync` succeeds (installs cffi)
- `uv run python -c "from quiver.exceptions import QuiverError; print(QuiverError('test'))"` succeeds
- `uv run python -c "from quiver._c_api import ffi; print(type(ffi))"` succeeds (FFI instance created, cdef parsed)
  </verify>
  <done>
- pyproject.toml has name="quiver", cffi dep, correct packages path
- src/quiver/ directory exists with __init__.py, py.typed, exceptions.py, _c_api.py
- QuiverError is importable
- ffi.cdef() parses all Phase 1 declarations without error
  </done>
</task>

<task type="auto">
  <name>Task 2: DLL loader and error/string helpers</name>
  <files>
    bindings/python/src/quiver/_loader.py
    bindings/python/src/quiver/_helpers.py
    bindings/python/src/quiver/_c_api.py
  </files>
  <action>
**1. Create `_loader.py`:**
- `_find_library_dir() -> Path | None`: Walk up from `__file__` through parent directories looking for a `build/bin/` directory that contains the DLL files. Return the Path if found, None otherwise.
- `load_library(ffi)`: Main entry point. Uses `_find_library_dir()` to locate DLLs.
  - On Windows (`sys.platform == "win32"`):
    - Pre-load core library first: `ffi.dlopen(str(lib_dir / "libquiver.dll"))` -- this ensures libquiver_c.dll can find its dependency. The returned handle is NOT used further (CFFI keeps it loaded).
    - Then load and return the C API library: `ffi.dlopen(str(lib_dir / "libquiver_c.dll"))`
    - Use full paths with forward slashes to trigger CFFI's `LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR` behavior
  - On macOS (`sys.platform == "darwin"`): load `libquiver_c.dylib`
  - On Linux: load `libquiver_c.so`
  - If `_find_library_dir()` returns None, fall back to loading by name only (system PATH): `ffi.dlopen("libquiver_c")` -- this will fail with a clear error if the library isn't found
- DLL name: Build output confirmed as `libquiver.dll` and `libquiver_c.dll` (with `lib` prefix)

**2. Create `_helpers.py`:**
- Import `ffi` and `get_lib` from `_c_api`
- Import `QuiverError` from `exceptions`

- `check(err: int) -> None`: If `err != 0` (QUIVER_ERROR), call `lib.quiver_get_last_error()`, decode the result with `ffi.string(ptr).decode("utf-8")`, and raise `QuiverError(detail)`. If the error string is empty, raise `QuiverError("Unknown error")`. Do NOT call `quiver_clear_last_error()` (per user decision, matches Julia/Dart behavior).

- `encode_string(s: str) -> bytes`: Return `s.encode("utf-8")`. Simple helper to keep encoding consistent.

- `decode_string(ptr) -> str`: Return `ffi.string(ptr).decode("utf-8")`. For non-null char* pointers from C API.

- `decode_string_or_none(ptr) -> str | None`: Check if `ptr == ffi.NULL`, return None if so, otherwise `decode_string(ptr)`. For nullable C strings like `default_value` in metadata.

- All functions must have full type hints.

**3. Update `_c_api.py`:**
- Wire the `get_lib()` function to use `load_library(ffi)` from `_loader.py`:
```python
from quiver._loader import load_library

_lib = None
def get_lib():
    global _lib
    if _lib is None:
        _lib = load_library(ffi)
    return _lib
```
  </action>
  <verify>
- `cd bindings/python && uv run python -c "from quiver._c_api import get_lib; lib = get_lib(); print('DLL loaded')"` -- DLL loads successfully
- `cd bindings/python && uv run python -c "import quiver; print(quiver.version())"` -- returns version string like "0.3.0"
- `cd bindings/python && uv run python -c "from quiver._helpers import check; check(0); print('OK')"` -- check(0) returns without error
  </verify>
  <done>
- DLL loader finds and loads both libquiver.dll and libquiver_c.dll from build/bin/
- `quiver.version()` returns the C library version string
- check(0) succeeds silently, check(1) would raise QuiverError (but we need a real C API error to test -- tested in Plan 02)
- String helpers encode/decode UTF-8 correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: CFFI declaration generator</name>
  <files>
    bindings/python/generator/generator.py
    bindings/python/generator/generator.bat
  </files>
  <action>
**1. Create `generator/generator.py`:**
A script that reads the C API headers and produces CFFI-compatible declarations. The C API headers use very regular patterns (no complex macros beyond QUIVER_C_API), so regex parsing is sufficient.

- Parse these header files (relative to project root):
  - `include/quiver/c/common.h`
  - `include/quiver/c/options.h`
  - `include/quiver/c/database.h`
  - `include/quiver/c/element.h`
- Find the project root by walking up from `__file__` until finding `CMakeLists.txt`
- For each header:
  - Strip `#include`, `#ifdef`, `#ifndef`, `#endif`, `#define`, `#else` preprocessor directives
  - Strip `QUIVER_C_API` from function declarations (CFFI cdef doesn't understand dllexport/dllimport)
  - Strip `extern "C" {` and closing `}`
  - Preserve: `typedef enum`, `typedef struct`, function declarations
  - Add `#include <stdbool.h>` is NOT needed -- CFFI understands `bool` natively when declared (but the C API uses `int*` for bool out-params anyway, so no special handling needed)
- Output: Print the combined declarations to stdout, or write to a specified output file
- Add `--output` flag to write directly to `src/quiver/_declarations.py` as a Python string constant
- The generator should produce a Python file containing: `DECLARATIONS = """..."""`
- Usage: `python generator/generator.py --output src/quiver/_declarations.py`
- Alternative: can also just print to stdout for inspection

**Design note:** The generator replaces hand-maintenance of cdef strings. When the C API changes, run the generator to update declarations. This was explicitly requested by the user in CONTEXT.md, overriding the out-of-scope note about auto-generators.

**Important:** The generator must handle the `stdbool.h` include -- CFFI's cdef parser understands `bool` as a type, but the C API header uses `bool*` for `quiver_database_in_transaction`'s out parameter. Make sure `bool` is recognized. If CFFI's parser complains about `bool`, replace it with `_Bool` in the output (CFFI recognizes `_Bool`).

**2. Create `generator/generator.bat`:**
```batch
@echo off
pushd %~dp0..
uv run python generator/generator.py %*
popd
```

**3. Do NOT update _c_api.py to use generated declarations yet** -- the hand-written declarations in Task 1 are the source of truth for Phase 1. The generator is a maintenance tool for future use. In later phases, the executor can switch _c_api.py to import from the generated file.
  </action>
  <verify>
- `cd bindings/python && uv run python generator/generator.py` prints parseable C declarations to stdout (no errors)
- `cd bindings/python && uv run python generator/generator.py --output src/quiver/_declarations.py` creates the file with DECLARATIONS string
- The generated declarations include all functions from common.h, options.h, database.h, element.h
  </verify>
  <done>
- Generator script reads all 4 C API headers and produces CFFI-compatible declarations
- Generator strips preprocessor directives and QUIVER_C_API macros
- generator.bat runs the generator with correct working directory
- Generated output is parseable by `ffi.cdef()` (can be verified by importing it)
  </done>
</task>

</tasks>

<verification>
1. `cd bindings/python && uv sync` -- package installs with cffi dependency
2. `cd bindings/python && uv run python -c "import quiver; print(quiver.version())"` -- prints version string
3. `cd bindings/python && uv run python -c "from quiver import QuiverError; raise QuiverError('test')"` -- raises with correct message
4. `cd bindings/python && uv run python -c "from quiver._c_api import ffi, get_lib; lib = get_lib(); print(type(lib))"` -- lib loaded
5. `cd bindings/python && uv run python generator/generator.py` -- generator runs without errors
</verification>

<success_criteria>
- `import quiver` works after install
- `quiver.version()` returns a version string from the C library
- QuiverError is importable and raisable
- DLL loader handles Windows dependency chain (libquiver.dll pre-loaded before libquiver_c.dll)
- check() function translates C API errors to Python exceptions
- String helpers correctly encode/decode UTF-8
- Generator script parses C API headers and produces valid CFFI declarations
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
