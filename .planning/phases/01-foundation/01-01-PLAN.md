---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/database_impl.h
  - src/database_create.cpp
  - tests/test_database_relations.cpp
autonomous: true
requirements:
  - FOUND-01
  - CRE-03
  - ERR-01

must_haves:
  truths:
    - "resolve_fk_label helper resolves a string label to an integer ID for any FK column"
    - "resolve_fk_label throws 'Failed to resolve label X to ID in table Y' for missing labels"
    - "resolve_fk_label rejects strings passed to non-FK INTEGER columns with a clear Quiver error"
    - "Existing set FK path in create_element uses the shared helper with zero behavioral change"
    - "All existing relation tests pass unchanged after refactor"
  artifacts:
    - path: "src/database_impl.h"
      provides: "resolve_fk_label method on Database::Impl"
      contains: "resolve_fk_label"
    - path: "src/database_create.cpp"
      provides: "Refactored set FK path calling resolve_fk_label"
      contains: "resolve_fk_label"
    - path: "tests/test_database_relations.cpp"
      provides: "Dedicated tests for FK label resolution, missing label, non-FK INTEGER guard"
      contains: "ResolveFkLabel"
  key_links:
    - from: "src/database_create.cpp"
      to: "src/database_impl.h"
      via: "impl_->resolve_fk_label() call in set table loop"
      pattern: "impl_->resolve_fk_label"
    - from: "src/database_impl.h"
      to: "include/quiver/schema.h"
      via: "TableDefinition::foreign_keys iteration and get_data_type() check"
      pattern: "table_def\\.foreign_keys|get_data_type"
    - from: "tests/test_database_relations.cpp"
      to: "tests/schemas/valid/relations.sql"
      via: "Test schema providing FK columns for resolution tests"
      pattern: "relations\\.sql"
---

<objective>
Extract a shared `resolve_fk_label` helper method on `Database::Impl` that resolves string labels to integer IDs for any FK column, refactor the existing set FK path in `create_element` to use it, and add a guard that rejects strings on non-FK INTEGER columns.

Purpose: Establish the reusable FK label resolution foundation that Phase 2 (create) and Phase 3 (update) will call without modification.
Output: Working `resolve_fk_label` method, refactored `create_element` set path, dedicated tests.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md

@src/database_impl.h
@src/database_create.cpp
@include/quiver/schema.h
@include/quiver/data_type.h
@tests/test_database_relations.cpp
@tests/schemas/valid/relations.sql
@tests/schemas/valid/basic.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract resolve_fk_label helper and refactor set FK path</name>
  <files>src/database_impl.h, src/database_create.cpp</files>
  <action>
**Step 1: Add `resolve_fk_label` method to `Database::Impl` in `src/database_impl.h`.**

Add the method inside the `struct Database::Impl` block (after the existing `require_column` method, before `load_schema_metadata`). The method signature is:

```cpp
Value resolve_fk_label(const TableDefinition& table_def,
                       const std::string& column,
                       const Value& value,
                       Database& db)
```

Implementation logic (behavior matrix):
1. If value is NOT `std::string` → return value unchanged (int64_t, double, nullptr all pass through)
2. If value IS `std::string`:
   a. Iterate `table_def.foreign_keys`. If `fk.from_column == column`:
      - Execute `SELECT id FROM {fk.to_table} WHERE label = ?` using `db.execute(lookup_sql, {label})`
      - If result is empty or `get_integer(0)` has no value: throw `std::runtime_error("Failed to resolve label '" + label + "' to ID in table '" + fk.to_table + "'")`
      - Return the resolved `int64_t` value (as `Value`)
   b. If no FK matches AND `table_def.get_data_type(column)` returns `DataType::Integer`:
      - Throw a clear error using Pattern 1: `"Cannot resolve attribute: '" + column + "' is INTEGER but received string '" + str_val + "' (not a foreign key)"`
      - Do NOT include an operation name since the helper is called from both create and update contexts
   c. Otherwise (string value for TEXT/DATETIME column): return value unchanged

You will need to add `#include "quiver/value.h"` if not already included (check -- `database.h` likely already pulls it in through transitive includes, but `database_impl.h` should have the include for `Value` since it appears in the method signature).

**Step 2: Refactor set FK path in `src/database_create.cpp`.**

In the set table insertion loop (lines 140-175), replace the 17-line inline FK resolution block (lines 149-169) with a single call to the helper:

Before:
```cpp
auto val = (*values_ptr)[row_idx];

// Check if this column is a FK and value is a string (label) that needs resolution
for (const auto& fk : table_def->foreign_keys) {
    if (fk.from_column == col_name && std::holds_alternative<std::string>(val)) {
        // ... 12 lines of resolution logic
        break;
    }
}

set_params.push_back(val);
```

After:
```cpp
auto val = impl_->resolve_fk_label(*table_def, col_name, (*values_ptr)[row_idx], *this);
set_params.push_back(val);
```

This collapses the inner `for` loop, the `if` check, the SQL lookup, the error throw, and the `break` into a single method call. The `val` variable declaration and the `push_back` remain.

**What NOT to do:**
- Do NOT change any other code paths in `create_element` (scalar, vector, time series loops are untouched in this phase)
- Do NOT modify `TypeValidator`, `Schema`, or `Element` classes
- Do NOT add any C API or binding changes
- Do NOT change the `database.h` public API
  </action>
  <verify>
Build the project:
```bash
cmake --build build --config Debug
```
Must compile with zero errors. Run the existing test suite:
```bash
./build/bin/quiver_tests.exe --gtest_filter="*Relation*"
```
All 7 existing relation tests must pass unchanged.
Then run the full C++ test suite:
```bash
./build/bin/quiver_tests.exe
```
All tests must pass (no regressions from the refactor).
  </verify>
  <done>
- `resolve_fk_label` method exists on `Database::Impl` in `database_impl.h`
- The method handles all 4 value variants (string FK → resolved int, string non-FK INTEGER → error, string TEXT/DATETIME → passthrough, non-string → passthrough)
- The inline 17-line FK block in the set path of `create_element` is replaced with a single `impl_->resolve_fk_label()` call
- All existing tests pass unchanged (zero behavioral change for the set FK path)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add dedicated FK label resolution tests</name>
  <files>tests/test_database_relations.cpp</files>
  <action>
Add 3 new test cases to `tests/test_database_relations.cpp` at the end of the file, after the existing tests. Add a section comment header:

```cpp
// ============================================================================
// FK label resolution (resolve_fk_label helper)
// ============================================================================
```

**Test 1: Valid label resolution via set FK create** (`ResolveFkLabelInSetCreate`)
- Use `relations.sql` schema (has `Child_set_parents` with `parent_ref` FK to `Parent`)
- Create 2 parents: "Parent 1", "Parent 2"
- Create child with set FK using string labels: `child.set("parent_ref", std::vector<std::string>{"Parent 1", "Parent 2"})`
- Call `db.create_element("Child", child)`
- Read back with `db.read_set_integers("Child", "parent_ref")`
- Assert: sets[0] has 2 values, values are 1 and 2 (resolved parent IDs)
- This proves the refactored set path still resolves FK labels correctly

**Test 2: Missing label error (ERR-01)** (`ResolveFkLabelMissingTarget`)
- Use `relations.sql` schema
- Create child with set FK referencing nonexistent parent: `child.set("parent_ref", std::vector<std::string>{"Nonexistent Parent"})`
- Call `db.create_element("Child", child)`
- Assert: throws `std::runtime_error` with EXACT message `"Failed to resolve label 'Nonexistent Parent' to ID in table 'Parent'"`
- Use the try/catch/rethrow pattern from existing tests to verify the exact error message with `EXPECT_STREQ`

**Test 3: Non-FK INTEGER column error** (`RejectStringForNonFkIntegerColumn`)
- Use `basic.sql` schema (has `Configuration` table with `integer_attribute INTEGER`, no FK)
- Create element: `element.set("label", std::string("Config 1"))` and `element.set("integer_attribute", std::string("not_a_label"))`
- Call `db.create_element("Configuration", element)`
- Assert: throws `std::runtime_error`
- The error message should contain the column name "integer_attribute" and indicate it is not a foreign key
- Use `EXPECT_THROW` for this test (exact message wording is Claude's discretion, so just verify it throws)

**Important:** These tests exercise the `resolve_fk_label` helper through the public `create_element` API. They do NOT call the helper directly (it is a private `Impl` method). The tests verify observable behavior, not internal implementation.
  </action>
  <verify>
Build and run:
```bash
cmake --build build --config Debug && ./build/bin/quiver_tests.exe --gtest_filter="*ResolveFkLabel*:*RejectString*"
```
All 3 new tests pass. Then run the full suite:
```bash
./build/bin/quiver_tests.exe
```
All tests pass (existing + new).
  </verify>
  <done>
- 3 new tests exist in `test_database_relations.cpp` under the "FK label resolution" section
- Test 1 proves string labels resolve to integer IDs through the set FK create path
- Test 2 proves missing labels throw the exact ERR-01 error message
- Test 3 proves strings on non-FK INTEGER columns throw a clear Quiver error (not a raw SQLite STRICT mode error)
- All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` -- project compiles cleanly
2. `./build/bin/quiver_tests.exe` -- ALL tests pass (existing + new)
3. `./build/bin/quiver_c_tests.exe` -- C API tests pass (no regressions)
4. Grep `resolve_fk_label` appears in both `database_impl.h` and `database_create.cpp`
5. Grep the old inline FK block (the `for (const auto& fk : table_def->foreign_keys)` pattern inside the set loop) is GONE from `database_create.cpp`
6. The 3 new test names appear in test output: `ResolveFkLabelInSetCreate`, `ResolveFkLabelMissingTarget`, `RejectStringForNonFkIntegerColumn`
</verification>

<success_criteria>
- The `resolve_fk_label` helper method is implemented on `Database::Impl` and is callable from any translation unit that includes `database_impl.h`
- The helper's interface (`TableDefinition&, string&, Value&, Database&`) works for scalar, vector, set, and time series FK columns without modification (Phase 2/3 ready)
- The existing set FK behavior is preserved exactly (zero change in observable behavior)
- The ERR-01 error message format is exactly: `"Failed to resolve label 'X' to ID in table 'Y'"`
- Strings on non-FK INTEGER columns produce a Quiver error, not a raw SQLite STRICT mode error
- All existing tests pass, 3 new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
