---
phase: 04-queries-and-relations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/python/src/quiver/_c_api.py
  - bindings/python/src/quiver/database.py
  - bindings/python/tests/test_database_query.py
autonomous: true
requirements: [QUERY-01, QUERY-02]
must_haves:
  truths:
    - "query_string executes SQL and returns a string or None"
    - "query_integer executes SQL and returns an int or None"
    - "query_float executes SQL and returns a float or None"
    - "query_date_time executes SQL and returns a datetime or None"
    - "Parameterized queries marshal typed parameters to C API without segfault"
    - "No rows returns None for all query methods"
    - "Empty params list routes to simple C API call"
    - "Unsupported param types raise TypeError immediately"
  artifacts:
    - path: "bindings/python/src/quiver/_c_api.py"
      provides: "6 CFFI query function declarations"
      contains: "quiver_database_query_string"
    - path: "bindings/python/src/quiver/database.py"
      provides: "_marshal_params helper and 4 query methods"
      contains: "_marshal_params"
    - path: "bindings/python/tests/test_database_query.py"
      provides: "Query tests for simple, parameterized, and date_time"
      min_lines: 50
  key_links:
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "query methods call lib.quiver_database_query_* functions"
      pattern: "quiver_database_query_"
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "_marshal_params uses ffi.cast for void pointer arrays"
      pattern: "ffi.cast"
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "query_string frees results with quiver_element_free_string"
      pattern: "quiver_element_free_string"
---

<objective>
Add parameterized SQL query methods to the Python bindings, completing the query surface.

Purpose: Enables Python users to execute SQL queries with typed parameters (int, float, str, None) through the same unified API that Julia and Dart provide. This is the core of Phase 4 -- relations were already completed in Phases 2-3.

Output: 6 CFFI declarations, `_marshal_params` helper, 4 unified query methods (`query_string`, `query_integer`, `query_float`, `query_date_time`), and comprehensive test coverage.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-queries-and-relations/04-CONTEXT.md
@.planning/phases/04-queries-and-relations/04-RESEARCH.md
@bindings/python/src/quiver/_c_api.py
@bindings/python/src/quiver/database.py
@bindings/python/tests/conftest.py
@include/quiver/c/database.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CFFI query declarations, _marshal_params helper, and 4 query methods</name>
  <files>
    bindings/python/src/quiver/_c_api.py
    bindings/python/src/quiver/database.py
  </files>
  <action>
**_c_api.py:** Append 6 CFFI declarations to the existing cdef block (before the closing `"""`):

```
// Query methods - simple
quiver_error_t quiver_database_query_string(quiver_database_t* db,
    const char* sql, char** out_value, int* out_has_value);
quiver_error_t quiver_database_query_integer(quiver_database_t* db,
    const char* sql, int64_t* out_value, int* out_has_value);
quiver_error_t quiver_database_query_float(quiver_database_t* db,
    const char* sql, double* out_value, int* out_has_value);

// Query methods - parameterized
quiver_error_t quiver_database_query_string_params(quiver_database_t* db,
    const char* sql, const int* param_types, const void* const* param_values,
    size_t param_count, char** out_value, int* out_has_value);
quiver_error_t quiver_database_query_integer_params(quiver_database_t* db,
    const char* sql, const int* param_types, const void* const* param_values,
    size_t param_count, int64_t* out_value, int* out_has_value);
quiver_error_t quiver_database_query_float_params(quiver_database_t* db,
    const char* sql, const int* param_types, const void* const* param_values,
    size_t param_count, double* out_value, int* out_has_value);
```

If CFFI parser rejects `const void* const*`, fall back to `void**` (ABI-compatible; CFFI ignores const qualifiers in ABI mode).

**database.py:** Add a module-level `_marshal_params` helper function (private, not on Database class -- consistent with `_parse_scalar_metadata` and `_parse_group_metadata` pattern). It must:
1. Accept a `list` of mixed-type Python values
2. Build parallel `int[]` (types) and `void*[]` (values) CFFI arrays
3. Return `(keepalive, c_types, c_values)` tuple where `keepalive` is a list holding all `ffi.new` allocations to prevent premature GC
4. Type mapping: `int` (and `bool` subclass) -> `QUIVER_DATA_TYPE_INTEGER` (0) via `ffi.new("int64_t*", p)`, `float` -> `QUIVER_DATA_TYPE_FLOAT` (1) via `ffi.new("double*", p)`, `str` -> `QUIVER_DATA_TYPE_STRING` (2) via `ffi.new("char[]", p.encode("utf-8"))`, `None` -> `QUIVER_DATA_TYPE_NULL` (4) with `ffi.NULL`
5. Use `isinstance(p, int)` check (catches `bool` since bool is subclass of int) -- NOT `type()` check
6. Raise `TypeError(f"Unsupported parameter type: {type(p).__name__}. Expected int, float, str, or None.")` for unsupported types
7. Cast all typed pointers to `void*` via `ffi.cast("void*", buf)`

Add `from datetime import datetime` import at top of database.py.

Add 4 methods to the Database class:

**query_string(self, sql: str, *, params: list | None = None) -> str | None:**
- Call `self._ensure_open()`
- If `params is not None and len(params) > 0`: call `_marshal_params(params)`, then `lib.quiver_database_query_string_params` with c_types, c_values, len(params)
- Else: call `lib.quiver_database_query_string`
- Both use `out_value = ffi.new("char**")` and `out_has = ffi.new("int*")`
- If `out_has[0] == 0` or `out_value[0] == ffi.NULL`: return None
- Otherwise: `try: return ffi.string(out_value[0]).decode("utf-8")` with `finally: lib.quiver_element_free_string(out_value[0])` (same pattern as read_scalar_string_by_id)

**query_integer(self, sql: str, *, params: list | None = None) -> int | None:**
- Same pattern but with `ffi.new("int64_t*")` for out_value
- No free needed (stack-allocated out-param)
- Return `out_value[0]` (Python auto-converts int64 to int) or None if `out_has[0] == 0`

**query_float(self, sql: str, *, params: list | None = None) -> float | None:**
- Same pattern but with `ffi.new("double*")` for out_value
- No free needed
- Return `out_value[0]` (always float, never coerce to int) or None if `out_has[0] == 0`

**query_date_time(self, sql: str, *, params: list | None = None) -> datetime | None:**
- Call `self.query_string(sql, params=params)` (reuse, not duplicate)
- If result is None: return None
- Return `datetime.fromisoformat(result)` (raises ValueError on unparseable strings -- this is intentional per locked decision)
  </action>
  <verify>
Run `python -c "from quiver import Database; print('import ok')"` from `bindings/python/` with `build/bin` in PATH to confirm no import errors. Verify that `_c_api.py` has all 6 query declarations and `database.py` has `_marshal_params` and 4 query methods.
  </verify>
  <done>
- `_c_api.py` has 6 new CFFI declarations for query_string/integer/float and their _params variants
- `database.py` has module-level `_marshal_params` helper returning (keepalive, c_types, c_values)
- `database.py` has `query_string`, `query_integer`, `query_float`, `query_date_time` methods on Database with keyword-only `params` argument
- `query_string` frees C-allocated string results via `quiver_element_free_string` in try/finally
- `query_date_time` composes `query_string` + `datetime.fromisoformat`
- No import errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add query test file with comprehensive coverage</name>
  <files>
    bindings/python/tests/test_database_query.py
  </files>
  <action>
Create `bindings/python/tests/test_database_query.py` using the existing `db` fixture from conftest.py (uses `basic.sql` schema which has Configuration table with `label TEXT UNIQUE NOT NULL`).

Check `basic.sql` schema for available columns to query. Use `collections_db` fixture if query tests need integer/float/string scalar attributes (the collections schema has Items with value INTEGER, score REAL, label TEXT, etc.).

Use pytest class-based structure matching existing test files. The test file must cover:

**Simple queries (QUERY-01):**
- `test_query_string_returns_value` -- create element, query its string attribute, assert match
- `test_query_string_no_rows_returns_none` -- query with WHERE clause matching nothing, assert None
- `test_query_integer_returns_value` -- query COUNT(*) or integer attribute, assert int type
- `test_query_integer_no_rows_returns_none` -- assert None
- `test_query_float_returns_value` -- query float attribute or CAST expression, assert float type
- `test_query_float_no_rows_returns_none` -- assert None

**Parameterized queries (QUERY-02):**
- `test_query_string_with_string_param` -- `WHERE label = ?` with `params=["Test"]`
- `test_query_integer_with_integer_param` -- `WHERE id = ?` with `params=[1]`
- `test_query_with_float_param` -- query with float parameter
- `test_query_with_none_param` -- `WHERE ? IS NULL` with `params=[None]`, verify correct NULL marshaling
- `test_query_with_mixed_params` -- query using int + string params together
- `test_query_with_bool_param` -- `params=[True]`, verify bool->int conversion works (True->1)
- `test_query_with_empty_params_routes_to_simple` -- `params=[]` should work same as no params

**Edge cases:**
- `test_marshal_params_unsupported_type_raises_typeerror` -- pass dict or list as param, assert TypeError with expected message format
- `test_query_date_time_returns_datetime` -- insert ISO date string, query it, assert `datetime` type
- `test_query_date_time_no_rows_returns_none` -- assert None
- `test_query_date_time_with_params` -- parameterized date query
- `test_query_date_time_invalid_format_raises_valueerror` -- insert non-date string, query as date_time, assert ValueError

Import `datetime` from stdlib. Import `pytest`, `Database`, `Element` as in other test files.
  </action>
  <verify>
Run `bindings/python/test/test.bat` (or `cd bindings/python && uv run pytest tests/ -v`) to verify all tests pass. Expect all new query tests plus existing 113 tests to pass with zero failures.
  </verify>
  <done>
- `test_database_query.py` exists with tests covering: simple string/integer/float queries, parameterized queries with all 4 types (int, float, str, None), bool-as-int, empty params, mixed params, unsupported type error, query_date_time success/none/params/invalid-format
- All tests pass alongside existing test suite
- Total test count increases from 113 to ~130+
  </done>
</task>

</tasks>

<verification>
1. `bindings/python/test/test.bat` runs all Python tests with zero failures
2. All 6 CFFI declarations present in `_c_api.py` (grep for `quiver_database_query_`)
3. All 4 query methods present on Database class in `database.py` (grep for `def query_`)
4. `_marshal_params` helper present in `database.py` (grep for `def _marshal_params`)
5. No segfaults or GC-premature-free issues (parameterized tests exercise keepalive pattern)
</verification>

<success_criteria>
- query_string(sql) returns str or None; query_string(sql, params=[...]) works with typed parameters
- query_integer(sql) returns int or None; parameterized variant works
- query_float(sql) returns float or None; parameterized variant works
- query_date_time(sql) returns datetime or None; raises ValueError on bad format
- bool params work (True->1, False->0)
- None params marshal as NULL correctly
- Empty params list routes to simple C API call
- Unsupported param types raise TypeError with exact message format
- All tests pass (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/04-queries-and-relations/04-01-SUMMARY.md`
</output>
