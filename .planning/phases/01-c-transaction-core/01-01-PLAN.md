---
phase: 01-c-transaction-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/quiver/database.h
  - src/database_impl.h
  - src/database.cpp
  - tests/test_database_transaction.cpp
  - tests/CMakeLists.txt
  - CLAUDE.md
autonomous: true
requirements:
  - TXN-01
  - TXN-02
  - TXN-03
must_haves:
  truths:
    - "Caller can call begin_transaction(), perform multiple writes, then commit() and all data persists"
    - "Caller can call begin_transaction(), perform multiple writes, then rollback() and no data persists"
    - "Existing write methods (create_element, update_vector_*, update_set_*, update_time_series_group) execute without error inside an explicit transaction"
    - "Double begin_transaction() throws 'Cannot begin_transaction: transaction already active'"
    - "commit() without active transaction throws 'Cannot commit: no active transaction'"
    - "rollback() without active transaction throws 'Cannot rollback: no active transaction'"
    - "in_transaction() returns true inside a transaction, false outside"
    - "All existing C++ tests pass unchanged"
  artifacts:
    - path: "include/quiver/database.h"
      provides: "Public begin_transaction, commit, rollback, in_transaction declarations"
      contains: "void begin_transaction"
    - path: "src/database_impl.h"
      provides: "Nest-aware TransactionGuard with owns_transaction_ flag"
      contains: "owns_transaction_"
    - path: "src/database.cpp"
      provides: "Public method implementations with precondition checks, internal callers use impl_->"
      contains: "Cannot begin_transaction: transaction already active"
    - path: "tests/test_database_transaction.cpp"
      provides: "Transaction-specific test suite"
      min_lines: 80
  key_links:
    - from: "include/quiver/database.h"
      to: "src/database.cpp"
      via: "public method declarations matched by implementations"
      pattern: "void begin_transaction|void commit|void rollback|bool in_transaction"
    - from: "src/database_impl.h"
      to: "src/database.cpp"
      via: "TransactionGuard used by all write methods; public methods call impl_->"
      pattern: "sqlite3_get_autocommit"
    - from: "tests/test_database_transaction.cpp"
      to: "include/quiver/database.h"
      via: "tests call public API methods"
      pattern: "begin_transaction|commit|rollback|in_transaction"
---

<objective>
Implement public `begin_transaction()`, `commit()`, `rollback()`, and `in_transaction()` on the C++ Database class, make the internal TransactionGuard nest-aware so existing write methods work inside explicit transactions, and add comprehensive tests.

Purpose: Enable callers of the C++ API to wrap multiple write operations in a single explicit transaction, which is the foundation for the C API (Phase 2), language bindings (Phase 3), and performance benchmarks (Phase 4).

Output: Modified `database.h`, `database_impl.h`, `database.cpp` with transaction support; new `test_database_transaction.cpp` registered in CMakeLists.txt; all existing tests still pass.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-c-transaction-core/01-CONTEXT.md
@.planning/phases/01-c-transaction-core/01-RESEARCH.md
@include/quiver/database.h
@src/database_impl.h
@src/database.cpp
@tests/test_utils.h
@tests/CMakeLists.txt
@tests/schemas/valid/collections.sql
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement transaction API and nest-aware TransactionGuard</name>
  <files>
    include/quiver/database.h
    src/database_impl.h
    src/database.cpp
  </files>
  <action>
    Three coordinated changes across the three files:

    **1. `include/quiver/database.h` -- Move transaction methods from private to public, add in_transaction()**

    Move `begin_transaction()`, `commit()`, `rollback()` from the `private:` section (lines 197-199) to the `public:` section. Add `in_transaction()` const method. Place them as a group with a comment, logically after the query methods and before the `private:` section:

    ```cpp
    // Transaction control
    void begin_transaction();
    void commit();
    void rollback();
    bool in_transaction() const;
    ```

    Remove lines 197-199 from the private section (the old declarations).

    **2. `src/database_impl.h` -- Make TransactionGuard nest-aware**

    Replace the existing TransactionGuard class (lines 99-119) with a nest-aware version. Add `bool owns_transaction_ = false` member. In the constructor, check `sqlite3_get_autocommit(impl_.db)`:
    - If non-zero (no active transaction): call `impl_.begin_transaction()` and set `owns_transaction_ = true`
    - If zero (already in a transaction): do nothing (complete no-op)

    In `commit()`: only call `impl_.commit()` if `owns_transaction_` is true. Always set `committed_ = true`.

    In destructor: only call `impl_.rollback()` if `!committed_ && owns_transaction_`.

    Do NOT log anything when the guard becomes a no-op (per research recommendation -- no-op logging adds noise proportional to batch size with zero diagnostic value).

    Full replacement:
    ```cpp
    class TransactionGuard {
        Impl& impl_;
        bool committed_ = false;
        bool owns_transaction_ = false;

    public:
        explicit TransactionGuard(Impl& impl) : impl_(impl) {
            if (sqlite3_get_autocommit(impl_.db)) {
                impl_.begin_transaction();
                owns_transaction_ = true;
            }
        }

        void commit() {
            if (owns_transaction_) {
                impl_.commit();
            }
            committed_ = true;
        }

        ~TransactionGuard() {
            if (!committed_ && owns_transaction_) {
                impl_.rollback();
            }
        }

        TransactionGuard(const TransactionGuard&) = delete;
        TransactionGuard& operator=(const TransactionGuard&) = delete;
    };
    ```

    **3. `src/database.cpp` -- Add precondition checks to public methods, fix internal callers**

    Replace the existing thin pass-through implementations (lines 275-283) with precondition-checking versions:

    ```cpp
    void Database::begin_transaction() {
        if (!sqlite3_get_autocommit(impl_->db)) {
            throw std::runtime_error("Cannot begin_transaction: transaction already active");
        }
        impl_->begin_transaction();
        impl_->logger->debug("User transaction started");
    }

    bool Database::in_transaction() const {
        return !sqlite3_get_autocommit(impl_->db);
    }

    void Database::commit() {
        if (sqlite3_get_autocommit(impl_->db)) {
            throw std::runtime_error("Cannot commit: no active transaction");
        }
        impl_->commit();
        impl_->logger->debug("User transaction committed");
    }

    void Database::rollback() {
        if (sqlite3_get_autocommit(impl_->db)) {
            throw std::runtime_error("Cannot rollback: no active transaction");
        }
        impl_->rollback();
        impl_->logger->debug("User transaction rolled back");
    }
    ```

    Fix internal callers in `migrate_up()` (lines 325, 329, 332) -- change `begin_transaction()` to `impl_->begin_transaction()`, `commit()` to `impl_->commit()`, `rollback()` to `impl_->rollback()`.

    Fix internal callers in `apply_schema()` (lines 359, 363, 365) -- same pattern: replace `begin_transaction()` with `impl_->begin_transaction()`, `commit()` with `impl_->commit()`, `rollback()` with `impl_->rollback()`.

    This is required because the public methods now have precondition checks that internal operations must bypass (per locked decision: "Error checks live in the public Database methods, not in Impl").

    **IMPORTANT: Update CLAUDE.md**

    After implementation, update `CLAUDE.md` to document the new public transaction API:
    - Add `begin_transaction()`, `commit()`, `rollback()`, `in_transaction()` to the Database Class section under Core API
    - Add these methods to the Cross-Layer Naming Conventions table
    - Remove the `with_transaction(lambda)` reference from the Transactions section since it does not exist in the codebase (confirmed by research)
  </action>
  <verify>
    Build the project: `cmake --build build --config Debug`

    Verify compilation succeeds with no errors. Run existing C++ tests: `./build/bin/quiver_tests.exe`

    All existing tests must pass unchanged. This confirms TXN-02 (existing write methods work) and that internal callers (migrate_up, apply_schema used by from_schema/from_migrations) are not broken.
  </verify>
  <done>
    - `begin_transaction()`, `commit()`, `rollback()` are public methods on Database
    - `in_transaction()` returns bool
    - TransactionGuard has `owns_transaction_` flag and checks `sqlite3_get_autocommit()`
    - `migrate_up()` and `apply_schema()` use `impl_->` for transaction calls
    - All existing C++ tests pass unchanged
    - CLAUDE.md updated with new API surface
  </done>
</task>

<task type="auto">
  <name>Task 2: Add transaction test suite</name>
  <files>
    tests/test_database_transaction.cpp
    tests/CMakeLists.txt
  </files>
  <action>
    **1. Create `tests/test_database_transaction.cpp`**

    Follow existing test patterns (see test_database_create.cpp for conventions). Use GoogleTest. Include `test_utils.h`, `<gtest/gtest.h>`, `<quiver/database.h>`, `<quiver/element.h>`.

    Test cases to implement (all use `":memory:"` databases with `QUIVER_LOG_OFF`):

    **Begin/Commit lifecycle (TXN-01):**
    - `BeginMultipleWritesCommit`: Use `collections.sql` schema. Create config element. Call `begin_transaction()`, create two Collection elements, call `commit()`. Verify both elements exist via `read_scalar_strings`. Assert `in_transaction()` is true between begin and commit, false after commit.

    **Begin/Rollback lifecycle (TXN-01):**
    - `BeginMultipleWritesRollback`: Use `collections.sql` schema. Create config element. Call `begin_transaction()`, create two Collection elements, call `rollback()`. Verify neither element exists via `read_scalar_strings` (should return empty). Assert `in_transaction()` is false after rollback.

    **Nested write methods work inside transaction (TXN-02):**
    - `WriteMethodsInsideTransaction`: Use `collections.sql` schema. Create config + one Collection element outside transaction. Call `begin_transaction()`, then exercise multiple write method types: `update_vector_integers`, `update_set_strings`, `update_time_series_group`, `create_element` (for a second Collection element). Call `commit()`. Verify all writes persisted. This proves TransactionGuard no-op works across all 10+ call sites.

    **Rollback undoes mixed writes (TXN-01 + TXN-02):**
    - `RollbackUndoesMixedWrites`: Use `collections.sql` schema. Create config + one Collection element. Call `begin_transaction()`, update vectors and create another element, call `rollback()`. Verify the vector is unchanged and the second element does not exist.

    **Error: double begin (TXN-03):**
    - `DoubleBeginThrows`: Use `basic.sql` schema. Call `begin_transaction()`, then call `begin_transaction()` again. Expect `std::runtime_error` with message `"Cannot begin_transaction: transaction already active"`. Call `rollback()` to clean up.

    **Error: commit without begin (TXN-03):**
    - `CommitWithoutBeginThrows`: Use `basic.sql` schema. Call `commit()` without prior `begin_transaction()`. Expect `std::runtime_error` with message `"Cannot commit: no active transaction"`.

    **Error: rollback without begin (TXN-03):**
    - `RollbackWithoutBeginThrows`: Use `basic.sql` schema. Call `rollback()` without prior `begin_transaction()`. Expect `std::runtime_error` with message `"Cannot rollback: no active transaction"`.

    **in_transaction query (TXN-01):**
    - `InTransactionReflectsState`: Use `basic.sql` schema. Assert `in_transaction()` is false initially, true after `begin_transaction()`, false after `commit()`. Repeat: true after `begin_transaction()`, false after `rollback()`.

    Use `EXPECT_THROW` or try/catch pattern for error tests (match existing codebase style from test_database_create.cpp). Use the `DatabaseTransaction` test suite name (first arg to `TEST()`).

    **2. Register in `tests/CMakeLists.txt`**

    Add `test_database_transaction.cpp` to the `quiver_tests` target source list, maintaining alphabetical order (after `test_database_time_series.cpp`, before `test_element.cpp`).
  </action>
  <verify>
    Build: `cmake --build build --config Debug`

    Run transaction tests specifically: `./build/bin/quiver_tests.exe --gtest_filter=DatabaseTransaction.*`

    All 8 transaction tests must pass. Then run full test suite: `./build/bin/quiver_tests.exe`

    All tests (existing + new) must pass.
  </verify>
  <done>
    - `test_database_transaction.cpp` exists with 8 test cases covering TXN-01, TXN-02, TXN-03
    - Tests registered in CMakeLists.txt
    - All 8 transaction tests pass
    - All existing tests still pass (full regression)
    - Begin/commit lifecycle verified with data persistence checks
    - Begin/rollback lifecycle verified with data absence checks
    - Multiple write method types verified inside explicit transaction
    - All 3 error messages verified exactly
    - in_transaction() state transitions verified
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` succeeds with no errors
2. `./build/bin/quiver_tests.exe` -- ALL tests pass (existing + new transaction tests)
3. `./build/bin/quiver_tests.exe --gtest_filter=DatabaseTransaction.*` -- all 8 transaction tests pass
4. Verify `database.h` has `begin_transaction`, `commit`, `rollback`, `in_transaction` in public section
5. Verify `database_impl.h` TransactionGuard has `owns_transaction_` and checks `sqlite3_get_autocommit`
6. Verify `database.cpp` public methods have precondition checks; `migrate_up` and `apply_schema` use `impl_->`
7. CLAUDE.md documents the new transaction API
</verification>

<success_criteria>
- Public C++ API: `begin_transaction()`, `commit()`, `rollback()`, `in_transaction()` on Database
- Nest-aware TransactionGuard: no-op when inside explicit transaction
- Internal callers bypass public checks via `impl_->`
- 8 new tests covering all 3 requirements pass
- Zero regressions in existing test suite
- CLAUDE.md updated
</success_criteria>

<output>
After completion, create `.planning/phases/01-c-transaction-core/01-01-SUMMARY.md`
</output>
