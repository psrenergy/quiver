---
phase: 01-quiver-lua-cli-executable
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmake/Dependencies.cmake
  - src/CMakeLists.txt
  - src/database.cpp
  - src/cli/main.cpp
autonomous: true
requirements:
  - CLI-01
  - CLI-02
  - CLI-03
  - DB-01
  - DB-02
  - DB-03
  - DB-04
  - DB-05
  - SCRIPT-01
  - SCRIPT-02
  - SCRIPT-03
  - ERR-01
  - ERR-02
  - ERR-03

must_haves:
  truths:
    - "User can run `quiver_lua --help` and see flag descriptions"
    - "User can run `quiver_lua --version` and see 'quiver_lua 0.5.0'"
    - "User can run `quiver_lua mydb.db script.lua` to execute a Lua script against a database"
    - "User can run `quiver_lua mydb.db script.lua --schema schema.sql` to create a database from a schema"
    - "User can run `quiver_lua mydb.db script.lua --migrations dir/` to create a database from migrations"
    - "User receives exit code 2 for invalid arguments (missing database, bad flags)"
    - "User receives exit code 1 for runtime errors (Lua errors, database errors)"
    - "User sees error messages on stderr, script output on stdout"
    - "Lua scripts with UTF-8 BOM execute correctly"
  artifacts:
    - path: "src/cli/main.cpp"
      provides: "CLI entry point — argument parsing, database construction, script execution"
    - path: "cmake/Dependencies.cmake"
      provides: "argparse v3.2 FetchContent dependency"
    - path: "src/CMakeLists.txt"
      provides: "quiver_lua executable target with QUIVER_VERSION define"
    - path: "src/database.cpp"
      provides: "spdlog stderr sink (was stdout)"
  key_links:
    - from: "src/cli/main.cpp"
      to: "quiver::Database"
      via: "constructor, from_schema(), from_migrations()"
      pattern: "Database\\(|from_schema|from_migrations"
    - from: "src/cli/main.cpp"
      to: "quiver::LuaRunner"
      via: "constructor + run()"
      pattern: "LuaRunner.*run"
    - from: "src/CMakeLists.txt"
      to: "quiver_lua target"
      via: "add_executable + target_link_libraries"
      pattern: "add_executable.*quiver_lua"
---

<objective>
Ship the complete `quiver_lua` CLI executable that opens a Quiver database and runs a Lua script against it.

Purpose: Deliver the v0.5 milestone — a standalone command-line tool wrapping the existing Database + LuaRunner C++ classes with argument parsing, error handling, and proper exit codes.
Output: Working `quiver_lua.exe` in `build/bin/`, built unconditionally by the existing `cmake --build build` workflow.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-quiver-lua-cli-executable/01-CONTEXT.md
@.planning/phases/01-quiver-lua-cli-executable/01-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From include/quiver/database.h:
```cpp
class Database {
public:
    explicit Database(const std::string& path, const DatabaseOptions& options = default_database_options());
    static Database from_migrations(const std::string& db_path,
                                    const std::string& migrations_path,
                                    const DatabaseOptions& options = default_database_options());
    static Database from_schema(const std::string& db_path,
                                const std::string& schema_path,
                                const DatabaseOptions& options = default_database_options());
};
```

From include/quiver/options.h:
```cpp
using DatabaseOptions = quiver_database_options_t;
inline DatabaseOptions default_database_options() {
    return {0, QUIVER_LOG_INFO};
}
```

From include/quiver/c/options.h:
```cpp
typedef enum {
    QUIVER_LOG_DEBUG = 0, QUIVER_LOG_INFO = 1, QUIVER_LOG_WARN = 2,
    QUIVER_LOG_ERROR = 3, QUIVER_LOG_OFF = 4,
} quiver_log_level_t;

typedef struct {
    int read_only;
    quiver_log_level_t console_level;
} quiver_database_options_t;
```

From include/quiver/lua_runner.h:
```cpp
class LuaRunner {
public:
    explicit LuaRunner(Database& db);
    void run(const std::string& script);
};
```

From src/database.cpp (line 51, the spdlog sink to fix):
```cpp
auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
```

From src/CMakeLists.txt (line 115-117, existing version pattern):
```cmake
target_compile_definitions(quiver_c PRIVATE
    QUIVER_VERSION="${PROJECT_VERSION}"
)
```

From CMakeLists.txt (line 3):
```cmake
project(quiver VERSION 0.5.0 ...)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add argparse dependency, create quiver_lua CMake target, fix spdlog sink</name>
  <files>
    cmake/Dependencies.cmake
    src/CMakeLists.txt
    src/database.cpp
  </files>
  <action>
Three changes in three existing files:

**1. cmake/Dependencies.cmake — Add argparse FetchContent block**

After the existing `rapidcsv` block (before the GoogleTest block), add:

```cmake
# argparse for CLI argument parsing (header-only)
FetchContent_Declare(argparse
    GIT_REPOSITORY https://github.com/p-ranav/argparse.git
    GIT_TAG v3.2
)
FetchContent_MakeAvailable(argparse)
```

Place it OUTSIDE the `if(QUIVER_BUILD_TESTS)` guard — argparse is needed unconditionally.

**2. src/CMakeLists.txt — Add quiver_lua executable target**

At the END of the file (after the `quiver_c` block, after the final `endif()`), add:

```cmake
# CLI executable
add_executable(quiver_lua cli/main.cpp)

target_compile_definitions(quiver_lua PRIVATE
    QUIVER_VERSION="${PROJECT_VERSION}"
)

target_link_libraries(quiver_lua PRIVATE
    quiver
    quiver_compiler_options
    argparse
)
```

This is unconditional — not behind a build option. The executable is the primary v0.5 deliverable. It links `quiver` (core library), `quiver_compiler_options` (project-wide warnings/flags), and `argparse` (CLI parsing).

Do NOT add `/bigobj` for quiver_lua — it only includes public quiver headers, not sol2 template-heavy code.

**3. src/database.cpp — Change spdlog from stdout to stderr**

Change the include on line 11:
```cpp
// BEFORE:
#include <spdlog/sinks/stdout_color_sinks.h>
// AFTER:
#include <spdlog/sinks/stderr_color_sinks.h>
```

Change the sink construction on line 51:
```cpp
// BEFORE:
auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
// AFTER:
auto console_sink = std::make_shared<spdlog::sinks::stderr_color_sink_mt>();
```

This keeps spdlog output on stderr so stdout is clean for Lua `print()` output. Per CONTEXT.md: "spdlog output goes to stderr, keeping stdout clean for script output." The project is WIP with no backwards compatibility requirement.
  </action>
  <verify>
    <automated>cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Debug -DQUIVER_BUILD_TESTS=ON -DQUIVER_BUILD_C_API=ON C:/Development/DatabaseTmp/quiver4 && cmake --build C:/Development/DatabaseTmp/quiver4/build --config Debug --target quiver 2>&1 | tail -5</automated>
  </verify>
  <done>
    - cmake/Dependencies.cmake contains argparse FetchContent block
    - src/CMakeLists.txt contains unconditional `add_executable(quiver_lua ...)` target
    - src/database.cpp uses `stderr_color_sink_mt` instead of `stdout_color_sink_mt`
    - `cmake --build build --target quiver` succeeds (library still builds with the spdlog change)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement src/cli/main.cpp — full CLI entry point</name>
  <files>
    src/cli/main.cpp
  </files>
  <action>
Create new file `src/cli/main.cpp`. This is the complete CLI implementation (~100-150 lines). The file must implement ALL 14 requirements in a single `main()` function.

**Structure overview:**

```
1. Includes
2. Helper: read_script_file() — reads file, strips UTF-8 BOM
3. Helper: parse_log_level() — maps string to quiver_log_level_t
4. main() — parse args, validate, construct database, run script
```

**Detailed implementation:**

**Includes:**
```cpp
#include <quiver/database.h>
#include <quiver/lua_runner.h>

#include <argparse/argparse.hpp>

#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
```

**read_script_file(const std::string& path) -> std::string:**
- Open file in binary mode with `std::ifstream`
- Read entire contents into a `std::string` using `std::istreambuf_iterator`
- If the string starts with bytes `\xEF\xBB\xBF` (UTF-8 BOM), erase the first 3 bytes
- Return the content
- This function is only called AFTER the existence check in main(), so it does not need to check existence itself. If the file cannot be opened (e.g., permission error), throw `std::runtime_error("Failed to read script file: " + path)`.
- [SCRIPT-03]: BOM stripping

**parse_log_level(const std::string& level) -> quiver_log_level_t:**
- Simple if-chain: "debug" -> QUIVER_LOG_DEBUG, "info" -> QUIVER_LOG_INFO, "warn" -> QUIVER_LOG_WARN, "error" -> QUIVER_LOG_ERROR, "off" -> QUIVER_LOG_OFF
- If no match: throw `std::runtime_error("Unknown log level: " + level)`
- [ERR-03]

**main(int argc, char* argv[]):**

Step 1 — Configure argparse:
```cpp
argparse::ArgumentParser program("quiver_lua", "quiver_lua " QUIVER_VERSION);
```
The second argument is the version string. When `--version` is used, argparse prints this string and exits. This satisfies [CLI-02] ("quiver_lua X.Y.Z" format).

Do NOT call `program.add_description()` or `program.add_epilog()` — the user decision says "flags only: no program description, no usage examples." [CLI-01]

Add positional arguments:
```cpp
program.add_argument("database")
    .help("path to the database file");

program.add_argument("script")
    .help("path to the Lua script file")
    .nargs(argparse::nargs_pattern::optional);
```
Script is optional to prepare for future REPL mode. [SCRIPT-01]

Add optional flags:
```cpp
program.add_argument("--schema")
    .help("create database from schema file");

program.add_argument("--migrations")
    .help("create database from migrations directory");

program.add_argument("--read-only")
    .help("open database in read-only mode")
    .flag();

program.add_argument("--log-level")
    .help("set log verbosity (debug, info, warn, error, off)")
    .default_value(std::string("warn"));
```
Default log level is "warn" per CONTEXT.md. [DB-05], [ERR-03]

Step 2 — Parse arguments:
```cpp
try {
    program.parse_args(argc, argv);
} catch (const std::exception& e) {
    std::cerr << e.what() << std::endl;
    return 2;
}
```
[CLI-03]: Exit code 2 for usage errors. No "error: " prefix per CONTEXT.md.

Step 3 — Post-parse validation:
```cpp
// Mutual exclusivity check [DB-04]
if (program.is_used("--schema") && program.is_used("--migrations")) {
    std::cerr << "Cannot use --schema and --migrations together" << std::endl;
    return 2;
}

// Script required (for now) — prepare for future REPL
auto script_path = program.present<std::string>("script");
if (!script_path) {
    std::cerr << "No script provided" << std::endl;
    return 2;
}
```
Do NOT use argparse's mutually_exclusive_group — the auto-generated error message doesn't match the user's desired wording. Use manual `is_used()` checking instead.

Step 4 — Runtime operations (wrapped in try/catch for exit code 1):
```cpp
try {
    // Check script file exists [SCRIPT-02]
    if (!std::filesystem::exists(*script_path)) {
        std::cerr << "Script file not found: " << *script_path << std::endl;
        return 1;
    }

    // Configure database options [DB-05], [ERR-03]
    quiver::DatabaseOptions options{};
    options.read_only = program.get<bool>("--read-only") ? 1 : 0;
    options.console_level = parse_log_level(program.get<std::string>("--log-level"));

    // Construct database (one of three modes) [DB-01], [DB-02], [DB-03]
    auto db_path = program.get<std::string>("database");

    quiver::Database db = [&]() -> quiver::Database {
        if (program.is_used("--schema")) {
            return quiver::Database::from_schema(db_path, program.get<std::string>("--schema"), options);
        }
        if (program.is_used("--migrations")) {
            return quiver::Database::from_migrations(db_path, program.get<std::string>("--migrations"), options);
        }
        return quiver::Database(db_path, options);
    }();

    // Read and execute script [SCRIPT-01], [SCRIPT-03]
    auto script = read_script_file(*script_path);
    quiver::LuaRunner lua(db);
    lua.run(script);

} catch (const std::exception& e) {
    // [ERR-01], [ERR-02]: Lua and database errors on stderr, exit 1
    std::cerr << e.what() << std::endl;
    return 1;
}

return 0;
```

**CRITICAL constraints from CONTEXT.md (locked decisions):**
- No "error: " prefix on any error messages — exit code signals the error
- Lua runtime errors pass through from C++ as-is (includes "Lua error: " prefix from LuaRunner)
- Database errors pass through from C++ as-is
- File-not-found uses user's input path, NOT resolved absolute path
- "--schema" and "--migrations" conflict message: exactly "Cannot use --schema and --migrations together"
- spdlog is NOT used in CLI code — use `std::cerr` only
- No validation of schema/migration file existence in CLI — pass through to C++
- No file content reading for migrations — pass directory path to `from_migrations()` which handles traversal internally
  </action>
  <verify>
    <automated>cmake --build C:/Development/DatabaseTmp/quiver4/build --config Debug --target quiver_lua 2>&1 | tail -5 && C:/Development/DatabaseTmp/quiver4/build/bin/quiver_lua.exe --version && C:/Development/DatabaseTmp/quiver4/build/bin/quiver_lua.exe --help</automated>
  </verify>
  <done>
    - src/cli/main.cpp exists and compiles
    - `quiver_lua --version` prints "quiver_lua 0.5.0"
    - `quiver_lua --help` shows flags without program description or examples
    - `quiver_lua` with no args returns exit code 2
    - `quiver_lua mydb.db` (no script) prints "No script provided" to stderr and returns exit code 2
    - `quiver_lua mydb.db script.lua --schema s.sql --migrations m/` prints "Cannot use --schema and --migrations together" to stderr and returns exit code 2
    - `quiver_lua mydb.db nonexistent.lua` prints "Script file not found: nonexistent.lua" to stderr and returns exit code 1
    - Existing test suite (`quiver_tests.exe`, `quiver_c_tests.exe`) still passes with the spdlog stderr change
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full requirement set:

1. **Build**: `cmake --build build --config Debug` succeeds with no errors
2. **Existing tests**: `build/bin/quiver_tests.exe` and `build/bin/quiver_c_tests.exe` pass (spdlog change is non-breaking)
3. **CLI-01**: `quiver_lua --help` shows flags, no description/examples
4. **CLI-02**: `quiver_lua --version` prints "quiver_lua 0.5.0"
5. **CLI-03**: `quiver_lua --bad-flag` returns exit code 2
6. **DB-01**: `quiver_lua existing.db script.lua` opens existing database
7. **DB-02**: `quiver_lua new.db script.lua --schema tests/schemas/valid/basic.sql` creates from schema
8. **DB-03**: `quiver_lua new.db script.lua --migrations tests/schemas/valid/` creates from migrations directory
9. **DB-04**: `quiver_lua db --schema s --migrations m` returns exit code 2 with "Cannot use --schema and --migrations together"
10. **DB-05**: `quiver_lua db script.lua --read-only` opens in read-only mode
11. **SCRIPT-01**: Script with `print("hello")` produces "hello" on stdout
12. **SCRIPT-02**: `quiver_lua db missing.lua` prints "Script file not found: missing.lua" and returns exit code 1
13. **SCRIPT-03**: Create a test script with UTF-8 BOM prefix, verify it executes correctly
14. **ERR-01**: Script with `error("boom")` prints Lua error on stderr, returns exit code 1
15. **ERR-02**: Invalid database path produces database error on stderr, returns exit code 1
16. **ERR-03**: `quiver_lua db script.lua --log-level debug` enables debug logging on stderr
</verification>

<success_criteria>
- `build/bin/quiver_lua.exe` exists and runs
- All 14 requirements (CLI-01 through ERR-03) verified
- Existing test suite passes (spdlog change is non-breaking)
- stdout is clean (only Lua `print()` output), all errors and logs go to stderr
</success_criteria>

<output>
After completion, create `.planning/phases/01-quiver-lua-cli-executable/01-01-SUMMARY.md`
</output>
