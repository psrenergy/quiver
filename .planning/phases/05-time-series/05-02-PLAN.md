---
phase: 05-time-series
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - bindings/python/src/quiver/database.py
  - bindings/python/tests/test_database_time_series.py
autonomous: true
requirements: [TS-03]
must_haves:
  truths:
    - "has_time_series_files returns True for collections with a files table and False otherwise"
    - "list_time_series_files_columns returns list of column names from the files table"
    - "read_time_series_files returns a dict mapping column names to paths (str or None)"
    - "update_time_series_files persists file paths and round-trips through read"
  artifacts:
    - path: "bindings/python/src/quiver/database.py"
      provides: "has_time_series_files, list_time_series_files_columns, read_time_series_files, update_time_series_files methods"
      contains: "def has_time_series_files"
    - path: "bindings/python/tests/test_database_time_series.py"
      provides: "Tests for all time series files operations"
      contains: "test_has_time_series_files"
  key_links:
    - from: "bindings/python/src/quiver/database.py"
      to: "quiver_database_has_time_series_files"
      via: "CFFI lib call with int* out-param"
      pattern: "quiver_database_has_time_series_files"
    - from: "bindings/python/src/quiver/database.py"
      to: "quiver_database_free_time_series_files"
      via: "try/finally cleanup of read results"
      pattern: "free_time_series_files"
---

<objective>
Implement the four time series files methods on the Database class and add comprehensive tests for all files operations.

Purpose: TS-03 completes the time series surface by wrapping the simpler file-reference operations. These use straightforward parallel string arrays, reusing patterns from existing scalar string reads.

Output: Four new Database methods for time series files, plus tests covering has/list/read/update/round-trip scenarios.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-time-series/05-CONTEXT.md
@.planning/phases/05-time-series/05-RESEARCH.md
@.planning/phases/05-time-series/05-01-SUMMARY.md
@bindings/python/src/quiver/_c_api.py
@bindings/python/src/quiver/database.py
@include/quiver/c/database.h
@tests/schemas/valid/collections.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement time series files methods</name>
  <files>
    bindings/python/src/quiver/database.py
  </files>
  <action>
Add four methods to the Database class in `database.py`, after `update_time_series_group`. Add a section comment `# -- Time series files --`. CFFI declarations were already added in Plan 01.

**1. `has_time_series_files`**
- Signature: `def has_time_series_files(self, collection: str) -> bool:`
- Call `quiver_database_has_time_series_files` with `int*` out-param
- Return `bool(out[0])`

**2. `list_time_series_files_columns`**
- Signature: `def list_time_series_files_columns(self, collection: str) -> list[str]:`
- Call `quiver_database_list_time_series_files_columns` with `char***` and `size_t*` out-params
- If count == 0, return `[]`
- In try block: decode each string via `ffi.string(...).decode("utf-8")`
- In finally block: call `quiver_database_free_string_array(out_columns[0], count)` -- the columns are just a string array, freed with the standard string array free

**3. `read_time_series_files`**
- Signature: `def read_time_series_files(self, collection: str) -> dict[str, str | None]:`
- Call `quiver_database_read_time_series_files` with two `char***` out-params (columns, paths) and `size_t*`
- If count == 0, return `{}`
- In try block: build dict mapping column names to paths. For each index, decode column name. For path: if `out_paths[0][i] == ffi.NULL`, set value to `None`; else decode string
- In finally block: call `quiver_database_free_time_series_files(out_columns[0], out_paths[0], count)`

**4. `update_time_series_files`**
- Signature: `def update_time_series_files(self, collection: str, data: dict[str, str | None]) -> None:`
- Per CONTEXT.md: symmetric API -- same dict shape as read returns
- Build parallel arrays from dict:
  - `c_columns = ffi.new("const char*[]", count)` with encoded column names (keepalive)
  - `c_paths = ffi.new("const char*[]", count)` with encoded paths or `ffi.NULL` for None values (keepalive)
- Call `quiver_database_update_time_series_files` with arrays and count
  </action>
  <verify>
Run `python -c "from quiver import Database; print(hasattr(Database, 'has_time_series_files'))"` -- should print True.
  </verify>
  <done>
All four time series files methods exist on Database with correct signatures and proper memory management (try/finally for reads, keepalive for writes).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add time series files tests</name>
  <files>
    bindings/python/tests/test_database_time_series.py
  </files>
  <action>
Append tests to the existing `test_database_time_series.py` file (created in Plan 01). Use the `collections_db` fixture which has `Collection_time_series_files` table with `data_file` and `metadata_file` columns. Also use `mixed_time_series_db` which does NOT have a files table.

**Tests to add:**

- `test_has_time_series_files_true` -- `collections_db.has_time_series_files("Collection")` returns `True`
- `test_has_time_series_files_false` -- `mixed_time_series_db.has_time_series_files("Sensor")` returns `False` (Sensor schema has no files table)
- `test_list_time_series_files_columns` -- `collections_db.list_time_series_files_columns("Collection")` returns `["data_file", "metadata_file"]` (or sorted equivalent)
- `test_read_time_series_files_initial` -- before any update, `read_time_series_files` returns dict with all columns mapped to `None`
- `test_update_and_read_time_series_files` -- update with `{"data_file": "/path/to/data.csv", "metadata_file": "/path/to/meta.json"}`, then read back and verify exact match
- `test_update_time_series_files_partial_none` -- update with one path set and one None, read back and verify None preserved
- `test_update_time_series_files_overwrite` -- update with values, then update again with different values, verify second values persisted
  </action>
  <verify>
Run `bindings/python/test/test.bat`. All time series tests pass (both group tests from Plan 01 and files tests from this plan).
  </verify>
  <done>
All time series files tests pass: has_time_series_files returns correct bool, list returns column names, read/update round-trip preserves paths and None values, overwrite works correctly.
  </done>
</task>

</tasks>

<verification>
1. All four files methods exist on Database class
2. `has_time_series_files` correctly distinguishes collections with/without files table
3. `read_time_series_files` / `update_time_series_files` round-trip preserves paths and None values
4. All tests in `test_database_time_series.py` pass (group + files)
5. Full test suite passes: `bindings/python/test/test.bat`
</verification>

<success_criteria>
- has_time_series_files returns correct boolean
- list_time_series_files_columns returns column names
- read/update files round-trip works with string paths and None values
- All test_database_time_series.py tests pass (group + files)
- Full Python test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-time-series/05-02-SUMMARY.md`
</output>
