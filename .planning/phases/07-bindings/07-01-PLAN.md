---
phase: 07-bindings
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/julia/src/database_csv.jl
  - bindings/julia/test/test_database_csv.jl
  - bindings/dart/lib/src/database_csv.dart
  - bindings/dart/test/database_csv_test.dart
autonomous: true
requirements: [BIND-01, BIND-02]

must_haves:
  truths:
    - "Julia export_csv(db, collection, group, path) produces correct CSV with default options"
    - "Julia export_csv(db, ...; enum_labels=Dict(...), date_time_format='...') marshals options to C API flat struct"
    - "Dart exportCSV(collection, group, path) produces correct CSV with default options"
    - "Dart exportCSV(collection, group, path, enumLabels: {...}, dateTimeFormat: '...') marshals options to C API flat struct"
    - "Julia and Dart produce byte-identical CSV output for the same input data and options"
  artifacts:
    - path: "bindings/julia/src/database_csv.jl"
      provides: "Julia export_csv with build_csv_options marshaling"
      contains: "build_csv_options"
    - path: "bindings/julia/test/test_database_csv.jl"
      provides: "Julia CSV export tests"
      contains: "export_csv"
    - path: "bindings/dart/lib/src/database_csv.dart"
      provides: "Dart exportCSV with arena-based options marshaling"
      contains: "exportCSV"
    - path: "bindings/dart/test/database_csv_test.dart"
      provides: "Dart CSV export tests"
      contains: "exportCSV"
  key_links:
    - from: "bindings/julia/src/database_csv.jl"
      to: "bindings/julia/src/c_api.jl"
      via: "C.quiver_database_export_csv 5-param call"
      pattern: "C\\.quiver_database_export_csv"
    - from: "bindings/dart/lib/src/database_csv.dart"
      to: "bindings/dart/lib/src/ffi/bindings.dart"
      via: "bindings.quiver_database_export_csv 5-param call"
      pattern: "bindings\\.quiver_database_export_csv"
---

<objective>
Implement Julia and Dart CSV export wrappers that marshal native map types to the C API flat struct and produce correct CSV output.

Purpose: BIND-01 and BIND-02 require idiomatic Julia/Dart wrappers that convert language-native Dict/Map to the C API's `quiver_csv_export_options_t` flat parallel-array struct. The existing stale stubs must be completely replaced.

Output: Working Julia `export_csv` with keyword args, working Dart `exportCSV` with named params, tests for both.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-bindings/07-CONTEXT.md
@.planning/phases/07-bindings/07-RESEARCH.md
@.planning/phases/06-c-api/06-02-SUMMARY.md
@CLAUDE.md
@bindings/julia/src/c_api.jl (lines 47-58: quiver_csv_export_options_t struct and default function; lines 397-399: quiver_database_export_csv 5-param FFI declaration)
@bindings/julia/src/database.jl (lines 11-20: build_options pattern to mirror)
@bindings/julia/src/database_csv.jl (stale 3-param stub to replace)
@bindings/dart/lib/src/database_csv.dart (stale 2-param stub to replace)
@bindings/dart/lib/src/ffi/bindings.dart (lines 3105-3118: quiver_csv_export_options_t struct; lines 2350-2387: quiver_database_export_csv 5-param function)
@include/quiver/c/csv.h (C API flat struct definition — source of truth for field layout)
@tests/schemas/valid/csv_export.sql (shared test schema)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Julia export_csv with build_csv_options marshaling and tests</name>
  <files>
    bindings/julia/src/database_csv.jl
    bindings/julia/test/test_database_csv.jl
  </files>
  <action>
Replace the entire contents of `bindings/julia/src/database_csv.jl` with a new implementation:

1. **`build_csv_options(kwargs...)`** helper function (mirrors `build_options` pattern in `database.jl` lines 11-20):
   - Start with `quiver_csv_export_options_default()` struct
   - If `:date_time_format` kwarg present: convert Julia String to C string pointer. Store the temporary in a collection for GC.@preserve.
   - If `:enum_labels` kwarg present (a `Dict{String, Dict{Int, String}}`): flatten into parallel arrays:
     - `c_attr_names`: `Vector{Ptr{Cchar}}` — one per attribute name
     - `c_entry_counts`: `Vector{Csize_t}` — number of entries per attribute
     - `c_values`: `Vector{Int64}` — all integer values concatenated
     - `c_labels`: `Vector{Ptr{Cchar}}` — all label strings concatenated
     - Set struct fields: `enum_attribute_names`, `enum_entry_counts`, `enum_values`, `enum_labels`, `enum_attribute_count`
   - Return `(opts_ref, temps)` where `temps` is a vector of all temporary objects that must stay alive during the C call (for GC.@preserve)

2. **`export_csv(db::Database, collection::String, group::String, path::String; kwargs...)`**:
   - Call `build_csv_options(kwargs)` to get `(opts, temps)`
   - Wrap C call in `GC.@preserve temps begin ... end`
   - Call `check(C.quiver_database_export_csv(db.ptr, collection, group, path, opts))`
   - Return nothing

3. **Keep `import_csv` stub** — do not remove it (it still exists in C API)

**CRITICAL Julia FFI details:**
- The `quiver_csv_export_options_t` Julia struct is immutable (auto-generated). To set fields, construct a new instance with all fields via positional constructor: `quiver_csv_export_options_t(date_time_format_ptr, attr_names_ptr, entry_counts_ptr, values_ptr, labels_ptr, attr_count)`
- Use `Base.unsafe_convert(Ptr{Cchar}, str)` for Julia strings → C pointers (valid within GC.@preserve)
- Use `pointer(vec)` for Julia vectors → C array pointers (valid within GC.@preserve)
- The `opts` must be `Ref{C.quiver_csv_export_options_t}` — passed as `Ptr{C.quiver_csv_export_options_t}` to @ccall

Create `bindings/julia/test/test_database_csv.jl` with these tests:
- **Scalar export with defaults**: Create Items, export scalars (group=""), read CSV, verify header and data rows
- **Group export (vector)**: Export "measurements" group, verify label column replaces id
- **Enum labels**: Export scalars with `enum_labels=Dict("status" => Dict(1 => "Active", 2 => "Inactive"))`, verify labels in output
- **Date formatting**: Export scalars with `date_time_format="%Y/%m/%d"`, verify reformatted dates
- **Combined options**: Both enum_labels and date_time_format together

Test pattern: Use `from_schema` with `:memory:` and `csv_export.sql` schema. Create test elements. Export to a `tempname()` file. Read file contents. Verify with `@test`. Clean up temp file in a `try/finally`.
  </action>
  <verify>
Run `bindings/julia/test/test.bat` — all Julia tests pass including new CSV tests. Alternatively: `julia --project=bindings/julia bindings/julia/test/runtests.jl test_database_csv.jl`
  </verify>
  <done>
Julia `export_csv` accepts keyword arguments for enum_labels (Dict{String, Dict{Int, String}}) and date_time_format (String), correctly marshals to C API flat struct, produces correct CSV output. All 5+ CSV tests pass. Default options work without any kwargs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Dart exportCSV with arena-based options marshaling and tests</name>
  <files>
    bindings/dart/lib/src/database_csv.dart
    bindings/dart/test/database_csv_test.dart
  </files>
  <action>
Replace the `exportCSV` method in `bindings/dart/lib/src/database_csv.dart`:

1. **New `exportCSV` signature** (on `DatabaseCSV` extension on `Database`):
```dart
void exportCSV(
  String collection,
  String group,
  String path, {
  Map<String, Map<int, String>>? enumLabels,
  String? dateTimeFormat,
})
```

2. **Implementation using Arena pattern** (mirrors existing Dart code in `database.dart`):
   - `_ensureNotClosed()`
   - Create `Arena()`
   - Allocate `arena<quiver_csv_export_options_t>()` for the options struct
   - Set `date_time_format`: `(dateTimeFormat ?? '').toNativeUtf8(allocator: arena).cast<Char>()`
   - If `enumLabels` not null and not empty:
     - Flatten `Map<String, Map<int, String>>` into parallel arrays:
       - `enum_attribute_names`: `Pointer<Pointer<Char>>` array of attribute name C strings
       - `enum_entry_counts`: `Pointer<Size>` array of entry counts per attribute
       - `enum_values`: `Pointer<Int64>` array of all integer values concatenated
       - `enum_labels`: `Pointer<Pointer<Char>>` array of all label C strings concatenated
       - `enum_attribute_count`: total number of attributes
     - All allocations via `arena` allocator — freed automatically in `finally`
   - If `enumLabels` null or empty: set all pointer fields to `nullptr`, `enum_attribute_count` to 0
   - Call `check(bindings.quiver_database_export_csv(_ptr, collectionN, groupN, pathN, optsPtr))`
   - `arena.releaseAll()` in finally block

3. **Keep `importCSV` stub** — do not remove it

**CRITICAL Dart FFI details:**
- `quiver_csv_export_options_default` is NOT available in Dart FFI (not in ffigen include-directives). Construct the struct manually.
- Use `arena<quiver_csv_export_options_t>()` to allocate, then set `.ref.field = value` for each field
- For array allocation: `arena<Pointer<Char>>(attrCount)` allocates a `Pointer<Pointer<Char>>` with N slots
- For Int64 array: `arena<Int64>(totalValues)` allocates a `Pointer<Int64>` with N slots
- For Size array: `arena<Size>(attrCount)` allocates a `Pointer<Size>` with N slots
- Use `ffi.nullptr` for null pointer fields (import `dart:ffi` as `ffi` is standard in this project — check existing imports)

Create `bindings/dart/test/database_csv_test.dart` with these tests:
- **Scalar export with defaults**: Create Items, export scalars (group=""), read CSV, verify header and data rows
- **Group export (vector)**: Export "measurements" group, verify label column replaces id
- **Enum labels**: Export scalars with `enumLabels: {"status": {1: "Active", 2: "Inactive"}}`, verify labels
- **Date formatting**: Export scalars with `dateTimeFormat: "%Y/%m/%d"`, verify reformatted dates
- **Combined options**: Both enumLabels and dateTimeFormat together

Test pattern: Use `Database.fromSchema` with temp file path and `csv_export.sql` schema. Create test elements. Export to temp file. Read file with `dart:io`. Verify with `expect`. Clean up in `tearDown`.
  </action>
  <verify>
Run `bindings/dart/test/test.bat` — all Dart tests pass including new CSV tests.
  </verify>
  <done>
Dart `exportCSV` accepts named parameters for enumLabels (Map<String, Map<int, String>>) and dateTimeFormat (String), correctly marshals to C API flat struct via Arena, produces correct CSV output. All 5+ CSV tests pass. Default options work without any named params.
  </done>
</task>

</tasks>

<verification>
1. `bindings/julia/test/test.bat` — all Julia tests pass (existing + new CSV tests)
2. `bindings/dart/test/test.bat` — all Dart tests pass (existing + new CSV tests)
3. Julia and Dart produce identical CSV output for the same input data and options (verified by matching test assertions)
</verification>

<success_criteria>
- Julia `export_csv` with keyword args works for default, enum_labels, date_time_format, and combined options
- Dart `exportCSV` with named params works for default, enum_labels, date_time_format, and combined options
- Both bindings use the 5-param C API `quiver_database_export_csv` with correctly marshaled flat struct
- All existing binding tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/07-bindings/07-01-SUMMARY.md`
</output>
