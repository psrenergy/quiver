---
phase: 07-bindings
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lua_runner.cpp
  - tests/test_lua_runner.cpp
autonomous: true
requirements: [BIND-03]

must_haves:
  truths:
    - "Lua db:export_csv(collection, group, path) produces correct CSV with default options"
    - "Lua db:export_csv(collection, group, path, {enum_labels=..., date_time_format=...}) marshals Lua table to C++ CSVExportOptions"
    - "Omitting the options table argument uses defaults (no crash, no error)"
  artifacts:
    - path: "src/lua_runner.cpp"
      provides: "Lua export_csv binding via sol2 lambda"
      contains: "export_csv"
    - path: "tests/test_lua_runner.cpp"
      provides: "Lua CSV export test cases"
      contains: "export_csv"
  key_links:
    - from: "src/lua_runner.cpp"
      to: "include/quiver/csv.h"
      via: "#include and CSVExportOptions construction"
      pattern: "export_csv"
    - from: "tests/test_lua_runner.cpp"
      to: "tests/schemas/valid/csv_export.sql"
      via: "Schema reference for CSV test data"
      pattern: "csv_export"
---

<objective>
Add Lua `export_csv` binding to the sol2 usertype in lua_runner.cpp and add Lua CSV export tests.

Purpose: BIND-03 requires Lua users to call `db:export_csv(collection, group, path, opts_table)` with native Lua table for options. Lua bypasses the C API and calls the C++ `Database::export_csv()` directly via sol2, per project design decision.

Output: Working Lua `export_csv` binding with optional table argument, C++ tests verifying Lua CSV export behavior.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-bindings/07-CONTEXT.md
@.planning/phases/07-bindings/07-RESEARCH.md
@CLAUDE.md
@src/lua_runner.cpp (bind_database function — add export_csv binding near "describe" around line 168)
@include/quiver/csv.h (CSVExportOptions struct — target for Lua table conversion)
@tests/test_lua_runner.cpp (add CSV export test cases)
@tests/schemas/valid/csv_export.sql (shared test schema)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Lua export_csv binding to lua_runner.cpp</name>
  <files>
    src/lua_runner.cpp
  </files>
  <action>
1. **Add `#include "quiver/csv.h"`** at the top of `lua_runner.cpp` (after existing includes).

2. **Add `export_csv` lambda** in `bind_database()`, after the `"describe"` binding (around line 169). Place it in a new comment group: `// Group 11: CSV export`. The binding:

```cpp
"export_csv",
[](Database& self,
   const std::string& collection,
   const std::string& group,
   const std::string& path,
   sol::optional<sol::table> opts_table) {
    CSVExportOptions opts;
    if (opts_table) {
        auto& t = *opts_table;
        if (auto fmt = t.get<sol::optional<std::string>>("date_time_format")) {
            opts.date_time_format = *fmt;
        }
        if (auto enums = t.get<sol::optional<sol::table>>("enum_labels")) {
            enums->for_each([&](sol::object attr_key, sol::object attr_value) {
                auto attr_name = attr_key.as<std::string>();
                auto& attr_map = opts.enum_labels[attr_name];
                attr_value.as<sol::table>().for_each([&](sol::object k, sol::object v) {
                    attr_map[k.as<int64_t>()] = v.as<std::string>();
                });
            });
        }
    }
    self.export_csv(collection, group, path, opts);
},
```

Key details:
- Lua bypasses C API entirely — calls `self.export_csv()` C++ method directly via sol2
- `sol::optional<sol::table>` makes the options table argument optional — callers can omit it entirely
- Enum integer keys extracted via `k.as<int64_t>()` (sol2 handles Lua number → int64_t correctly for integer values per Lua 5.4)
- No binding-layer validation — pass through to C++, let C++ surface errors
  </action>
  <verify>
`cmake --build build --config Debug` compiles successfully with the new binding.
  </verify>
  <done>
`export_csv` lambda registered in the sol2 usertype. Lua scripts can call `db:export_csv(collection, group, path)` (defaults) or `db:export_csv(collection, group, path, {enum_labels = {...}, date_time_format = "..."})` (with options).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Lua CSV export tests to test_lua_runner.cpp</name>
  <files>
    tests/test_lua_runner.cpp
  </files>
  <action>
Add new test cases at the end of `test_lua_runner.cpp` (before the closing of the test file), using the `csv_export.sql` schema. Follow the existing test patterns in this file (GTest TEST_F or TEST, create db from schema, run Lua script, verify).

Test cases to add:

1. **`LuaRunner_ExportCSV_ScalarDefaults`**: Create a database from `csv_export.sql`. Create test elements via Lua. Call `db:export_csv("Items", "", temp_path)` in Lua. Read the output CSV file in C++ and verify header contains "label,name,status,price,date_created,notes" and data rows are correct.

2. **`LuaRunner_ExportCSV_GroupExport`**: Create elements with vector data. Call `db:export_csv("Items", "measurements", temp_path)` in Lua. Verify header contains "label,vector_index,measurement" and data rows are correct.

3. **`LuaRunner_ExportCSV_EnumLabels`**: Create elements with integer status values. Call:
```lua
db:export_csv("Items", "", temp_path, {
    enum_labels = {
        status = {[1] = "Active", [2] = "Inactive"}
    }
})
```
Verify the CSV contains "Active"/"Inactive" instead of 1/2.

4. **`LuaRunner_ExportCSV_DateTimeFormat`**: Create elements with ISO datetime strings in `date_created`. Call:
```lua
db:export_csv("Items", "", temp_path, {
    date_time_format = "%Y/%m/%d"
})
```
Verify the CSV contains reformatted dates.

5. **`LuaRunner_ExportCSV_CombinedOptions`**: Both enum_labels and date_time_format together.

Test helpers:
- Use `std::tmpnam` or platform temp file for output path
- Read CSV file with `std::ifstream` and verify line-by-line
- Clean up temp file in test teardown
- Reference schema: `tests/schemas/valid/csv_export.sql`

The test fixture should match the existing pattern in test_lua_runner.cpp for creating databases and running Lua scripts.
  </action>
  <verify>
Run `./build/bin/quiver_tests.exe --gtest_filter=*LuaRunner*CSV*` — all Lua CSV tests pass. Then run full test suite `./build/bin/quiver_tests.exe` to confirm no regressions.
  </verify>
  <done>
5 Lua CSV export tests pass: scalar defaults, group export, enum labels, date formatting, combined options. Full C++ test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` compiles cleanly
2. `./build/bin/quiver_tests.exe --gtest_filter=*LuaRunner*CSV*` — all 5 Lua CSV tests pass
3. `./build/bin/quiver_tests.exe` — full C++ test suite passes (no regressions)
</verification>

<success_criteria>
- Lua `db:export_csv(collection, group, path)` works with default options
- Lua `db:export_csv(collection, group, path, {enum_labels = {...}, date_time_format = "..."})` works with full options
- Options table argument is truly optional (omitting it uses defaults)
- All existing Lua tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/07-bindings/07-02-SUMMARY.md`
</output>
