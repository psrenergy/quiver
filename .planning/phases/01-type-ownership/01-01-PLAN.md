---
phase: 01-type-ownership
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/quiver/options.h
  - include/quiver/database.h
  - src/database.cpp
  - src/cli/main.cpp
  - src/c/database_options.h
  - src/c/database.cpp
autonomous: true
requirements:
  - TYPES-01
  - TYPES-02
must_haves:
  truths:
    - "include/quiver/options.h has zero includes from include/quiver/c/"
    - "DatabaseOptions is a struct with bool read_only and enum class LogLevel console_level"
    - "LogLevel enum class has values Debug=0, Info=1, Warn=2, Error=3, Off=4"
    - "default_database_options() is removed -- DatabaseOptions{} gives defaults via member initializers"
    - "C API boundary converts quiver_database_options_t to quiver::DatabaseOptions before calling C++ core"
    - "CSVOptions remains unchanged (already a proper C++ type)"
  artifacts:
    - path: "include/quiver/options.h"
      provides: "C++ LogLevel enum class and DatabaseOptions struct"
      contains: "enum class LogLevel"
    - path: "src/c/database_options.h"
      provides: "convert_database_options boundary function"
      contains: "convert_database_options"
    - path: "src/c/database.cpp"
      provides: "C API functions using boundary conversion"
      contains: "convert_database_options"
  key_links:
    - from: "src/c/database.cpp"
      to: "src/c/database_options.h"
      via: "convert_database_options() call"
      pattern: "convert_database_options"
    - from: "include/quiver/database.h"
      to: "include/quiver/options.h"
      via: "DatabaseOptions default parameter"
      pattern: "DatabaseOptions& options = \\{\\}"
---

<objective>
Define native C++ types (enum class LogLevel, struct DatabaseOptions) in the C++ public header, add a C-to-C++ conversion function in the C API boundary layer, and update all production code to use the new types.

Purpose: Eliminate the layer inversion where the C++ core header depends on the C API header. After this plan, `include/quiver/options.h` compiles independently without any C API includes.

Output: Updated production source files. C++ library and CLI build successfully with the new types. C API struct layout is unchanged. Bindings are untouched.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-type-ownership/01-CONTEXT.md
@.planning/phases/01-type-ownership/01-RESEARCH.md

<interfaces>
<!-- Current include/quiver/options.h (being replaced): -->
```cpp
// include/quiver/options.h -- CURRENT (layer inversion)
#include "quiver/c/options.h"              // <-- THIS IS THE PROBLEM
using DatabaseOptions = quiver_database_options_t;  // typedef alias
inline DatabaseOptions default_database_options() { return {0, QUIVER_LOG_INFO}; }
```

<!-- Current include/quiver/c/options.h (UNCHANGED by this plan): -->
```cpp
typedef enum {
    QUIVER_LOG_DEBUG = 0, QUIVER_LOG_INFO = 1, QUIVER_LOG_WARN = 2,
    QUIVER_LOG_ERROR = 3, QUIVER_LOG_OFF = 4,
} quiver_log_level_t;
typedef struct {
    int read_only;
    quiver_log_level_t console_level;
} quiver_database_options_t;
```

<!-- Current src/c/database_options.h (add conversion function alongside existing CSV conversion): -->
```cpp
inline quiver::CSVOptions convert_options(const quiver_csv_options_t* options) { ... }
inline quiver_csv_options_t csv_options_default() { ... }
```

<!-- Current src/database.cpp internal functions (lines 26-43): -->
```cpp
spdlog::level::level_enum to_spdlog_level(quiver_log_level_t level) { ... }
std::shared_ptr<spdlog::logger> create_database_logger(const std::string& db_path, quiver_log_level_t console_level) { ... }
```

<!-- Current src/cli/main.cpp (lines 25-37): -->
```cpp
static quiver_log_level_t parse_log_level(const std::string& level) {
    if (level == "debug") return QUIVER_LOG_DEBUG;
    ...
}
// line 85: options.read_only = program.get<bool>("--read-only") ? 1 : 0;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define native C++ types in options.h and update database.h default arguments</name>
  <files>
    include/quiver/options.h
    include/quiver/database.h
  </files>
  <action>
**include/quiver/options.h** -- Replace the entire file contents with:

1. Remove `#include "quiver/c/options.h"` (the layer inversion).
2. Remove `using DatabaseOptions = quiver_database_options_t;` typedef.
3. Remove `default_database_options()` function entirely.
4. Add `enum class LogLevel` with explicit integer values matching the C enum: `Debug = 0, Info = 1, Warn = 2, Error = 3, Off = 4`.
5. Add `struct QUIVER_API DatabaseOptions` with:
   - `bool read_only = false;`
   - `LogLevel console_level = LogLevel::Info;`
6. Keep `CSVOptions` and `default_csv_options()` exactly as they are (no changes -- TYPES-02 already satisfied).
7. Keep existing includes: `"export.h"`, `<cstdint>`, `<string>`, `<unordered_map>`.

Target state of options.h:
```cpp
#ifndef QUIVER_OPTIONS_H
#define QUIVER_OPTIONS_H

#include "export.h"

#include <cstdint>
#include <string>
#include <unordered_map>

namespace quiver {

enum class LogLevel {
    Debug = 0,
    Info = 1,
    Warn = 2,
    Error = 3,
    Off = 4,
};

struct QUIVER_API DatabaseOptions {
    bool read_only = false;
    LogLevel console_level = LogLevel::Info;
};

struct QUIVER_API CSVOptions {
    std::unordered_map<std::string, std::unordered_map<std::string, std::unordered_map<std::string, int64_t>>>
        enum_labels;
    std::string date_time_format;
};

inline CSVOptions default_csv_options() {
    return {};
}

}  // namespace quiver

#endif  // QUIVER_OPTIONS_H
```

**include/quiver/database.h** -- Update the three default argument expressions:

- Line 19: Change `default_database_options()` to `{}` in the `Database` constructor.
- Line 31: Change `default_database_options()` to `{}` in `from_migrations`.
- Line 35: Change `default_database_options()` to `{}` in `from_schema`.

All three become: `const DatabaseOptions& options = {}`
  </action>
  <verify>
    <automated>cmake --build build --config Debug --target quiver 2>&1 | tail -5</automated>
  </verify>
  <done>include/quiver/options.h has zero C API includes, defines enum class LogLevel and struct DatabaseOptions with member initializers, and default_database_options() is removed. database.h uses {} for default arguments.</done>
</task>

<task type="auto">
  <name>Task 2: Update production code to use C++ types and add boundary conversion</name>
  <files>
    src/database.cpp
    src/cli/main.cpp
    src/c/database_options.h
    src/c/database.cpp
  </files>
  <action>
**src/c/database_options.h** -- Add `convert_database_options` inline function BEFORE the existing `convert_options` function. Add at the top of the file body (after includes, before existing functions):

```cpp
inline quiver::DatabaseOptions convert_database_options(const quiver_database_options_t& c_opts) {
    return {
        .read_only = c_opts.read_only != 0,
        .console_level = static_cast<quiver::LogLevel>(c_opts.console_level),
    };
}
```

This is safe because LogLevel integer values explicitly match quiver_log_level_t values (both 0-4).

**src/c/database.cpp** -- Three changes:

1. Add `#include "database_options.h"` after the existing `#include "internal.h"` (needed for `convert_database_options`).

2. Replace `quiver_database_options_default` body:
   - Before: `return quiver::default_database_options();`
   - After: `return {0, QUIVER_LOG_INFO};`

3. Update `quiver_database_open` -- convert C options before constructing:
   - Before: `*out_db = new quiver_database(path, *options);`
   - After: `*out_db = new quiver_database(path, convert_database_options(*options));`
   - Before: `auto default_options = quiver::default_database_options();` / `*out_db = new quiver_database(path, default_options);`
   - After: `*out_db = new quiver_database(path, quiver::DatabaseOptions{});`

4. Update `quiver_database_from_migrations` similarly:
   - `*options` usages: `quiver::Database::from_migrations(db_path, migrations_path, convert_database_options(*options));`
   - `else` branch: `auto db = quiver::Database::from_migrations(db_path, migrations_path, quiver::DatabaseOptions{});`

5. Update `quiver_database_from_schema` similarly:
   - `*options` usages: `quiver::Database::from_schema(db_path, schema_path, convert_database_options(*options));`
   - `else` branch: `auto db = quiver::Database::from_schema(db_path, schema_path, quiver::DatabaseOptions{});`

**src/database.cpp** -- Two changes to the anonymous namespace functions:

1. Change `to_spdlog_level` parameter from `quiver_log_level_t level` to `quiver::LogLevel level`. Update all switch cases:
   - `QUIVER_LOG_DEBUG` -> `quiver::LogLevel::Debug`
   - `QUIVER_LOG_INFO` -> `quiver::LogLevel::Info`
   - `QUIVER_LOG_WARN` -> `quiver::LogLevel::Warn`
   - `QUIVER_LOG_ERROR` -> `quiver::LogLevel::Error`
   - `QUIVER_LOG_OFF` -> `quiver::LogLevel::Off`
   - Keep the `default:` case returning `spdlog::level::info`.

2. Change `create_database_logger` parameter from `quiver_log_level_t console_level` to `quiver::LogLevel console_level`. Body is unchanged (it already just passes through to `to_spdlog_level`).

**src/cli/main.cpp** -- Two changes:

1. Change `parse_log_level` return type from `quiver_log_level_t` to `quiver::LogLevel`. Update return values:
   - `QUIVER_LOG_DEBUG` -> `quiver::LogLevel::Debug`
   - `QUIVER_LOG_INFO` -> `quiver::LogLevel::Info`
   - `QUIVER_LOG_WARN` -> `quiver::LogLevel::Warn`
   - `QUIVER_LOG_ERROR` -> `quiver::LogLevel::Error`
   - `QUIVER_LOG_OFF` -> `quiver::LogLevel::Off`

2. Line 85: Change `options.read_only = program.get<bool>("--read-only") ? 1 : 0;` to `options.read_only = program.get<bool>("--read-only");` (field is now `bool`, not `int`).
  </action>
  <verify>
    <automated>cmake --build build --config Debug --target quiver --target quiver_c --target quiver_cli 2>&1 | tail -5</automated>
  </verify>
  <done>All production code compiles with the new C++ types. src/database.cpp uses LogLevel enum class. CLI uses LogLevel enum class. C API boundary converts quiver_database_options_t to DatabaseOptions. quiver_database_options_default() returns C struct directly without calling removed default_database_options().</done>
</task>

</tasks>

<verification>
1. `include/quiver/options.h` contains no `#include` referencing `quiver/c/` -- verify with: `grep -c "quiver/c/" include/quiver/options.h` returns 0
2. Library target (`quiver`) builds without errors
3. C API target (`quiver_c`) builds without errors
4. CLI target (`quiver_cli`) builds without errors
5. C API struct layout in `include/quiver/c/options.h` is completely unchanged
</verification>

<success_criteria>
- `cmake --build build --config Debug --target quiver --target quiver_c --target quiver_cli` succeeds with zero errors
- `grep "quiver/c/" include/quiver/options.h` returns no matches
- `grep "default_database_options" include/quiver/options.h include/quiver/database.h` returns no matches
- `grep "enum class LogLevel" include/quiver/options.h` returns a match
</success_criteria>

<output>
After completion, create `.planning/phases/01-type-ownership/01-01-SUMMARY.md`
</output>
