---
phase: 01-bug-fixes-and-element-dedup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/quiver/database.h
  - include/quiver/schema.h
  - src/schema.cpp
  - src/database_describe.cpp
  - tests/test_database_lifecycle.cpp
autonomous: true
requirements: [BUG-02, BUG-03]

must_haves:
  truths:
    - "describe() prints each category header (Scalars, Vectors, Sets, Time Series) exactly once per collection, regardless of how many group tables exist"
    - "describe() shows time series groups with dimension column highlighted in brackets"
    - "describe() displays columns in schema-definition order, not alphabetical"
    - "import_csv parameter is named 'collection' in the C++ header declaration, matching the implementation"
  artifacts:
    - path: "include/quiver/database.h"
      provides: "import_csv with collection parameter name"
      contains: "import_csv(const std::string& collection"
    - path: "include/quiver/schema.h"
      provides: "TableDefinition with column_order vector"
      contains: "std::vector<std::string> column_order"
    - path: "src/database_describe.cpp"
      provides: "Restructured describe output with collected groups and time series support"
  key_links:
    - from: "src/schema.cpp"
      to: "include/quiver/schema.h"
      via: "column_order populated in load_from_database"
      pattern: "column_order\\.push_back"
    - from: "src/database_describe.cpp"
      to: "include/quiver/schema.h"
      via: "iterates column_order for display ordering"
      pattern: "column_order"
---

<objective>
Fix two independent bugs: rename `import_csv`'s header parameter from `table` to `collection` (BUG-03), and restructure `describe()` to print category headers once per collection, display columns in schema-definition order, and add time series group output (BUG-02).

Purpose: Eliminate cosmetic inconsistencies and incomplete schema display output.
Output: Corrected header, restructured describe with time series support, ordered columns.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bug-fixes-and-element-dedup/01-CONTEXT.md

<interfaces>
<!-- Key types and contracts the executor needs. -->

From include/quiver/schema.h:
```cpp
struct ColumnDefinition {
    std::string name;
    DataType type;
    bool not_null;
    bool primary_key;
    std::optional<std::string> default_value;
};

struct TableDefinition {
    std::string name;
    std::map<std::string, ColumnDefinition> columns;  // fast lookup by name
    std::vector<ForeignKey> foreign_keys;
    std::vector<Index> indexes;
    // NOTE: column_order vector needs to be ADDED here
};

class Schema {
    // Table classification methods used by describe():
    bool is_collection(const std::string& table) const;
    bool is_vector_table(const std::string& table) const;
    bool is_set_table(const std::string& table) const;
    bool is_time_series_table(const std::string& table) const;
    bool is_time_series_files_table(const std::string& table) const;
    std::string get_parent_collection(const std::string& table) const;
    std::vector<std::string> table_names() const;
    std::vector<std::string> collection_names() const;
};
```

From src/schema.cpp (load_from_database, lines 312-325):
```cpp
// Current code loses column order when inserting into std::map
for (auto& col : columns) {
    table.columns[col.name] = std::move(col);
}
```

From src/schema.cpp (query_columns, lines 328-364):
```cpp
// Returns columns in PRAGMA table_info order (schema-definition order)
std::vector<ColumnDefinition> Schema::query_columns(sqlite3* db, const std::string& table);
```

From include/quiver/database.h line 128:
```cpp
// Current: uses "table" (the bug)
void import_csv(const std::string& table,
                const std::string& group,
                const std::string& path,
                const CSVOptions& options = default_csv_options());
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rename import_csv parameter and add column_order to TableDefinition</name>
  <files>include/quiver/database.h, include/quiver/schema.h, src/schema.cpp</files>
  <action>
**BUG-03 fix (one-line):**
In `include/quiver/database.h` line 128, change `const std::string& table` to `const std::string& collection` in the `import_csv` declaration. The implementation at `src/database_csv_import.cpp:220` already uses `collection`. No other files need changes -- the C API and all bindings already use `collection`.

**column_order addition (for BUG-02):**
1. In `include/quiver/schema.h`, add a `std::vector<std::string> column_order;` field to `struct TableDefinition`, placed after the `columns` map. This preserves schema-definition order alongside the map's fast lookup.

2. In `src/schema.cpp`, in `Schema::load_from_database()`, after the loop that populates `table.columns` from `query_columns()` result (around lines 316-319), add a loop that populates `table.column_order` by iterating the `columns` vector (which is already in PRAGMA table_info order) and pushing each `col.name`. This must happen BEFORE the `std::move(col)` into the map. Restructure the loop:

```cpp
auto columns = query_columns(db, name);
for (const auto& col : columns) {
    table.column_order.push_back(col.name);
}
for (auto& col : columns) {
    table.columns[col.name] = std::move(col);
}
```

Note: The first loop uses `const auto&` (reads names), the second uses `auto&` (moves values). This is necessary because `std::move` invalidates the source.
  </action>
  <verify>
    <automated>cmake --build build --config Debug 2>&1 | tail -5</automated>
  </verify>
  <done>
- `import_csv` declaration uses `collection` parameter name
- `TableDefinition` has `column_order` vector populated in schema-definition order
- Project compiles without errors
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Restructure describe() output with collected groups and time series</name>
  <files>src/database_describe.cpp, tests/test_database_lifecycle.cpp</files>
  <behavior>
- Test: describe() with multiple vector groups prints "Vectors:" header exactly once
- Test: describe() with multiple set groups prints "Sets:" header exactly once
- Test: describe() with time series groups prints "Time Series:" header with dimension column in brackets, e.g. `data: [date_time] value(Real), count(Integer)`
- Test: describe() column order matches schema definition order, not alphabetical
- Test: describe() with no groups of a category omits that category header entirely
  </behavior>
  <action>
Rewrite `src/database_describe.cpp` to collect all groups per category before printing:

**Scalars section:** Use `column_order` instead of iterating `table_def->columns` map directly. For each column name in `table_def->column_order`, look up the column definition from `table_def->columns`:
```cpp
if (table_def && !table_def->column_order.empty()) {
    std::cout << "  Scalars:\n";
    for (const auto& name : table_def->column_order) {
        const auto& col = table_def->columns.at(name);
        // print column info...
    }
}
```

**Vectors section:** Collect all matching vector tables into a vector FIRST, then print header once:
```cpp
std::vector<std::pair<std::string, const TableDefinition*>> vector_groups;
for (const auto& table_name : impl_->schema->table_names()) {
    if (!impl_->schema->is_vector_table(table_name)) continue;
    if (impl_->schema->get_parent_collection(table_name) != collection) continue;
    auto group_name = table_name.substr(prefix_vec.size());
    const auto* vec_table = impl_->schema->get_table(table_name);
    if (vec_table) vector_groups.emplace_back(group_name, vec_table);
}
if (!vector_groups.empty()) {
    std::cout << "  Vectors:\n";
    for (const auto& [group_name, vec_table] : vector_groups) {
        std::cout << "    - " << group_name << ": ";
        bool first = true;
        for (const auto& col_name : vec_table->column_order) {
            if (col_name == "id" || col_name == "vector_index") continue;
            const auto& col = vec_table->columns.at(col_name);
            if (!first) std::cout << ", ";
            std::cout << col_name << "(" << data_type_to_string(col.type) << ")";
            first = false;
        }
        std::cout << "\n";
    }
}
```

**Sets section:** Same pattern as Vectors but skip only `id` column (sets have no `vector_index`).

**Time Series section (new):** Same collect-then-print pattern, but highlight the dimension column (any column whose name starts with `date_`) in brackets:
```cpp
// For time series groups, dimension column in brackets:
// data: [date_time] value(Real), count(Integer)
for (const auto& col_name : ts_table->column_order) {
    if (col_name == "id") continue;
    const auto& col = ts_table->columns.at(col_name);
    if (!first) std::cout << ", ";
    bool is_dimension = col_name.substr(0, 5) == "date_";
    if (is_dimension) {
        std::cout << "[" << col_name << "]";
    } else {
        std::cout << col_name << "(" << data_type_to_string(col.type) << ")";
    }
    first = false;
}
```

**Tests:** Add tests in `tests/test_database_lifecycle.cpp` that capture `std::cout` output from `describe()` and verify:
1. Use a schema with multiple vector groups and multiple set groups to verify headers print once
2. Use a schema with time series to verify time series section appears with bracket notation
3. Verify column ordering matches schema definition

Use `std::ostringstream` with `std::cout.rdbuf()` redirect to capture output for assertions, restoring the original buffer in a scope guard.

A suitable test schema exists or can use `tests/schemas/valid/time_series.sql` or similar. Check existing test schemas with time series tables. If no suitable schema exists with multiple vector/set groups AND time series, create one at `tests/schemas/valid/describe_multi_group.sql`.
  </action>
  <verify>
    <automated>./build/bin/quiver_tests.exe --gtest_filter="*describe*" 2>&1</automated>
  </verify>
  <done>
- "Vectors:" header prints exactly once even with multiple vector tables
- "Sets:" header prints exactly once even with multiple set tables
- "Time Series:" header prints with dimension column in brackets
- Column display order matches schema-definition order (PRAGMA table_info)
- All existing tests still pass
  </done>
</task>

</tasks>

<verification>
```bash
# Build and run all C++ tests
cmake --build build --config Debug && ./build/bin/quiver_tests.exe

# Verify import_csv parameter rename
grep -n "import_csv" include/quiver/database.h

# Verify column_order exists in schema.h
grep -n "column_order" include/quiver/schema.h

# Verify no duplicate headers in describe
grep -c "Vectors:" src/database_describe.cpp  # Should be 1
grep -c "Sets:" src/database_describe.cpp     # Should be 1
```
</verification>

<success_criteria>
- BUG-02: `describe()` prints each category header exactly once per collection, includes time series with bracketed dimension column, displays columns in schema-definition order
- BUG-03: `import_csv` declaration uses `collection` parameter name matching implementation
- All existing C++ tests pass unchanged
- New describe tests verify the corrected behavior
</success_criteria>

<output>
After completion, create `.planning/phases/01-bug-fixes-and-element-dedup/01-01-SUMMARY.md`
</output>
