---
phase: 08-lua-fk-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [tests/test_lua_runner.cpp]
autonomous: true
requirements: [LUA-01]
must_haves:
  truths:
    - "Lua create_element resolves scalar FK string label to integer ID"
    - "Lua create_element resolves vector FK string labels to integer IDs"
    - "Lua create_element resolves set FK string labels to integer IDs"
    - "Lua create_element resolves time series FK string labels to integer IDs"
    - "Lua create_element resolves all FK types in a single call"
    - "Lua create_element raises error for nonexistent FK target"
    - "Lua create_element raises error for string in non-FK integer column"
    - "Lua create_element produces zero partial writes on FK failure"
    - "Lua create_element passes non-FK integers unchanged"
  artifacts:
    - path: "tests/test_lua_runner.cpp"
      provides: "LuaRunnerFkTest fixture + 9 FK create tests"
      contains: "LuaRunnerFkTest"
  key_links:
    - from: "tests/test_lua_runner.cpp"
      to: "LuaRunner::run()"
      via: "lua.run() with create_element Lua scripts"
      pattern: 'lua\.run\(R"'
    - from: "tests/test_lua_runner.cpp"
      to: "Database read methods"
      via: "C++ EXPECT_EQ verification of resolved FK IDs"
      pattern: "db\\.read_scalar_integers|db\\.read_vector_integers_by_id|db\\.read_set_integers|db\\.read_time_series_group"
---

<objective>
Add 9 FK resolution create tests to the Lua test file, covering all column types (scalar, vector, set, time series), combined, no-FK regression, error cases, and partial write safety.

Purpose: Verify that FK label-to-ID resolution works correctly when `create_element` is called from Lua scripts, completing the create-path coverage for the Lua binding layer.
Output: `LuaRunnerFkTest` fixture class + 9 passing tests appended to `tests/test_lua_runner.cpp`
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-lua-fk-tests/08-CONTEXT.md
@.planning/phases/08-lua-fk-tests/08-RESEARCH.md
@tests/test_lua_runner.cpp
@tests/test_database_create.cpp (lines 341-567 — C++ FK create tests to mirror)
@tests/schemas/valid/relations.sql
@tests/schemas/valid/basic.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LuaRunnerFkTest fixture and 9 FK create tests</name>
  <files>tests/test_lua_runner.cpp</files>
  <action>
Append the following to the END of `tests/test_lua_runner.cpp` (after the last existing test, line ~2124):

1. **Comment block separator:**
```cpp
// ============================================================================
// FK label resolution tests
// ============================================================================
```

2. **New test fixture** (separate from existing `LuaRunnerTest`):
```cpp
class LuaRunnerFkTest : public ::testing::Test {
protected:
    void SetUp() override {
        relations_schema = VALID_SCHEMA("relations.sql");
        basic_schema = VALID_SCHEMA("basic.sql");
    }
    std::string relations_schema;
    std::string basic_schema;
};
```
Note: `basic_schema` is needed for test 8 (no-FK regression). The existing file already includes `test_utils.h` which provides the `VALID_SCHEMA` macro.

3. **9 tests** using `TEST_F(LuaRunnerFkTest, ...)`. Each test creates a fresh `:memory:` database. Lua scripts write, C++ reads back for verification. Follow the naming convention of existing tests (CamelCase).

**Test 1: CreateElementSetFkLabels** — Create 2 parents in Lua, create child with `mentor_id = {"Parent 1", "Parent 2"}`. C++ reads `db.read_set_integers("Child", "mentor_id")`, sorts result, expects `{1, 2}`. Include `#include <algorithm>` at top of file if not already present (it IS already present — line 3).

**Test 2: CreateElementMissingFkTarget** — `EXPECT_THROW` on `lua.run()` that creates child with `mentor_id = {"Nonexistent Parent"}`. No message inspection.

**Test 3: CreateElementStringForNonFkInteger** — `EXPECT_THROW` on `lua.run()` that creates child with `score = {"not_a_label"}` (score is a non-FK integer set column in relations.sql).

**Test 4: CreateElementScalarFkLabel** — Create parent in Lua, create child with `parent_id = "Parent 1"`. C++ reads `db.read_scalar_integers("Child", "parent_id")` -> expects `[1]`.

**Test 5: CreateElementVectorFkLabels** — Create 2 parents in Lua, create child with `parent_ref = {"Parent 1", "Parent 2"}`. C++ reads `db.read_vector_integers_by_id("Child", "parent_ref", 1)` -> expects `{1, 2}`.

**Test 6: CreateElementTimeSeriesFkLabels** — Create 2 parents in Lua, create child with `date_time = {"2024-01-01", "2024-01-02"}, sponsor_id = {"Parent 1", "Parent 2"}`. C++ reads `db.read_time_series_group("Child", "events", 1)` -> expects `sponsor_id` values `{1, 2}` via `std::get<int64_t>(row.at("sponsor_id"))`.

**Test 7: CreateElementAllFkTypes** — Create 2 parents in Lua. Create child with ALL FK types in one create_element call: `parent_id = "Parent 1"` (scalar FK), `mentor_id = {"Parent 2"}` (set FK), `parent_ref = {"Parent 1"}` (vector+set FK), `date_time = {"2024-01-01"}, sponsor_id = {"Parent 2"}` (time series FK). C++ reads back all four types and verifies resolved IDs.

**Test 8: CreateElementNoFkUnchanged** — Uses `basic_schema` (no FK columns). Create element in Lua with `label = "Config 1", integer_attribute = 42, float_attribute = 3.14`. C++ reads back and verifies values unchanged. This is a regression test: non-FK schemas must pass through unmodified.

**Test 9: CreateElementFkResolutionNoPartialWrites** — `EXPECT_THROW` on `lua.run()` that creates child with `parent_id = "Nonexistent"`. Then C++ verifies `db.read_scalar_strings("Child", "label").size() == 0` — no Child element exists (zero partial writes per CONTEXT.md decision).

IMPORTANT implementation notes:
- All Lua scripts use `lua.run(R"( ... )")` raw string literals
- Verification is always C++ `EXPECT_EQ`/`ASSERT_EQ`, never Lua `assert()`
- Error tests are `EXPECT_THROW(lua.run(...), std::runtime_error)` — no message substring matching
- Set read-back results should be sorted before comparison (pitfall 2 from research)
- Time series group name is `"events"` (not the full table name)
  </action>
  <verify>
Build and run the Lua tests:
```bash
cmake --build build --config Debug && ./build/bin/quiver_tests.exe --gtest_filter="LuaRunnerFkTest.*"
```
All 9 LuaRunnerFkTest tests pass. Also run the full suite to confirm no regressions:
```bash
./build/bin/quiver_tests.exe
```
  </verify>
  <done>9 LuaRunnerFkTest create tests pass, covering set FK, scalar FK, vector FK, time series FK, all types combined, missing target error, non-FK integer error, no partial writes, and no-FK regression. Full test suite still passes with no regressions.</done>
</task>

</tasks>

<verification>
- `./build/bin/quiver_tests.exe --gtest_filter="LuaRunnerFkTest.*"` passes all 9 tests
- `./build/bin/quiver_tests.exe` passes all tests (no regressions)
- `LuaRunnerFkTest` fixture exists in `tests/test_lua_runner.cpp` with `relations.sql` schema
- FK tests are grouped at end of file with comment block separator
</verification>

<success_criteria>
All 9 FK create tests pass through the Lua scripting layer, verifying FK label-to-ID resolution works identically to C++. Each test writes via Lua, reads back via C++, and confirms resolved integer IDs. Error paths throw on invalid FK targets. No partial writes on failure.
</success_criteria>

<output>
After completion, create `.planning/phases/08-lua-fk-tests/08-01-SUMMARY.md`
</output>
