---
phase: 08-lua-fk-tests
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified: [tests/test_lua_runner.cpp]
autonomous: true
requirements: [LUA-02]
must_haves:
  truths:
    - "Lua update_element resolves scalar FK string label to integer ID"
    - "Lua update_element resolves set FK string labels to integer IDs"
    - "Lua update_element resolves all FK types in a single call"
    - "Lua update_element failure preserves existing element data"
    - "Lua update_element passes non-FK values unchanged"
    - "Lua individual typed update methods work with pre-resolved integer IDs for vector FK"
    - "Lua individual typed update methods work with pre-resolved integer IDs for time series FK"
  artifacts:
    - path: "tests/test_lua_runner.cpp"
      provides: "7 FK update tests appended to LuaRunnerFkTest fixture"
      contains: "UpdateElement"
  key_links:
    - from: "tests/test_lua_runner.cpp"
      to: "LuaRunner::run()"
      via: "lua.run() with update_element and individual typed update Lua scripts"
      pattern: 'lua\.run\(R"'
    - from: "tests/test_lua_runner.cpp"
      to: "Database read methods"
      via: "C++ EXPECT_EQ verification of updated FK IDs"
      pattern: "db\\.read_scalar_integers|db\\.read_vector_integers_by_id|db\\.read_set_integers|db\\.read_time_series_group"
---

<objective>
Add 7 FK resolution update tests to the Lua test file, covering both the bulk `update_element` path (with FK resolution) and individual typed methods (with pre-resolved integer IDs).

Purpose: Verify that FK label-to-ID resolution works correctly when update operations are called from Lua scripts, and that individual typed methods accept integer IDs directly.
Output: 7 additional passing tests appended to the `LuaRunnerFkTest` fixture in `tests/test_lua_runner.cpp`
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-lua-fk-tests/08-CONTEXT.md
@.planning/phases/08-lua-fk-tests/08-RESEARCH.md
@.planning/phases/08-lua-fk-tests/08-01-SUMMARY.md
@tests/test_lua_runner.cpp
@tests/test_database_update.cpp (lines 650-878 — C++ FK update tests to mirror)
@tests/schemas/valid/relations.sql
@tests/schemas/valid/basic.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 7 FK update tests to LuaRunnerFkTest fixture</name>
  <files>tests/test_lua_runner.cpp</files>
  <action>
Append 7 update tests to the end of `tests/test_lua_runner.cpp`, after the 9 create tests added by Plan 01. These tests use the existing `LuaRunnerFkTest` fixture.

**Split rationale (per CONTEXT.md and RESEARCH.md):** 5 tests use bulk `update_element` (FK resolution), 2 tests use individual typed methods (pre-resolved integer IDs).

**Via `update_element` (bulk path, with FK resolution) -- 5 tests:**

**Test 1: UpdateElementScalarFkLabel** — In Lua: create 2 parents and 1 child with `parent_id = "Parent 1"`. Then `db:update_element("Child", 1, {parent_id = "Parent 2"})`. C++ reads `db.read_scalar_integers("Child", "parent_id")` -> expects `[2]`.

**Test 2: UpdateElementSetFkLabels** — In Lua: create 2 parents and 1 child with `mentor_id = {"Parent 1"}`. Then `db:update_element("Child", 1, {mentor_id = {"Parent 2"}})`. C++ reads `db.read_set_integers("Child", "mentor_id")` -> expects `{2}`.

**Test 3: UpdateElementAllFkTypes** — In Lua: create 2 parents and 1 child with all FK types pointing to Parent 1 (scalar `parent_id`, set `mentor_id`, vector+set `parent_ref`, time series `date_time + sponsor_id`). Then `db:update_element("Child", 1, {parent_id = "Parent 2", mentor_id = {"Parent 2"}, parent_ref = {"Parent 2"}, date_time = {"2025-01-01"}, sponsor_id = {"Parent 2"}})`. C++ reads all four FK types and verifies all resolved to Parent 2's ID (2).

**Test 4: UpdateElementFkFailurePreservesExisting** — In Lua: create 1 parent and 1 child with `parent_id = "Parent 1"`. Then `EXPECT_THROW` on `lua.run()` that calls `db:update_element("Child", 1, {parent_id = "Nonexistent"})`. C++ reads `db.read_scalar_integers("Child", "parent_id")` -> expects `[1]` (original value preserved).

**Test 5: UpdateElementNoFkUnchanged** — Uses `basic_schema`. In Lua: create element with `label = "Config 1", integer_attribute = 42, float_attribute = 3.14, string_attribute = "hello"`. Then `db:update_element("Configuration", 1, {integer_attribute = 100, float_attribute = 2.71, string_attribute = "world"})`. C++ reads back via `read_scalar_integer_by_id`, `read_scalar_float_by_id`, `read_scalar_string_by_id` -> expects `100`, `2.71`, `"world"`.

**Via individual typed methods (no FK resolution, integer IDs directly) -- 2 tests:**

**Test 6: UpdateVectorFkViaTypedMethod** — In Lua: create 2 parents, create child with `parent_ref = {"Parent 1"}`. Then `db:update_vector_integers("Child", "parent_ref", 1, {2, 1})` (passing integer IDs directly, not string labels). C++ reads `db.read_vector_integers_by_id("Child", "parent_ref", 1)` -> expects `{2, 1}`.

**Test 7: UpdateTimeSeriesFkViaTypedMethod** — In Lua: create 2 parents, create child with time series data (`date_time + sponsor_id` pointing to Parent 1). Then call `db:update_time_series_group("Child", "events", 1, ...)` with new rows containing integer IDs `{2, 1}` directly. The Lua syntax for `update_time_series_group` takes an array of row tables: `{{date_time = "2025-01-01", sponsor_id = 2}, {date_time = "2025-01-02", sponsor_id = 1}}`. C++ reads `db.read_time_series_group("Child", "events", 1)` -> expects `sponsor_id` values `{2, 1}`.

IMPORTANT implementation notes:
- All tests write via Lua `lua.run(R"( ... )")`, verify via C++ assertions
- Bulk `update_element` tests pass string labels (FK resolution happens in C++ layer)
- Individual typed method tests pass integer IDs (no FK resolution needed)
- Error test uses `EXPECT_THROW(..., std::runtime_error)` without message inspection
- Set read-back should be sorted before comparison
- Time series group name is `"events"` (not the full table name)
- For typed method time series update, use `db:update_time_series_group("Child", "events", 1, rows)` where rows is a Lua table of row tables
  </action>
  <verify>
Build and run the Lua FK tests:
```bash
cmake --build build --config Debug && ./build/bin/quiver_tests.exe --gtest_filter="LuaRunnerFkTest.*"
```
All 16 LuaRunnerFkTest tests pass (9 create from Plan 01 + 7 update from this plan). Also run the full suite:
```bash
./build/bin/quiver_tests.exe
```
  </verify>
  <done>16 LuaRunnerFkTest tests pass (9 create + 7 update), covering FK resolution via bulk update_element (scalar, set, all types, failure-preserves, no-FK) and individual typed methods (vector, time series). Full test suite passes with no regressions.</done>
</task>

</tasks>

<verification>
- `./build/bin/quiver_tests.exe --gtest_filter="LuaRunnerFkTest.*"` passes all 16 tests
- `./build/bin/quiver_tests.exe` passes all tests (no regressions)
- Update tests cover both `update_element` (5 tests with FK resolution) and individual typed methods (2 tests with integer IDs)
- Failure-preserves test confirms original values remain after failed FK update
</verification>

<success_criteria>
All 7 FK update tests pass through the Lua scripting layer, verifying FK label-to-ID resolution for update_element and that individual typed methods accept pre-resolved integer IDs. Error paths throw on invalid FK targets and preserve existing data. Non-FK schemas update correctly without interference.
</success_criteria>

<output>
After completion, create `.planning/phases/08-lua-fk-tests/08-02-SUMMARY.md`
</output>
