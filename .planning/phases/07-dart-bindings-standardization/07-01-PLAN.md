---
phase: 07-dart-bindings-standardization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/dart/lib/src/database_delete.dart
  - bindings/dart/lib/src/database.dart
  - bindings/dart/lib/src/element.dart
  - bindings/dart/lib/src/lua_runner.dart
  - bindings/dart/lib/src/database_read.dart
  - bindings/dart/test/database_delete_test.dart
  - bindings/dart/test/element_test.dart
  - bindings/dart/test/database_lifecycle_test.dart
autonomous: true
must_haves:
  truths:
    - "Every Dart wrapper method uses camelCase naming following Dart conventions"
    - "Dart method names map predictably from C API names (strip quiver_database_ prefix, camelCase)"
    - "No custom error strings are defined in Dart wrapper code -- all DatabaseException messages originate from C API"
    - "Dart-side state guards use StateError, not DatabaseException"
    - "Dart-side type dispatch errors use ArgumentError, not DatabaseException"
    - "Dart test suite passes (bindings/dart/test/test.bat green)"
  artifacts:
    - path: "bindings/dart/lib/src/database_delete.dart"
      provides: "deleteElement method (renamed from deleteElementById)"
      contains: "void deleteElement("
    - path: "bindings/dart/lib/src/database.dart"
      provides: "Factory constructors using check() and StateError for _ensureNotClosed"
      contains: "throw StateError"
    - path: "bindings/dart/lib/src/element.dart"
      provides: "Element with ArgumentError for type dispatch, StateError for disposed"
      contains: "throw ArgumentError"
    - path: "bindings/dart/lib/src/lua_runner.dart"
      provides: "LuaRunner with check() constructor and raw error surfacing in run()"
      contains: "check(bindings.quiver_lua_runner_new"
    - path: "bindings/dart/lib/src/database_read.dart"
      provides: "Defensive branches using ArgumentError"
      contains: "throw ArgumentError("
  key_links:
    - from: "bindings/dart/lib/src/lua_runner.dart"
      to: "src/c/lua_runner.cpp"
      via: "quiver_lua_runner_get_error for run() errors (not check(), because lua_runner_run stores in runner->last_error not quiver_set_last_error)"
      pattern: "quiver_lua_runner_get_error"
    - from: "bindings/dart/lib/src/database.dart"
      to: "bindings/dart/lib/src/exceptions.dart"
      via: "Factory constructors now use check() instead of manual error handling"
      pattern: "check\\(bindings\\.quiver_database_from"
    - from: "bindings/dart/lib/src/element.dart"
      to: "src/c/element.cpp -> src/database_create.cpp"
      via: "Empty array check stays in Dart as ArgumentError (Dart-side type dispatch)"
      pattern: "throw ArgumentError"
---

<objective>
Standardize Dart binding names (NAME-04) and error handling (ERRH-04) so all wrapper methods use idiomatic Dart camelCase naming, map predictably from C API names, and surface C API error messages without crafting custom strings.

Purpose: Ensure the Dart binding layer is a thin wrapper that retrieves errors from the C API rather than defining its own error messages, completing the Dart standardization layer of the refactoring roadmap.
Output: 5 modified source files, 3 modified test files, all Dart tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dart-bindings-standardization/07-RESEARCH.md
@bindings/dart/lib/src/database_delete.dart
@bindings/dart/lib/src/database.dart
@bindings/dart/lib/src/element.dart
@bindings/dart/lib/src/lua_runner.dart
@bindings/dart/lib/src/database_read.dart
@bindings/dart/lib/src/exceptions.dart
@bindings/dart/test/database_delete_test.dart
@bindings/dart/test/element_test.dart
@bindings/dart/test/database_lifecycle_test.dart
@bindings/dart/test/lua_runner_test.dart
@src/c/lua_runner.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rename deleteElementById and standardize error handling in database.dart, element.dart, lua_runner.dart</name>
  <files>
    bindings/dart/lib/src/database_delete.dart
    bindings/dart/lib/src/database.dart
    bindings/dart/lib/src/element.dart
    bindings/dart/lib/src/lua_runner.dart
    bindings/dart/test/database_delete_test.dart
    bindings/dart/test/element_test.dart
    bindings/dart/test/database_lifecycle_test.dart
  </files>
  <action>
**database_delete.dart -- Rename method (NAME-04):**
- Rename `deleteElementById` to `deleteElement` (line 7). The function body already calls `bindings.quiver_database_delete_element` correctly.

**database_delete_test.dart -- Update 5 call sites:**
- Replace all 5 occurrences of `db.deleteElementById` with `db.deleteElement`.
- Lines 28, 64, 100, 124, 154.

**database.dart -- Fix factory error handling and state guard (ERRH-04):**

1. **fromSchema factory (lines 41-54):** Replace manual error handling with `check()`. Remove the `if (err != quiver_error_t.QUIVER_OK)` block and fallback string `'Failed to create database from schema'`. Instead, call `check(bindings.quiver_database_from_schema(...))` directly, then `return Database._(outDbPtr.value)`. The C API always calls `quiver_set_last_error` on failure, so `check()` will retrieve the correct message.

2. **fromMigrations factory (lines 72-85):** Same pattern as fromSchema. Replace manual error handling with `check()`. Remove `'Failed to create database from migrations'` fallback.

3. **_ensureNotClosed (lines 93-97):** Change from `throw const DatabaseException('Database has been closed')` to `throw StateError('Database has been closed')`. This correctly distinguishes programming errors (use-after-close) from database errors.

**element.dart -- Fix 4 custom error sites (ERRH-04):**

1. **_ensureNotDisposed (lines 38-42):** Change from `throw const DatabaseException('Element has been disposed')` to `throw StateError('Element has been disposed')`.

2. **set() method, empty list case (line 84):** Change from `throw DatabaseException("Empty list not allowed for '$name'")` to `throw ArgumentError("Empty list not allowed for '$name'")`. This is Dart-side type dispatch, not a database error.

3. **set() method, default case (lines 87-90):** Change from `throw DatabaseException("Unsupported type ...")` to `throw ArgumentError("Unsupported type ${value.runtimeType} for '$name'")`.

4. **_setMixedList, else branch (lines 102-105):** Change from `throw DatabaseException("Unsupported array element type ...")` to `throw ArgumentError("Unsupported array element type ${first.runtimeType} for '$name'")`.

**lua_runner.dart -- Standardize error handling (ERRH-04):**

1. **Constructor (lines 30-46):** Replace manual error handling with `check()`. The C API `quiver_lua_runner_new` DOES call `quiver_set_last_error` on failure, so `check()` works here:
```dart
LuaRunner(Database db) : _ptr = nullptr {
  final arena = Arena();
  try {
    final outRunnerPtr = arena<Pointer<quiver_lua_runner_t>>();
    check(bindings.quiver_lua_runner_new(db.ptr, outRunnerPtr));
    _ptr = outRunnerPtr.value;
  } finally {
    arena.releaseAll();
  }
}
```

2. **_ensureNotDisposed (lines 48-52):** Change from `throw const DatabaseException('LuaRunner has been disposed')` to `throw StateError('LuaRunner has been disposed')`.

3. **run() method (lines 62-85):** CANNOT use `check()` because `quiver_lua_runner_run` stores errors in `runner->last_error` (NOT `quiver_set_last_error`). Keep the `quiver_lua_runner_get_error` call path but:
   - Remove the `'Lua error: '` prefix -- throw `LuaException(errorMsg)` directly instead of `LuaException('Lua error: $errorMsg')`
   - For the fallback when `quiver_lua_runner_get_error` returns no message, use `check(err)` to try the global error path (covers QUIVER_REQUIRE failures):
```dart
void run(String script) {
  _ensureNotDisposed();
  final arena = Arena();
  try {
    final err = bindings.quiver_lua_runner_run(
      _ptr,
      script.toNativeUtf8(allocator: arena).cast(),
    );
    if (err != quiver_error_t.QUIVER_OK) {
      final outErrorPtr = arena<Pointer<Char>>();
      final getErr = bindings.quiver_lua_runner_get_error(_ptr, outErrorPtr);
      if (getErr == quiver_error_t.QUIVER_OK && outErrorPtr.value != nullptr) {
        final errorMsg = outErrorPtr.value.cast<Utf8>().toDartString();
        if (errorMsg.isNotEmpty) {
          throw LuaException(errorMsg);
        }
      }
      // Fallback: try global error (for QUIVER_REQUIRE failures)
      check(err);
    }
  } finally {
    arena.releaseAll();
  }
}
```

**element_test.dart -- Update 2 exception type assertions:**

1. **Line 93:** Change `throwsA(isA<DatabaseException>())` to `throwsA(isA<ArgumentError>())` for the "rejects empty array" test.

2. **Line 187:** Change `throwsA(isA<DatabaseException>())` to `throwsA(isA<StateError>())` for the "throws after dispose" test.

**database_lifecycle_test.dart -- Update 2 exception type assertions:**

1. **Line 129:** Change `throwsA(isA<DatabaseException>())` to `throwsA(isA<StateError>())` for the "throws after close" test in `currentVersion` group.

2. **Line 147:** Change `throwsA(isA<DatabaseException>())` to `throwsA(isA<StateError>())` for the "operations throw after close" test.
  </action>
  <verify>
Build the C++ library first (required for Dart FFI): `cmake --build build --config Debug`
Then run Dart tests: `bindings/dart/test/test.bat`
Specifically verify:
- "rejects empty array" test passes with ArgumentError
- "throws after dispose" test passes with StateError
- "throws after close" tests pass with StateError
- All delete tests pass with `deleteElement` (not `deleteElementById`)
- All LuaRunner tests pass (syntax error, undefined variable, invalid collection)
  </verify>
  <done>
- `deleteElementById` renamed to `deleteElement` in source and all 5 test call sites
- database.dart fromSchema/fromMigrations use check() instead of manual error handling
- database.dart _ensureNotClosed throws StateError
- element.dart _ensureNotDisposed throws StateError
- element.dart set() empty list/unsupported type throw ArgumentError
- element.dart _setMixedList unsupported type throws ArgumentError
- lua_runner.dart constructor uses check() pattern
- lua_runner.dart _ensureNotDisposed throws StateError
- lua_runner.dart run() surfaces error without 'Lua error: ' prefix
- All test assertions updated to match new exception types
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix defensive else branches in database_read.dart</name>
  <files>
    bindings/dart/lib/src/database_read.dart
  </files>
  <action>
**Fix 2 defensive else branches (ERRH-04):**

1. **Line 816 in readVectorGroupById:** Change `throw Exception('Unknown data type: ${col.dataType}')` to `throw ArgumentError('Unknown data type: ${col.dataType}')`.

2. **Line 866 in readSetGroupById:** Change `throw Exception('Unknown data type: ${col.dataType}')` to `throw ArgumentError('Unknown data type: ${col.dataType}')`.

These are exhaustive type dispatch branches that should never be reached in normal operation. Changing from bare `Exception` to `ArgumentError` is consistent with how the codebase already handles type dispatch errors (e.g., `_marshalParams` in database.dart line 218, `updateTimeSeriesGroup` in database_update.dart lines 304/307).

**No test file changes needed** -- no existing tests assert on these specific defensive branches.
  </action>
  <verify>
Run Dart tests: `bindings/dart/test/test.bat`
Specifically verify:
- database_read tests pass (exercises readVectorGroupById, readSetGroupById)
- No regressions in other test files
  </verify>
  <done>
- database_read.dart has zero bare `Exception` throws
- Both defensive branches use `ArgumentError` consistent with codebase convention
- All Dart tests pass
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `bindings/dart/test/test.bat` passes (all Dart tests green)
2. Grep for `DatabaseException(` in `bindings/dart/lib/src/` -- should only appear in `exceptions.dart` (the check() function and class definition)
3. Grep for `throw Exception(` in `bindings/dart/lib/src/` -- should return zero hits
4. `deleteElementById` appears nowhere in any Dart source or test file
5. All state guards (`_ensureNotClosed`, `_ensureNotDisposed`) throw `StateError`
6. All type dispatch errors throw `ArgumentError`
</verification>

<success_criteria>
- NAME-04 satisfied: All Dart wrapper methods use camelCase and map predictably from C API names. The only rename needed (deleteElementById -> deleteElement) is complete.
- ERRH-04 satisfied: Zero custom DatabaseException error messages in Dart wrapper code. All database errors surface from C API via check(). Dart-side state guards use StateError. Dart-side type dispatch errors use ArgumentError.
- All Dart tests pass without regressions.
</success_criteria>

<output>
After completion, create `.planning/phases/07-dart-bindings-standardization/07-01-SUMMARY.md`
</output>
