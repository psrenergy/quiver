# Phase 7: Dart Bindings Standardization - Research

**Researched:** 2026-02-10
**Domain:** Dart wrapper function naming conventions and error handling standardization
**Confidence:** HIGH

## Summary

Phase 7 standardizes the Dart bindings layer to ensure all wrapper methods use idiomatic Dart `camelCase` naming, map predictably from C API names, and surface C API error messages without crafting custom error strings in Dart code. The Dart bindings use a two-layer architecture: (1) the FFI layer (`bindings.dart`) auto-generated by `ffigen`, which mirrors C API function names exactly, and (2) the wrapper layer (`database.dart`, `database_*.dart`, `element.dart`, `lua_runner.dart`) which provides idiomatic Dart methods using extensions on the `Database` class.

The good news: the Dart wrapper naming is already ~98% correct. All methods already use `camelCase`, already strip the `quiver_database_` prefix from C API names, and already use Dart-idiomatic naming. The only naming issue is `deleteElementById` which should be `deleteElement` to match the C API rename from Phase 5 (C API is now `quiver_database_delete_element`, without `_by_id`). The error handling issue is more significant: there are **10 custom error message sites** across 4 files that violate ERRH-04 (error messages should come from the C API, not be crafted in bindings).

A critical finding is that `quiver_lua_runner_run` stores errors in `runner->last_error` (a per-runner field), NOT in the global `quiver_set_last_error()`. This means `check()` will NOT work for Lua script errors -- the Dart binding's current approach of calling `quiver_lua_runner_get_error` is architecturally necessary. The fix is to remove the custom error message prefixes ("Lua error: ", "Lua script execution failed") while keeping the `quiver_lua_runner_get_error` call path.

**Primary recommendation:** Rename `deleteElementById` to `deleteElement`, remove all custom `DatabaseException` strings crafted in Dart wrapper code (replace factory methods with `check()`, replace defensive else branches with `ArgumentError`), and standardize LuaRunner error handling to surface error messages without custom prefixes.

## Standard Stack

Not applicable -- this phase involves no new libraries, only refactoring existing Dart wrapper code. All tools are already in the project (Dart SDK ^3.10.0, ffigen ^11.0.0, ffi ^2.1.0).

## Architecture Patterns

### Dart Bindings Architecture

The Dart bindings use a two-layer architecture:

```
lib/
  quiver_db.dart              # Library entry point, exports
  src/
    ffi/
      bindings.dart           # Layer 1: FFI layer (auto-generated by ffigen)
      library_loader.dart     # Dynamic library loading
    database.dart             # Database class + lifecycle + helpers
    database_create.dart      # DatabaseCreate extension
    database_csv.dart         # DatabaseCSV extension
    database_delete.dart      # DatabaseDelete extension (NEEDS RENAME of method)
    database_metadata.dart    # DatabaseMetadata extension
    database_query.dart       # DatabaseQuery extension
    database_read.dart        # DatabaseRead extension
    database_relations.dart   # DatabaseRelations extension
    database_update.dart      # DatabaseUpdate extension
    element.dart              # Element class (builder for creation)
    lua_runner.dart            # LuaRunner class
    exceptions.dart           # check() function, DatabaseException, LuaException
    date_time.dart            # DateTime conversion helpers
```

**Layer 1 (FFI -- bindings.dart):** Auto-generated by `ffigen` (Dart's C FFI binding generator). Functions have exact C API names (e.g., `bindings.quiver_database_read_scalar_integers`). This layer is NOT touched by Phase 7.

**Layer 2 (Wrappers):** Hand-written Dart methods that call Layer 1 via the `bindings` global. These use `camelCase` naming, Dart types, and Arena-based memory management. The `check()` function in `exceptions.dart` converts C API error codes into Dart exceptions by calling `quiver_get_last_error()`.

### Current Dart Method Name Mapping

The naming convention converts C API `snake_case` to Dart `camelCase` and strips `quiver_database_` prefix:

| C API Name | Dart Wrapper Name | Convention | Status |
|------------|-------------------|------------|--------|
| `quiver_database_from_schema` | `Database.fromSchema` (factory) | camelCase factory | OK |
| `quiver_database_from_migrations` | `Database.fromMigrations` (factory) | camelCase factory | OK |
| `quiver_database_close` | `close` | strip prefix | OK |
| `quiver_database_describe` | `describe` | strip prefix | OK |
| `quiver_database_create_element` | `createElement` | camelCase | OK |
| `quiver_database_update_element` | `updateElement` / `updateElementFromBuilder` | camelCase | OK |
| `quiver_database_delete_element` | `deleteElementById` | **WRONG** -- still has `ById` from before Phase 5 | **RENAME** |
| `quiver_database_read_scalar_integers` | `readScalarIntegers` | camelCase | OK |
| `quiver_database_read_scalar_floats` | `readScalarFloats` | camelCase | OK |
| `quiver_database_read_scalar_strings` | `readScalarStrings` | camelCase | OK |
| `quiver_database_read_scalar_integer_by_id` | `readScalarIntegerById` | camelCase | OK |
| `quiver_database_read_scalar_float_by_id` | `readScalarFloatById` | camelCase | OK |
| `quiver_database_read_scalar_string_by_id` | `readScalarStringById` | camelCase | OK |
| `quiver_database_read_vector_integers` | `readVectorIntegers` | camelCase | OK |
| `quiver_database_read_vector_floats` | `readVectorFloats` | camelCase | OK |
| `quiver_database_read_vector_strings` | `readVectorStrings` | camelCase | OK |
| `quiver_database_read_vector_integers_by_id` | `readVectorIntegersById` | camelCase | OK |
| `quiver_database_read_vector_floats_by_id` | `readVectorFloatsById` | camelCase | OK |
| `quiver_database_read_vector_strings_by_id` | `readVectorStringsById` | camelCase | OK |
| `quiver_database_read_set_integers` | `readSetIntegers` | camelCase | OK |
| `quiver_database_read_set_floats` | `readSetFloats` | camelCase | OK |
| `quiver_database_read_set_strings` | `readSetStrings` | camelCase | OK |
| `quiver_database_read_set_integers_by_id` | `readSetIntegersById` | camelCase | OK |
| `quiver_database_read_set_floats_by_id` | `readSetFloatsById` | camelCase | OK |
| `quiver_database_read_set_strings_by_id` | `readSetStringsById` | camelCase | OK |
| `quiver_database_read_element_ids` | `readElementIds` | camelCase | OK |
| `quiver_database_update_scalar_relation` | `updateScalarRelation` | camelCase | OK |
| `quiver_database_read_scalar_relation` | `readScalarRelation` | camelCase | OK |
| `quiver_database_update_scalar_integer` | `updateScalarInteger` | camelCase | OK |
| `quiver_database_update_scalar_float` | `updateScalarFloat` | camelCase | OK |
| `quiver_database_update_scalar_string` | `updateScalarString` | camelCase | OK |
| `quiver_database_update_vector_integers` | `updateVectorIntegers` | camelCase | OK |
| `quiver_database_update_vector_floats` | `updateVectorFloats` | camelCase | OK |
| `quiver_database_update_vector_strings` | `updateVectorStrings` | camelCase | OK |
| `quiver_database_update_set_integers` | `updateSetIntegers` | camelCase | OK |
| `quiver_database_update_set_floats` | `updateSetFloats` | camelCase | OK |
| `quiver_database_update_set_strings` | `updateSetStrings` | camelCase | OK |
| `quiver_database_read_time_series_group` | `readTimeSeriesGroup` | camelCase | OK |
| `quiver_database_update_time_series_group` | `updateTimeSeriesGroup` | camelCase | OK |
| `quiver_database_has_time_series_files` | `hasTimeSeriesFiles` | camelCase | OK |
| `quiver_database_list_time_series_files_columns` | `listTimeSeriesFilesColumns` | camelCase | OK |
| `quiver_database_read_time_series_files` | `readTimeSeriesFiles` | camelCase | OK |
| `quiver_database_update_time_series_files` | `updateTimeSeriesFiles` | camelCase | OK |
| `quiver_database_get_scalar_metadata` | `getScalarMetadata` | camelCase | OK |
| `quiver_database_get_vector_metadata` | `getVectorMetadata` | camelCase | OK |
| `quiver_database_get_set_metadata` | `getSetMetadata` | camelCase | OK |
| `quiver_database_get_time_series_metadata` | `getTimeSeriesMetadata` | camelCase | OK |
| `quiver_database_list_scalar_attributes` | `listScalarAttributes` | camelCase | OK |
| `quiver_database_list_vector_groups` | `listVectorGroups` | camelCase | OK |
| `quiver_database_list_set_groups` | `listSetGroups` | camelCase | OK |
| `quiver_database_list_time_series_groups` | `listTimeSeriesGroups` | camelCase | OK |
| `quiver_database_current_version` | `currentVersion` | camelCase | OK |
| `quiver_database_export_csv` | `exportCSV` | camelCase | OK |
| `quiver_database_import_csv` | `importCSV` | camelCase | OK |
| `quiver_database_query_string` | `queryString` | camelCase | OK |
| `quiver_database_query_integer` | `queryInteger` | camelCase | OK |
| `quiver_database_query_float` | `queryFloat` | camelCase | OK |
| `quiver_database_query_string_params` | `queryStringParams` | camelCase | OK |
| `quiver_database_query_integer_params` | `queryIntegerParams` | camelCase | OK |
| `quiver_database_query_float_params` | `queryFloatParams` | camelCase | OK |

**Additional Dart-only methods (no direct C API mapping):**

| Dart Method | Purpose | Status |
|-------------|---------|--------|
| `readScalarDateTimeById` | Reads string, converts to DateTime | OK -- convenience wrapper |
| `readVectorDateTimesById` | Reads string vector, converts to DateTimes | OK |
| `readSetDateTimesById` | Reads string set, converts to DateTimes | OK |
| `readAllScalarsById` | Composite: reads all scalar attributes for one element | OK |
| `readAllVectorsById` | Composite: reads all vector groups for one element | OK |
| `readAllSetsById` | Composite: reads all set groups for one element | OK |
| `readVectorGroupById` | Composite: reads all columns in a vector group for one element | OK |
| `readSetGroupById` | Composite: reads all columns in a set group for one element | OK |
| `queryDateTime` | Reads string query result, converts to DateTime | OK |
| `queryDateTimeParams` | Reads parameterized string query result, converts to DateTime | OK |
| `createElement` (Map overload) | Convenience: creates element from Map instead of Element builder | OK |
| `createElementFromBuilder` | Creates element from Element builder | OK |
| `updateElement` (Map overload) | Convenience: updates from Map | OK |
| `updateElementFromBuilder` | Updates from Element builder | OK |

### Naming Issue: Only 1 Method Needs Renaming

| Current Name | C API Name | Expected Dart Name | Issue |
|-------------|------------|--------------------|----|
| `deleteElementById` | `quiver_database_delete_element` | `deleteElement` | Phase 5 renamed C API from `_by_id`; Dart wrapper still has old name |

### Dart Naming Convention (Codified from existing practice)

The Dart wrapper naming convention is:

1. **Strip `quiver_database_` prefix** from C API function names
2. **Convert `snake_case` to `camelCase`** (Dart standard)
3. **`ById` suffix preserved** only where the C API has `_by_id` (read operations with both "all" and "single" variants)
4. **Types use `PascalCase`** (Dart standard): `Database`, `Element`, `LuaRunner`, `DatabaseException`
5. **Factory constructors** use named constructors: `Database.fromSchema`, `Database.fromMigrations`
6. **Extensions** organize methods by category: `DatabaseRead`, `DatabaseCreate`, etc.
7. **Private methods** use `_` prefix: `_ensureNotClosed`, `_parseScalarMetadata`, `_marshalParams`

### Error Handling Audit: Custom Error Messages in Dart

**ERRH-04 Requirement:** Dart bindings surface C API errors uniformly -- no custom error messages defined in Dart code.

**Current error handling pattern (correct):**
```dart
// exceptions.dart -- the check() function retrieves C API errors
void check(int err) {
  if (err != 0) {
    final detail = bindings.quiver_get_last_error().cast<Utf8>().toDartString();
    if (detail.isEmpty) {
      print('WARNING check: C API returned error but quiver_get_last_error() is empty');
      throw const DatabaseException('Unknown error');
    }
    throw DatabaseException(detail);
  }
}
```

This is correct -- it retrieves the error message from C API and surfaces it. The `'Unknown error'` fallback is acceptable as a safety net.

**Custom error messages that VIOLATE ERRH-04:**

| File | Line | Custom Message | Category |
|------|------|---------------|----------|
| `database.dart:51-53` | `throw DatabaseException(errorMsg.isNotEmpty ? errorMsg : 'Failed to create database from schema')` | Fallback in `fromSchema` factory | Bypasses `check()` |
| `database.dart:82-84` | `throw DatabaseException(errorMsg.isNotEmpty ? errorMsg : 'Failed to create database from migrations')` | Fallback in `fromMigrations` factory | Bypasses `check()` |
| `database.dart:95` | `throw const DatabaseException('Database has been closed')` | State guard | Dart-side state management |
| `element.dart:40` | `throw const DatabaseException('Element has been disposed')` | State guard | Dart-side state management |
| `element.dart:84` | `throw DatabaseException("Empty list not allowed for '$name'")` | Input validation | Should come from C API |
| `element.dart:88-90` | `throw DatabaseException("Unsupported type ${value.runtimeType} for '$name'")` | Type dispatch failure | Dart-side type dispatch |
| `element.dart:103-105` | `throw DatabaseException("Unsupported array element type ${first.runtimeType} for '$name'")` | Type dispatch failure in mixed list | Dart-side type dispatch |
| `lua_runner.dart:38-40` | `throw DatabaseException(errorMsg.isNotEmpty ? errorMsg : 'Failed to create LuaRunner')` | Fallback in constructor | Bypasses `check()` |
| `lua_runner.dart:50` | `throw const DatabaseException('LuaRunner has been disposed')` | State guard | Dart-side state management |
| `lua_runner.dart:77` | `throw LuaException('Lua error: $errorMsg')` | Wraps Lua error with custom prefix | Should just surface the error |
| `lua_runner.dart:79` | `throw const LuaException('Lua script execution failed')` | Crafted fallback | Should surface C API/Lua error |
| `database_read.dart:816` | `throw Exception('Unknown data type: ${col.dataType}')` | Defensive else branch in `readVectorGroupById` | Should be `ArgumentError` |
| `database_read.dart:866` | `throw Exception('Unknown data type: ${col.dataType}')` | Defensive else branch in `readSetGroupById` | Should be `ArgumentError` |

**Total: 13 custom error message sites across 4 files.**

### Error Message Categories and Remediation

**Category 1: Factory methods bypassing `check()` (database.dart lines 51, 82; lua_runner.dart line 38)**

The `fromSchema`, `fromMigrations`, and `LuaRunner` constructors manually call the C API and check the return code instead of using `check()`. They have fallback messages like `'Failed to create database from schema'` when `quiver_get_last_error()` returns empty.

**Remediation:** Replace manual error handling with `check()`. The C API functions (`quiver_database_from_schema`, `quiver_database_from_migrations`, `quiver_lua_runner_new`) all call `quiver_set_last_error(e.what())` on failure, so `check()` will retrieve the correct message. The fallback strings are redundant.

**Category 2: Dart-side state guards (database.dart line 95; element.dart line 40; lua_runner.dart line 50)**

The `_ensureNotClosed()` and `_ensureNotDisposed()` methods throw `DatabaseException('Database has been closed')` and `DatabaseException('Element has been disposed')` / `DatabaseException('LuaRunner has been disposed')`. These are Dart-side state management checks that prevent calling the C API on freed resources.

**Remediation:** These are a judgment call. The C API has `QUIVER_REQUIRE(db)` which checks for null pointers, but in Dart the pointer may not be null -- it may be a dangling pointer after close/dispose. The Dart-side check prevents use-after-free. Options:
- **Option A (recommended):** Keep these as `StateError` (Dart standard for "object used after disposal") instead of `DatabaseException`. This correctly distinguishes programming errors from database errors.
- **Option B:** Keep as `DatabaseException` but accept they are a necessary exception to ERRH-04 since they protect against use-after-free at the binding level.

**Category 3: Input validation in Element (element.dart lines 84, 88-90, 103-105)**

The `set()` method and `_setMixedList()` throw `DatabaseException` for: empty lists, unsupported value types, and unsupported array element types. These are Dart-side type dispatch decisions.

**Remediation:**
- **Empty list check (line 84):** The C API `quiver_element_set_array_*` would handle empty arrays -- this should be tested. If C++ rejects empty arrays with a proper error, remove the Dart check and let it flow through. If C++ silently accepts them, keep the check but change to `ArgumentError`.
- **Unsupported type (lines 88-90, 103-105):** These are genuine Dart-side type dispatch failures -- the code cannot determine which C function to call. Change from `DatabaseException` to `ArgumentError` to distinguish from database errors. `ArgumentError` is already used elsewhere in the codebase (`_marshalParams` in database.dart:218, `updateTimeSeriesGroup` in database_update.dart:304,307).

**Category 4: LuaRunner error wrapping (lua_runner.dart lines 77, 79)**

The `run()` method handles errors by calling `quiver_lua_runner_get_error` and wrapping the message with `'Lua error: $errorMsg'` prefix, or throwing `'Lua script execution failed'` as fallback.

**CRITICAL FINDING:** `quiver_lua_runner_run` stores errors in `runner->last_error` (a per-runner field in the C struct), NOT in the global `quiver_set_last_error()`. This means `check()` will NOT work for Lua script errors -- `quiver_get_last_error()` will return empty. The call to `quiver_lua_runner_get_error` is architecturally necessary and MUST be kept.

**Remediation:** Keep the `quiver_lua_runner_get_error` call path but:
1. Remove the `'Lua error: '` prefix -- just surface the error message directly as `LuaException(errorMsg)`
2. For the fallback when `quiver_lua_runner_get_error` fails, use `check()` since the `QUIVER_REQUIRE` in the C API _does_ store errors in `quiver_set_last_error` for precondition failures

**Category 5: Defensive else branches in composite functions (database_read.dart lines 816, 866)**

The `readVectorGroupById` and `readSetGroupById` methods have `default: throw Exception('Unknown data type: ...')` branches.

**Remediation:** Change from bare `Exception` to `ArgumentError`. These are exhaustive type dispatch branches that should never be reached. Note: `readAllScalarsById`, `readAllVectorsById`, and `readAllSetsById` use exhaustive `switch` without a `default` branch -- Dart's exhaustive switch on `int` values handles the 4 known cases (INTEGER, FLOAT, STRING, DATE_TIME) without needing a default. The `readVectorGroupById` and `readSetGroupById` methods should follow the same pattern if possible, or keep the default as `ArgumentError`.

### Complete Remediation Plan

| File | Line(s) | Current | Proposed | Impact |
|------|---------|---------|----------|--------|
| `database_delete.dart:7` | `deleteElementById` | Rename to `deleteElement` | Function name + all test call sites |
| `database.dart:41-59` | `fromSchema` manual error handling | Use `check()` pattern | Remove `'Failed to create database from schema'` fallback |
| `database.dart:65-91` | `fromMigrations` manual error handling | Use `check()` pattern | Remove `'Failed to create database from migrations'` fallback |
| `database.dart:93-97` | `_ensureNotClosed` throws `DatabaseException` | Change to `StateError('Database has been closed')` | Exception type change |
| `element.dart:38-42` | `_ensureNotDisposed` throws `DatabaseException` | Change to `StateError('Element has been disposed')` | Exception type change |
| `element.dart:84` | `throw DatabaseException("Empty list not allowed...")` | Change to `throw ArgumentError("Empty list not allowed for '$name'")` | Exception type change |
| `element.dart:88-90` | `throw DatabaseException("Unsupported type...")` | Change to `throw ArgumentError(...)` | Exception type change |
| `element.dart:103-105` | `throw DatabaseException("Unsupported array element type...")` | Change to `throw ArgumentError(...)` | Exception type change |
| `lua_runner.dart:30-46` | LuaRunner constructor manual error handling | Use `check()` pattern | Remove `'Failed to create LuaRunner'` fallback |
| `lua_runner.dart:48-52` | `_ensureNotDisposed` throws `DatabaseException` | Change to `StateError('LuaRunner has been disposed')` | Exception type change |
| `lua_runner.dart:62-84` | `run()` with custom error wrapping | Keep `quiver_lua_runner_get_error` but throw `LuaException(errorMsg)` without prefix | Remove `'Lua error: '` prefix and `'Lua script execution failed'` |
| `database_read.dart:816` | `throw Exception('Unknown data type...')` | Change to `throw ArgumentError(...)` | Exception type change |
| `database_read.dart:866` | `throw Exception('Unknown data type...')` | Change to `throw ArgumentError(...)` | Exception type change |

### Files Affected (Complete List)

**Source files to modify:**
- `bindings/dart/lib/src/database_delete.dart` -- rename method
- `bindings/dart/lib/src/database.dart` -- fix factory error handling, change `_ensureNotClosed` exception type
- `bindings/dart/lib/src/element.dart` -- fix error handling, change `_ensureNotDisposed` exception type
- `bindings/dart/lib/src/lua_runner.dart` -- standardize error handling, change `_ensureNotDisposed` exception type
- `bindings/dart/lib/src/database_read.dart` -- fix defensive branch exception types

**Test files to update (for `deleteElementById` -> `deleteElement` rename):**
- `bindings/dart/test/database_delete_test.dart` -- 5 call sites of `deleteElementById`

**Test files to verify (exception type changes may affect assertions):**
- `bindings/dart/test/element_test.dart` -- tests `throwsA(isA<DatabaseException>())` for empty array (line 93) and disposed element (line 187). The empty array test will need `isA<ArgumentError>()`. The disposed test will need `isA<StateError>()`.
- `bindings/dart/test/lua_runner_test.dart` -- tests `throwsA(isA<LuaException>())` for syntax errors. These should still pass since `LuaException` is still thrown.
- `bindings/dart/test/database_lifecycle_test.dart` -- tests `throwsA(isA<DatabaseException>())` for closed database operations. These will need to be checked -- some may need `isA<StateError>()` if they test the "Database has been closed" path, but others that test C API errors (like bad schema path) should remain `isA<DatabaseException>()`.

**Tests that check specific error messages:**
- `bindings/dart/test/issues_test.dart:17-21` -- checks `e.message` `contains('label')`. This tests a `DatabaseException` from `fromMigrations`. Since the error comes from the C API, it will still contain 'label'. No change needed.

**Files NOT touched:**
- `bindings/dart/lib/src/ffi/bindings.dart` -- auto-generated, already correct from Phase 5
- `bindings/dart/lib/src/ffi/library_loader.dart` -- no changes needed
- `bindings/dart/lib/src/exceptions.dart` -- `check()` function is correct, `DatabaseException`/`LuaException` types are correct
- `bindings/dart/lib/src/date_time.dart` -- no changes needed
- `bindings/dart/lib/src/database_create.dart` -- all names correct, uses `check()` correctly
- `bindings/dart/lib/src/database_csv.dart` -- all names correct, uses `check()` correctly
- `bindings/dart/lib/src/database_metadata.dart` -- all names correct, uses `check()` correctly
- `bindings/dart/lib/src/database_query.dart` -- all names correct, uses `check()` correctly
- `bindings/dart/lib/src/database_relations.dart` -- all names correct, uses `check()` correctly
- `bindings/dart/lib/src/database_update.dart` -- all names correct, uses `check()` correctly (already uses `ArgumentError` appropriately)
- `bindings/dart/lib/quiver_db.dart` -- export file, no changes needed

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| C API error retrieval | Custom error checking per function | `check()` from `exceptions.dart` | Single centralized error path; guaranteed to surface C API errors |
| Lua error retrieval | Generic `check()` for Lua errors | `quiver_lua_runner_get_error` C API call | Lua errors are stored per-runner, not in global `quiver_set_last_error` |
| FFI binding names | Manual edits to bindings.dart | Re-run `ffigen` generator if C API changes | bindings.dart is auto-generated |
| State management errors | `DatabaseException` for disposed/closed state | `StateError` (Dart built-in) | Distinguishes programming errors from database errors |

**Key insight:** The `check()` function is the correct and only mechanism for converting C API errors to Dart exceptions -- except for LuaRunner errors which require the `quiver_lua_runner_get_error` call path. Any code path that bypasses `check()` and crafts its own error messages violates ERRH-04 (with the LuaRunner being the one justified exception, but even there the error message should be surfaced without custom prefixes).

## Common Pitfalls

### Pitfall 1: LuaRunner Errors Cannot Use `check()`
**What goes wrong:** Switching `LuaRunner.run()` to use `check()` causes Lua script errors to throw with "Unknown error" instead of the actual Lua error message.
**Why it happens:** `quiver_lua_runner_run` stores the error in `runner->last_error` (per-runner field), NOT in the global `quiver_set_last_error()`. The `check()` function reads the global error, which is empty for Lua errors.
**How to avoid:** Keep the `quiver_lua_runner_get_error` call path in `LuaRunner.run()`. Only use `check()` for the LuaRunner constructor (which does use `quiver_set_last_error`).
**Warning signs:** Lua error tests pass but with "Unknown error" instead of the actual Lua error message.

### Pitfall 2: StateError vs DatabaseException in Tests
**What goes wrong:** Tests that assert `throwsA(isA<DatabaseException>())` for closed/disposed state guards start failing when those guards switch to `StateError`.
**Why it happens:** Changing from `DatabaseException` to `StateError` is a type-level change. `isA<DatabaseException>()` won't match `StateError`.
**How to avoid:** Audit all tests that trigger the "has been closed" / "has been disposed" path. Update assertions from `isA<DatabaseException>()` to `isA<StateError>()`.
**Warning signs:** Test failures at the `expect` line for state guard assertions.

### Pitfall 3: Empty List Test Assertion Change
**What goes wrong:** `element_test.dart` line 93 asserts `throwsA(isA<DatabaseException>())` for `element.set('values', [])`. If changed to `ArgumentError`, this test must update.
**Why it happens:** Changing the exception type for empty list validation.
**How to avoid:** Update the test assertion to `throwsA(isA<ArgumentError>())`.
**Warning signs:** Element test "rejects empty array" fails with wrong exception type.

### Pitfall 4: Factory Constructor Error Handling Timing
**What goes wrong:** In `Database.fromSchema` and `Database.fromMigrations`, if `check()` throws before the `Database._` constructor is called, the Arena is still cleaned up correctly (due to `finally`). However, if the C API partially succeeds and allocates a database handle before failing, the handle may leak.
**Why it happens:** `check()` throws immediately, and the `outDbPtr.value` may contain a partially-initialized database handle.
**How to avoid:** In factory constructors, call `check()` and then immediately read `outDbPtr.value`. If `check()` throws, the C API should not have set `outDbPtr.value` to a valid handle (the C API contract: out-parameter is only set on QUIVER_OK). Verify this assumption.
**Warning signs:** Memory leaks in error paths (hard to detect, unlikely in practice).

### Pitfall 5: LuaException Subclass of DatabaseException
**What goes wrong:** `LuaException extends DatabaseException`. Tests asserting `isA<DatabaseException>()` will match `LuaException` instances. Tests asserting `isA<LuaException>()` specifically should continue to work.
**Why it happens:** Dart class hierarchy -- `LuaException` IS-A `DatabaseException`.
**How to avoid:** This is actually fine. The existing tests use `isA<LuaException>()` for Lua-specific error tests. No changes needed to test assertions for Lua errors.
**Warning signs:** None -- the hierarchy is correct.

## Code Examples

### Naming Rename Pattern (Only 1 method)

```dart
// BEFORE (database_delete.dart):
void deleteElementById(String collection, int id) {
  _ensureNotClosed();
  final arena = Arena();
  try {
    check(bindings.quiver_database_delete_element(_ptr, collection.toNativeUtf8(allocator: arena).cast(), id));
  } finally {
    arena.releaseAll();
  }
}

// AFTER (database_delete.dart):
void deleteElement(String collection, int id) {
  _ensureNotClosed();
  final arena = Arena();
  try {
    check(bindings.quiver_database_delete_element(_ptr, collection.toNativeUtf8(allocator: arena).cast(), id));
  } finally {
    arena.releaseAll();
  }
}
```

### Error Handling Fix: Factory Constructor

```dart
// BEFORE (database.dart):
factory Database.fromSchema(String dbPath, String schemaPath) {
  final arena = Arena();
  try {
    final optionsPtr = arena<quiver_database_options_t>();
    optionsPtr.ref = bindings.quiver_database_options_default();
    final outDbPtr = arena<Pointer<quiver_database_t>>();

    final err = bindings.quiver_database_from_schema(
      dbPath.toNativeUtf8(allocator: arena).cast(),
      schemaPath.toNativeUtf8(allocator: arena).cast(),
      optionsPtr,
      outDbPtr,
    );

    if (err != quiver_error_t.QUIVER_OK) {
      final errorPtr = bindings.quiver_get_last_error();
      final errorMsg = errorPtr.cast<Utf8>().toDartString();
      throw DatabaseException(
        errorMsg.isNotEmpty ? errorMsg : 'Failed to create database from schema',
      );
    }

    return Database._(outDbPtr.value);
  } finally {
    arena.releaseAll();
  }
}

// AFTER (database.dart):
factory Database.fromSchema(String dbPath, String schemaPath) {
  final arena = Arena();
  try {
    final optionsPtr = arena<quiver_database_options_t>();
    optionsPtr.ref = bindings.quiver_database_options_default();
    final outDbPtr = arena<Pointer<quiver_database_t>>();

    check(bindings.quiver_database_from_schema(
      dbPath.toNativeUtf8(allocator: arena).cast(),
      schemaPath.toNativeUtf8(allocator: arena).cast(),
      optionsPtr,
      outDbPtr,
    ));

    return Database._(outDbPtr.value);
  } finally {
    arena.releaseAll();
  }
}
```

### Error Handling Fix: State Guards

```dart
// BEFORE:
void _ensureNotClosed() {
  if (_isClosed) {
    throw const DatabaseException('Database has been closed');
  }
}

// AFTER:
void _ensureNotClosed() {
  if (_isClosed) {
    throw StateError('Database has been closed');
  }
}
```

### Error Handling Fix: LuaRunner Constructor

```dart
// BEFORE (lua_runner.dart):
LuaRunner(Database db) : _ptr = nullptr {
  final arena = Arena();
  try {
    final outRunnerPtr = arena<Pointer<quiver_lua_runner_t>>();
    final err = bindings.quiver_lua_runner_new(db.ptr, outRunnerPtr);
    if (err != quiver_error_t.QUIVER_OK) {
      final errorPtr = bindings.quiver_get_last_error();
      final errorMsg = errorPtr.cast<Utf8>().toDartString();
      throw DatabaseException(
        errorMsg.isNotEmpty ? errorMsg : 'Failed to create LuaRunner',
      );
    }
    _ptr = outRunnerPtr.value;
  } finally {
    arena.releaseAll();
  }
}

// AFTER (lua_runner.dart):
LuaRunner(Database db) : _ptr = nullptr {
  final arena = Arena();
  try {
    final outRunnerPtr = arena<Pointer<quiver_lua_runner_t>>();
    check(bindings.quiver_lua_runner_new(db.ptr, outRunnerPtr));
    _ptr = outRunnerPtr.value;
  } finally {
    arena.releaseAll();
  }
}
```

### Error Handling Fix: LuaRunner run()

```dart
// BEFORE (lua_runner.dart):
void run(String script) {
  _ensureNotDisposed();
  final arena = Arena();
  try {
    final err = bindings.quiver_lua_runner_run(_ptr, script.toNativeUtf8(allocator: arena).cast());
    if (err != quiver_error_t.QUIVER_OK) {
      final outErrorPtr = arena<Pointer<Char>>();
      final getErr = bindings.quiver_lua_runner_get_error(_ptr, outErrorPtr);
      if (getErr == quiver_error_t.QUIVER_OK && outErrorPtr.value != nullptr) {
        final errorMsg = outErrorPtr.value.cast<Utf8>().toDartString();
        throw LuaException('Lua error: $errorMsg');
      } else {
        throw const LuaException('Lua script execution failed');
      }
    }
  } finally {
    arena.releaseAll();
  }
}

// AFTER (lua_runner.dart):
void run(String script) {
  _ensureNotDisposed();
  final arena = Arena();
  try {
    final err = bindings.quiver_lua_runner_run(_ptr, script.toNativeUtf8(allocator: arena).cast());
    if (err != quiver_error_t.QUIVER_OK) {
      final outErrorPtr = arena<Pointer<Char>>();
      final getErr = bindings.quiver_lua_runner_get_error(_ptr, outErrorPtr);
      if (getErr == quiver_error_t.QUIVER_OK && outErrorPtr.value != nullptr) {
        final errorMsg = outErrorPtr.value.cast<Utf8>().toDartString();
        throw LuaException(errorMsg);
      } else {
        // Fallback: try global error (for QUIVER_REQUIRE failures)
        check(err);
      }
    }
  } finally {
    arena.releaseAll();
  }
}
```

### Error Handling Fix: Element Type Dispatch

```dart
// BEFORE (element.dart):
case List v when v.isEmpty:
  throw DatabaseException("Empty list not allowed for '$name'");
case List v:
  _setMixedList(name, v);
default:
  throw DatabaseException("Unsupported type ${value.runtimeType} for '$name'");

// AFTER (element.dart):
case List v when v.isEmpty:
  throw ArgumentError("Empty list not allowed for '$name'");
case List v:
  _setMixedList(name, v);
default:
  throw ArgumentError("Unsupported type ${value.runtimeType} for '$name'");
```

### Error Handling Fix: Defensive Else Branch

```dart
// BEFORE (database_read.dart):
default:
  throw Exception('Unknown data type: ${col.dataType}');

// AFTER (database_read.dart):
default:
  throw ArgumentError('Unknown data type: ${col.dataType}');
```

## State of the Art

Not applicable -- this is internal refactoring of binding wrapper code, not adoption of external technology.

## Open Questions

### 1. Should state guards (`_ensureNotClosed`, `_ensureNotDisposed`) change exception type?

**What we know:** Currently they throw `DatabaseException`. Dart convention uses `StateError` for "object used after disposal" (similar to how `StreamController` throws `StateError` after close). The ERRH-04 requirement says "no custom error strings defined in Dart code" which these technically violate.

**What's unclear:** Whether changing from `DatabaseException` to `StateError` is desired, since it changes the public API contract.

**Recommendation:** Change to `StateError`. This is more idiomatic Dart, correctly distinguishes programming errors from database errors, and removes custom messages from `DatabaseException`. The test impact is manageable -- update `isA<DatabaseException>()` to `isA<StateError>()` in affected tests. Confidence: HIGH.

### 2. Should the empty list check in element.dart be removed or kept?

**What we know:** `element.dart` line 84 handles empty lists by throwing `DatabaseException("Empty list not allowed for '$name'")`. This prevents the call from reaching the C API.

**What's unclear:** Whether the C++ layer properly rejects empty arrays with a clear error message, or silently accepts them.

**Recommendation:** Change the exception type to `ArgumentError` regardless. Whether to also remove the check depends on C++ behavior -- test what happens when `quiver_element_set_array_integer` is called with count=0. If C++ throws a proper error, the Dart check is redundant. If C++ silently accepts, keep the Dart check as `ArgumentError`. Confidence: MEDIUM -- need to verify C++ behavior.

### 3. Should `LuaException` still wrap the error message, or just pass it through?

**What we know:** Currently `LuaException('Lua error: $errorMsg')` adds a "Lua error: " prefix. After the fix, it would be `LuaException(errorMsg)` -- just the raw error message. The `LuaException` type itself already indicates it's a Lua error. Tests use `isA<LuaException>()` without checking message content.

**Recommendation:** Remove the prefix. The `LuaException` type conveys that it's a Lua error; the prefix is redundant and violates ERRH-04. Confidence: HIGH.

## Sources

### Primary (HIGH confidence)
- Direct source code analysis of all `bindings/dart/lib/src/*.dart` files -- complete method inventory, error message catalog
- Direct source code analysis of all `bindings/dart/test/*.dart` files -- test call sites, error assertions
- Direct source code analysis of `bindings/dart/lib/src/ffi/bindings.dart` -- FFI layer function names (post-Phase 5)
- Direct source code analysis of `src/c/lua_runner.cpp` -- verified that `quiver_lua_runner_run` stores errors in `runner->last_error`, NOT `quiver_set_last_error`
- Phase 6 Research (`06-RESEARCH.md`) -- Julia bindings standardization patterns (parallel structure)
- Phase 5 Research (`05-RESEARCH.md`) -- C API naming decisions, cascade analysis
- CLAUDE.md -- project principles ("Error Messages: All error messages are defined in the C++/C API layer. Bindings retrieve and surface them -- they never craft their own.")

### Secondary (MEDIUM confidence)
- Dart language conventions -- `camelCase` for methods, `PascalCase` for types, `StateError` for invalid state
- `bindings/dart/pubspec.yaml` -- Dart SDK ^3.10.0, ffigen ^11.0.0, dependencies

## Metadata

**Confidence breakdown:**
- Naming audit: HIGH -- every Dart wrapper method cataloged, only 1 rename needed
- Error handling audit: HIGH -- every custom error message site found via grep, all 13 categorized
- C API mapping: HIGH -- every wrapper method mapped to its C API counterpart, verified from bindings.dart
- LuaRunner error path: HIGH -- verified in C source code that `quiver_lua_runner_run` uses `runner->last_error` not `quiver_set_last_error`
- Remediation plan: HIGH -- all changes are straightforward, exception types well understood

**Research date:** 2026-02-10
**Valid until:** 2026-03-10 (stable -- internal refactoring, no external dependencies)
