---
phase: 07-dart-fk-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [bindings/dart/test/database_update_test.dart]
autonomous: true
requirements: [DART-02]
must_haves:
  truths:
    - "Dart updateElement resolves scalar FK string labels to integer IDs"
    - "Dart updateElement resolves vector FK string labels to integer IDs"
    - "Dart updateElement resolves set FK string labels to integer IDs"
    - "Dart updateElement resolves time series FK string labels to integer IDs"
    - "Dart updateElement resolves all FK types in a single call"
    - "Dart updateElement passes non-FK integer values through unchanged"
    - "Dart updateElement failure preserves the element's existing data"
  artifacts:
    - path: "bindings/dart/test/database_update_test.dart"
      provides: "7 Dart FK update tests appended at end of file"
      contains: "FK Resolution - Update"
  key_links:
    - from: "bindings/dart/test/database_update_test.dart"
      to: "db.updateElement"
      via: "Dart Map API with string labels for FK columns triggering C API FK resolution"
      pattern: "updateElement.*Child.*parent_id"
---

<objective>
Add 7 FK resolution tests to the Dart update test file, mirroring all C++ update-path FK tests.

Purpose: Verify that FK label-to-ID resolution works correctly through Dart's updateElement for all column types (scalar, vector, set, time series), combined operations, no-FK regression, and transactional safety (failure preserves existing data).

Output: 7 new tests inside a `group('FK Resolution - Update', ...)` block appended at the end of the `main()` function in database_update_test.dart
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bindings/dart/test/database_update_test.dart
@bindings/dart/lib/src/element.dart
@bindings/dart/lib/src/database_update.dart
@bindings/dart/lib/src/database_read.dart
@bindings/dart/lib/src/exceptions.dart
@tests/schemas/valid/relations.sql
@tests/schemas/valid/basic.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 7 FK resolution update tests to Dart test file</name>
  <files>bindings/dart/test/database_update_test.dart</files>
  <action>
Append a new `group('FK Resolution - Update', () { ... });` block at the end of `main()`, just before the closing `}` of the main function. Each test follows the existing Dart test pattern: `Database.fromSchema(':memory:', schemaPath)` with `try/finally` and `db.close()`.

Use `final testsPath` already declared at the top of `main()` for path construction. The relations.sql path is `path.join(testsPath, 'schemas', 'valid', 'relations.sql')`.

**Setup pattern for FK update tests (tests 1-5, 7):**
Each test needs: (a) create Configuration (required by schema), (b) create 2 Parents, (c) create child with initial FK pointing to Parent 1 via string label, (d) update child to point to Parent 2 via string label using `db.updateElement('Child', 1, {...})`, (e) read back and verify resolved IDs.

**The 7 tests to add (mirroring C++ test names, adapted to Dart conventions):**

1. **`test('resolves scalar FK labels to IDs', ...)`** -- Create Configuration, Parents "Parent 1", "Parent 2". Create child with `'parent_id': 'Parent 1'`. Update child: `db.updateElement('Child', 1, {'parent_id': 'Parent 2'})`. Verify via `db.readScalarIntegers('Child', 'parent_id')` that value is `[2]`. Close db.

2. **`test('resolves vector FK labels to IDs', ...)`** -- Create Configuration, Parents. Create child with `'parent_ref': ['Parent 1']`. Update child: `db.updateElement('Child', 1, {'parent_ref': ['Parent 2', 'Parent 1']})`. Verify via `db.readVectorIntegersById('Child', 'parent_ref', 1)` that values are `[2, 1]` (order preserved). Close db.

3. **`test('resolves set FK labels to IDs', ...)`** -- Create Configuration, Parents. Create child with `'mentor_id': ['Parent 1']`. Update child: `db.updateElement('Child', 1, {'mentor_id': ['Parent 2']})`. Verify via `db.readSetIntegersById('Child', 'mentor_id', 1)` that value is `[2]`. Close db.

4. **`test('resolves time series FK labels to IDs', ...)`** -- Create Configuration, Parents. Create child with `'date_time': ['2024-01-01']`, `'sponsor_id': ['Parent 1']`. Update child: `db.updateElement('Child', 1, {'date_time': ['2024-06-01', '2024-06-02'], 'sponsor_id': ['Parent 2', 'Parent 1']})`. Verify via `db.readTimeSeriesGroup('Child', 'events', 1)` that `result['sponsor_id']` is `[2, 1]` and `result['date_time']` has length 2. Close db.

    NOTE: The time series group name is `'events'` (from `Child_time_series_events`). The `readTimeSeriesGroup` returns `Map<String, List<Object>>` where INTEGER columns are `List<int>` and the dimension column `date_time` is parsed to `DateTime` objects.

5. **`test('resolves all FK types in one call', ...)`** -- Create Configuration, Parents. Create child with ALL FK types pointing to Parent 1:
   - `'parent_id': 'Parent 1'` (scalar FK)
   - `'mentor_id': ['Parent 1']` (set FK)
   - `'parent_ref': ['Parent 1']` (vector FK)
   - `'date_time': ['2024-01-01']`, `'sponsor_id': ['Parent 1']` (time series)

   Update child to change ALL FK types to Parent 2:
   `db.updateElement('Child', 1, {'parent_id': 'Parent 2', 'mentor_id': ['Parent 2'], 'parent_ref': ['Parent 2'], 'date_time': ['2025-01-01'], 'sponsor_id': ['Parent 2']})`

   Verify each:
   - Scalar: `db.readScalarIntegers('Child', 'parent_id')` -> `[2]`
   - Set: `db.readSetIntegersById('Child', 'mentor_id', 1)` -> `[2]`
   - Vector: `db.readVectorIntegersById('Child', 'parent_ref', 1)` -> `[2]`
   - Time series: `db.readTimeSeriesGroup('Child', 'events', 1)['sponsor_id']` -> `[2]`

   Close db.

6. **`test('non-FK integer columns pass through unchanged', ...)`** -- Use `basic.sql` schema (no FK columns). Create element with `'label': 'Config 1'`, `'integer_attribute': 42`, `'float_attribute': 3.14`, `'string_attribute': 'hello'`. Update: `db.updateElement('Configuration', 1, {'integer_attribute': 100, 'float_attribute': 2.71, 'string_attribute': 'world'})`. Verify:
   - `db.readScalarIntegerById('Configuration', 'integer_attribute', 1)` -> `100`
   - `db.readScalarFloatById('Configuration', 'float_attribute', 1)` -> `2.71`
   - `db.readScalarStringById('Configuration', 'string_attribute', 1)` -> `'world'`

   This proves the FK pre-resolve pass is a no-op for non-FK schemas during update. Close db.

7. **`test('failure preserves existing data', ...)`** -- Create Configuration, create "Parent 1". Create child with `'parent_id': 'Parent 1'`. Attempt update with `'parent_id': 'Nonexistent Parent'`: `expect(() => db.updateElement('Child', 1, {'parent_id': 'Nonexistent Parent'}), throwsA(isA<DatabaseException>()))`. Then verify original value preserved: `db.readScalarIntegers('Child', 'parent_id')` returns `[1]`. Close db.

**Pattern notes:**
- All tests use `Database.fromSchema(':memory:', schemaPath)` for db creation, `db.close()` in `finally` for cleanup.
- FK labels are passed as string values in the Map. The Dart Element builder routes strings through Element.setString() / Element.setArrayString() in the Dart layer, which calls the C API's FK resolution.
- The relations.sql schema requires a Configuration element before creating Parent/Child.
- Use `throwsA(isA<DatabaseException>())` for error cases -- do not inspect error messages.
  </action>
  <verify>
Run Dart tests:
```bash
bindings/dart/test/test.bat
```
All Dart tests pass including the 7 new FK update tests.
  </verify>
  <done>
7 FK update tests inside a `group('FK Resolution - Update', ...)` appended to database_update_test.dart, all passing. Test names: resolves scalar FK labels to IDs, resolves vector FK labels to IDs, resolves set FK labels to IDs, resolves time series FK labels to IDs, resolves all FK types in one call, non-FK integer columns pass through unchanged, failure preserves existing data.
  </done>
</task>

</tasks>

<verification>
1. `bindings/dart/test/test.bat` -- all Dart tests pass (existing + 7 new FK update tests)
2. Verify the 7 new tests exist in database_update_test.dart inside `group('FK Resolution - Update', ...)`
</verification>

<success_criteria>
- 7 new tests in database_update_test.dart inside `group('FK Resolution - Update', ...)`
- Test names mirror C++ counterparts adapted to Dart group/test conventions
- All tests pass when run via Dart test runner
- No regressions in existing Dart tests
</success_criteria>

<output>
After completion, create `.planning/phases/07-dart-fk-tests/07-02-SUMMARY.md`
</output>
