---
phase: 07-dart-fk-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [bindings/dart/test/database_create_test.dart]
autonomous: true
requirements: [DART-01]
must_haves:
  truths:
    - "Dart createElement resolves set FK string labels to integer IDs"
    - "Dart createElement resolves scalar FK string labels to integer IDs"
    - "Dart createElement resolves vector FK string labels to integer IDs"
    - "Dart createElement resolves time series FK string labels to integer IDs"
    - "Dart createElement resolves all FK types in a single call"
    - "Dart createElement throws DatabaseException for missing FK target labels"
    - "Dart createElement throws DatabaseException for strings in non-FK integer columns"
    - "Dart createElement writes zero rows when FK resolution fails (no partial writes)"
    - "Dart createElement passes non-FK integer values through unchanged"
  artifacts:
    - path: "bindings/dart/test/database_create_test.dart"
      provides: "9 Dart FK create tests appended at end of file"
      contains: "FK Resolution - Create"
  key_links:
    - from: "bindings/dart/test/database_create_test.dart"
      to: "db.createElement"
      via: "Dart Map API with string labels for FK columns triggering C API FK resolution"
      pattern: "createElement.*Child.*parent_id"
---

<objective>
Add 9 FK resolution tests to the Dart create test file, mirroring all C++ create-path FK tests.

Purpose: Verify that FK label-to-ID resolution works correctly through Dart's createElement for all column types (scalar, vector, set, time series), error cases (missing target, non-FK integer), combined operations, no-FK regression, and transactional safety (no partial writes).

Output: 9 new tests inside a `group('FK Resolution - Create', ...)` block appended at the end of the `main()` function in database_create_test.dart
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bindings/dart/test/database_create_test.dart
@bindings/dart/lib/src/element.dart
@bindings/dart/lib/src/database_create.dart
@bindings/dart/lib/src/database_read.dart
@bindings/dart/lib/src/exceptions.dart
@tests/schemas/valid/relations.sql
@tests/schemas/valid/basic.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 9 FK resolution create tests to Dart test file</name>
  <files>bindings/dart/test/database_create_test.dart</files>
  <action>
Append a new `group('FK Resolution - Create', () { ... });` block at the end of `main()`, just before the closing `}` of the main function. Each test follows the existing Dart test pattern: `Database.fromSchema(':memory:', schemaPath)` with `try/finally` and `db.close()`.

Use `final testsPath` already declared at the top of `main()` for path construction. The relations.sql path is `path.join(testsPath, 'schemas', 'valid', 'relations.sql')`.

**The 9 tests to add (mirroring C++ test names, adapted to Dart conventions):**

1. **`test('resolves set FK labels to IDs', ...)`** -- Create Configuration, 2 Parents ("Parent 1", "Parent 2"). Create child with `'mentor_id': ['Parent 1', 'Parent 2']` (string list for set FK). Verify via `db.readSetIntegersById('Child', 'mentor_id', 1)` that values are `[1, 2]` (sort before comparing with `..sort()`). Close db.

2. **`test('throws on missing FK target label', ...)`** -- Create Configuration. Verify `expect(() => db.createElement('Child', {'label': 'Child 1', 'mentor_id': ['Nonexistent Parent']}), throwsA(isA<DatabaseException>()))`. Do NOT check error message per CONTEXT.md decisions. Close db.

3. **`test('throws on string for non-FK integer column', ...)`** -- Create Configuration, create a Parent. Create child attempt with `score` column (non-FK INTEGER in `Child_set_scores`) set to string labels `['not_a_label']`. The set attribute name is `score` (from table `Child_set_scores`). Pass: `db.createElement('Child', {'label': 'Child 1', 'parent_id': 1, 'score': ['not_a_label']})`. Verify `throwsA(isA<DatabaseException>())`. Close db.

4. **`test('resolves scalar FK labels to IDs', ...)`** -- Create Configuration, create "Parent 1". Create child with `'parent_id': 'Parent 1'` (string label, not integer). Verify via `db.readScalarIntegers('Child', 'parent_id')` that value is `[1]`. Close db.

5. **`test('resolves vector FK labels to IDs', ...)`** -- Create Configuration, create "Parent 1", "Parent 2". Create child with `'parent_ref': ['Parent 1', 'Parent 2']` (string list for vector FK). Verify via `db.readVectorIntegersById('Child', 'parent_ref', 1)` that values are `[1, 2]`. Close db.

6. **`test('resolves time series FK labels to IDs', ...)`** -- Create Configuration, create "Parent 1", "Parent 2". Create child with `'date_time': ['2024-01-01', '2024-01-02']` and `'sponsor_id': ['Parent 1', 'Parent 2']` (string arrays for time series). Verify via `db.readTimeSeriesGroup('Child', 'events', 1)`. The result is `Map<String, List<Object>>`. Check that the `sponsor_id` column contains `[1, 2]` (integers after FK resolution). Close db.

    NOTE: The time series group name is `'events'` (from `Child_time_series_events`). The `readTimeSeriesGroup` Dart method returns `Map<String, List<Object>>` where INTEGER columns are returned as `List<int>`. The dimension column `date_time` is parsed to `DateTime` objects.

7. **`test('resolves all FK types in one call', ...)`** -- Create Configuration, create "Parent 1", "Parent 2". Create child with ALL FK types in one createElement call:
   - `'parent_id': 'Parent 1'` (scalar FK)
   - `'mentor_id': ['Parent 2']` (set FK)
   - `'parent_ref': ['Parent 1']` (vector FK)
   - `'date_time': ['2024-01-01']` (time series dimension)
   - `'sponsor_id': ['Parent 2']` (time series FK)

   Verify each:
   - Scalar: `db.readScalarIntegers('Child', 'parent_id')` -> `[1]`
   - Set: `db.readSetIntegersById('Child', 'mentor_id', 1)..sort()` -> `[2]`
   - Vector: `db.readVectorIntegersById('Child', 'parent_ref', 1)` -> `[1]`
   - Time series: `db.readTimeSeriesGroup('Child', 'events', 1)['sponsor_id']` -> `[2]`

   Close db.

8. **`test('non-FK integer columns pass through unchanged', ...)`** -- Use `basic.sql` schema (no FK columns). Create element with `'label': 'Config 1'`, `'integer_attribute': 42`, `'float_attribute': 3.14`. Verify all values read back correctly:
   - `db.readScalarStrings('Configuration', 'label')` -> `['Config 1']`
   - `db.readScalarIntegers('Configuration', 'integer_attribute')` -> `[42]`
   - `db.readScalarFloats('Configuration', 'float_attribute')` -> `[3.14]`

   This proves the FK pre-resolve pass is a no-op for non-FK schemas. Close db.

9. **`test('zero partial writes on resolution failure', ...)`** -- Create Configuration (required by schema). Attempt to create child with `'parent_id': 'Nonexistent Parent'` (string label). Verify `throwsA(isA<DatabaseException>())`. Then verify no child was created by reading `db.readScalarStrings('Child', 'label')` and asserting the result is empty. Close db.

**Pattern notes:**
- All tests use `Database.fromSchema(':memory:', schemaPath)` for db creation, `db.close()` in `finally` for cleanup.
- FK labels are passed as string values in the Map (e.g., `'parent_id': 'Parent 1'`) or string lists (e.g., `'mentor_id': ['Parent 1']`). This triggers Element.setString() / Element.setArrayString() in the Dart layer, which calls the C API's FK resolution.
- The relations.sql schema requires a Configuration element before creating Parent/Child.
- Use `throwsA(isA<DatabaseException>())` for error cases -- do not inspect error messages.
  </action>
  <verify>
Run Dart tests:
```bash
bindings/dart/test/test.bat
```
All Dart tests pass including the 9 new FK create tests.
  </verify>
  <done>
9 FK create tests inside a `group('FK Resolution - Create', ...)` appended to database_create_test.dart, all passing. Test names: resolves set FK labels to IDs, throws on missing FK target label, throws on string for non-FK integer column, resolves scalar FK labels to IDs, resolves vector FK labels to IDs, resolves time series FK labels to IDs, resolves all FK types in one call, non-FK integer columns pass through unchanged, zero partial writes on resolution failure.
  </done>
</task>

</tasks>

<verification>
1. `bindings/dart/test/test.bat` -- all Dart tests pass (existing + 9 new FK create tests)
2. Verify the 9 new tests exist in database_create_test.dart inside `group('FK Resolution - Create', ...)`
</verification>

<success_criteria>
- 9 new tests in database_create_test.dart inside `group('FK Resolution - Create', ...)`
- Test names mirror C++ counterparts adapted to Dart group/test conventions
- All tests pass when run via Dart test runner
- No regressions in existing Dart tests
</success_criteria>

<output>
After completion, create `.planning/phases/07-dart-fk-tests/07-01-SUMMARY.md`
</output>
