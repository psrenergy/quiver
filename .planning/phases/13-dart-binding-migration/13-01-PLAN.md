---
phase: 13-dart-binding-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/dart/lib/src/ffi/bindings.dart
  - bindings/dart/lib/src/database_update.dart
  - bindings/dart/lib/src/database_read.dart
autonomous: true
requirements: [BIND-03, BIND-04]

must_haves:
  truths:
    - "Dart updateTimeSeriesGroup accepts Map<String, List<Object>> with column names as keys and typed lists as values"
    - "Dart readTimeSeriesGroup returns Map<String, List<Object>> with typed columns and DateTime dimension"
    - "Empty Map on update clears all rows for that element"
    - "FFI bindings reflect the new 9-arg C API signatures for time series read/update/free"
  artifacts:
    - path: "bindings/dart/lib/src/ffi/bindings.dart"
      provides: "Regenerated FFI bindings with new multi-column C API signatures"
      contains: "quiver_database_update_time_series_group"
    - path: "bindings/dart/lib/src/database_update.dart"
      provides: "Map-based updateTimeSeriesGroup with columnar marshaling"
      contains: "Map<String, List<Object>> data"
    - path: "bindings/dart/lib/src/database_read.dart"
      provides: "Map-based readTimeSeriesGroup with typed columnar unmarshaling"
      contains: "Map<String, List<Object>> readTimeSeriesGroup"
  key_links:
    - from: "bindings/dart/lib/src/database_update.dart"
      to: "bindings/dart/lib/src/ffi/bindings.dart"
      via: "bindings.quiver_database_update_time_series_group with 9 args"
      pattern: "quiver_database_update_time_series_group.*columnNames.*columnTypes.*columnData.*columnCount.*rowCount"
    - from: "bindings/dart/lib/src/database_read.dart"
      to: "bindings/dart/lib/src/ffi/bindings.dart"
      via: "bindings.quiver_database_read_time_series_group with 9 args"
      pattern: "quiver_database_read_time_series_group.*outColNames.*outColTypes.*outColData.*outColCount.*outRowCount"
    - from: "bindings/dart/lib/src/database_read.dart"
      to: "bindings/dart/lib/src/database_metadata.dart"
      via: "getTimeSeriesMetadata for dimension column identification"
      pattern: "getTimeSeriesMetadata.*dimensionColumn"
---

<objective>
Regenerate Dart FFI bindings and rewrite updateTimeSeriesGroup/readTimeSeriesGroup for the multi-column C API with Map-based interface.

Purpose: Migrate Dart time series methods from old 2-column row-oriented interface to new N-column columnar Map interface, matching Phase 11 C API and mirroring Phase 12 Julia semantics with Dart-idiomatic syntax.
Output: Updated FFI bindings, rewritten update method accepting `Map<String, List<Object>>`, rewritten read method returning `Map<String, List<Object>>` with DateTime dimension parsing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-dart-binding-migration/13-CONTEXT.md
@.planning/phases/13-dart-binding-migration/13-RESEARCH.md
@.planning/phases/12-julia-binding-migration/12-01-SUMMARY.md

@bindings/dart/lib/src/database_update.dart
@bindings/dart/lib/src/database_read.dart
@bindings/dart/lib/src/database.dart
@bindings/dart/lib/src/date_time.dart
@bindings/dart/lib/src/database_metadata.dart
@include/quiver/c/database.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate FFI bindings and rewrite updateTimeSeriesGroup</name>
  <files>
    bindings/dart/lib/src/ffi/bindings.dart
    bindings/dart/lib/src/database_update.dart
  </files>
  <action>
**Step 1: Regenerate FFI bindings.**
Run `bindings/dart/generator/generator.bat` to regenerate `bindings/dart/lib/src/ffi/bindings.dart` from the current C headers. This picks up the new 9-arg signatures for `quiver_database_update_time_series_group`, `quiver_database_read_time_series_group`, and `quiver_database_free_time_series_data` from Phase 11.

After regeneration, verify the new signatures exist by checking the generated file contains:
- `quiver_database_update_time_series_group` with `column_names`, `column_types`, `column_data`, `column_count`, `row_count` parameters
- `quiver_database_read_time_series_group` with output pointers for `column_names`, `column_types`, `column_data`, `column_count`, `row_count`
- `quiver_database_free_time_series_data` with `column_names`, `column_types`, `column_data`, `column_count`, `row_count` parameters

**Step 2: Rewrite `updateTimeSeriesGroup` in `database_update.dart`.**

Replace the old method signature:
```dart
void updateTimeSeriesGroup(String collection, String group, int id, List<Map<String, Object?>> rows)
```

With the new Map-based columnar signature:
```dart
void updateTimeSeriesGroup(String collection, String group, int id, Map<String, List<Object>> data)
```

Implementation requirements (per user decisions in CONTEXT.md):
- **Empty Map = clear**: If `data.isEmpty`, call C API with `nullptr, nullptr, nullptr, 0, 0` for the column args. This clears all rows.
- **Row count validation**: Before marshaling, validate that ALL lists in the Map have equal length. Throw `ArgumentError('All column lists must have the same length')` on mismatch. This is the ONE validation Dart does (C API trusts row_count).
- **Strict type enforcement**: No auto-coercion. Determine column type from runtime type of first element:
  - `int` -> `QUIVER_DATA_TYPE_INTEGER`, allocate `arena<Int64>(rowCount)`, copy values cast as `int`
  - `double` -> `QUIVER_DATA_TYPE_FLOAT`, allocate `arena<Double>(rowCount)`, copy values cast as `double`
  - `String` -> `QUIVER_DATA_TYPE_STRING`, allocate `arena<Pointer<Char>>(rowCount)`, convert each to native UTF8
  - `DateTime` -> `QUIVER_DATA_TYPE_STRING`, allocate `arena<Pointer<Char>>(rowCount)`, convert each via `dateTimeToString()` then to native UTF8
  - Any other type -> throw `ArgumentError('Unsupported value type: ${values.first.runtimeType}')`
- **Marshaling**: Build parallel arrays `columnNames` (`Pointer<Pointer<Char>>`), `columnTypes` (`Pointer<Int>`), `columnData` (`Pointer<Pointer<Void>>`) in Arena. Each entry.key becomes a column name, entry.value is marshaled per its runtime type.
- **Call**: `bindings.quiver_database_update_time_series_group(_ptr, collection, group, id, columnNames, columnTypes, columnData, columnCount, rowCount)`
- **Arena cleanup**: Wrap everything in Arena try/finally (existing pattern).
- Import `date_time.dart` is already available via `database.dart` part-of chain. If `dateTimeToString` is not accessible, check the import structure in `database.dart`.

Use the code example from 13-RESEARCH.md as a reference, but adapt to the exact ffigen-generated types (e.g., `Pointer<Int>` vs `Pointer<Int32>` for column_types -- use whatever ffigen generates).
  </action>
  <verify>
Run `bindings/dart/generator/generator.bat` completes without error. Verify `bindings.dart` contains the new 9-arg signatures by searching for `quiver_database_update_time_series_group`. Verify `database_update.dart` compiles (no syntax errors) by running `dart analyze bindings/dart/lib/src/database_update.dart` or checking the full package `dart analyze bindings/dart`.
  </verify>
  <done>
FFI bindings regenerated with multi-column C API signatures. `updateTimeSeriesGroup` accepts `Map<String, List<Object>>` with strict type enforcement, DateTime support, empty-map clear semantics, and row count validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite readTimeSeriesGroup to return Map with typed columns</name>
  <files>
    bindings/dart/lib/src/database_read.dart
  </files>
  <action>
Replace the old `readTimeSeriesGroup` method in `database_read.dart`.

Old signature:
```dart
List<Map<String, Object?>> readTimeSeriesGroup(String collection, String group, int id)
```

New signature:
```dart
Map<String, List<Object>> readTimeSeriesGroup(String collection, String group, int id)
```

Implementation requirements (per user decisions in CONTEXT.md):
- **Allocate output pointers in Arena**: `outColNames` (`Pointer<Pointer<Pointer<Char>>>`), `outColTypes` (`Pointer<Pointer<Int>>`), `outColData` (`Pointer<Pointer<Pointer<Void>>>`), `outColCount` (`Pointer<Size>`), `outRowCount` (`Pointer<Size>>`). Use whatever exact types ffigen generated -- check `bindings.dart` for the exact `quiver_database_read_time_series_group` signature.
- **Call C API**: `bindings.quiver_database_read_time_series_group(_ptr, collection, group, id, outColNames, outColTypes, outColData, outColCount, outRowCount)`
- **Empty check**: If `colCount == 0 || rowCount == 0`, return empty `Map<String, List<Object>>()` (empty map, no keys).
- **Dimension column identification**: Call `getTimeSeriesMetadata(collection, group)` and use `meta.dimensionColumn` to identify which column gets DateTime parsing.
- **Typed unmarshaling per column**: Iterate `c = 0..colCount-1`:
  - Read column name: `outColNames.value[c].cast<Utf8>().toDartString()`
  - Read column type: `outColTypes.value[c]`
  - Switch on type:
    - `QUIVER_DATA_TYPE_INTEGER`: Cast `outColData.value[c]` to `Pointer<Int64>`, generate `List<int>`
    - `QUIVER_DATA_TYPE_FLOAT`: Cast to `Pointer<Double>`, generate `List<double>`
    - `QUIVER_DATA_TYPE_STRING` (or TEXT): Cast to `Pointer<Pointer<Char>>`:
      - If column name == dimension column: parse each string via `stringToDateTime()` to produce `List<DateTime>`. Throw on parse failure (per user decision).
      - Otherwise: produce `List<String>`
- **Free C memory**: Call `bindings.quiver_database_free_time_series_data(outColNames.value, outColTypes.value, outColData.value, colCount, rowCount)` AFTER copying all data to Dart objects but BEFORE returning.
- **Arena cleanup**: Wrap in try/finally.
- **Return**: `Map<String, List<Object>>` with column names as keys and typed lists as values.

Use the code example from 13-RESEARCH.md as a reference, adapting to exact ffigen-generated types. The key risk is the `void**` marshaling -- `outColData.value` is `Pointer<Pointer<Void>>`, and each `outColData.value[c]` must be cast to the correct typed pointer based on `outColTypes.value[c]`.
  </action>
  <verify>
Run `dart analyze bindings/dart` to verify no compilation errors. Check that `readTimeSeriesGroup` return type is `Map<String, List<Object>>` in the source.
  </verify>
  <done>
`readTimeSeriesGroup` returns `Map<String, List<Object>>` with typed columns (List&lt;int&gt; for INTEGER, List&lt;double&gt; for REAL, List&lt;String&gt; for TEXT, List&lt;DateTime&gt; for dimension column). Free function calls the new 5-arg `quiver_database_free_time_series_data`.
  </done>
</task>

</tasks>

<verification>
1. `bindings/dart/lib/src/ffi/bindings.dart` contains regenerated FFI bindings with 9-arg time series signatures
2. `updateTimeSeriesGroup` signature is `Map<String, List<Object>> data` (not old `List<Map<String, Object?>> rows`)
3. `readTimeSeriesGroup` return type is `Map<String, List<Object>>` (not old `List<Map<String, Object?>>`)
4. `dart analyze bindings/dart` reports no errors
5. Both methods use Arena try/finally pattern consistent with existing codebase
</verification>

<success_criteria>
- FFI bindings regenerated and contain new multi-column signatures
- updateTimeSeriesGroup accepts Map with strict type enforcement and empty-map clear semantics
- readTimeSeriesGroup returns Map with typed columns and DateTime dimension parsing
- No compilation errors in dart analyze
</success_criteria>

<output>
After completion, create `.planning/phases/13-dart-binding-migration/13-01-SUMMARY.md`
</output>
