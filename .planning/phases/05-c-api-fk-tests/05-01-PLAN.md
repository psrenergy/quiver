---
phase: 05-c-api-fk-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [tests/test_c_api_database_create.cpp]
autonomous: true
requirements: [CAPI-01]
must_haves:
  truths:
    - "C API create_element resolves set FK string labels to integer IDs"
    - "C API create_element resolves scalar FK string labels to integer IDs"
    - "C API create_element resolves vector FK string labels to integer IDs"
    - "C API create_element resolves time series FK string labels to integer IDs"
    - "C API create_element resolves all FK types in a single call"
    - "C API create_element returns QUIVER_ERROR for missing FK target labels"
    - "C API create_element returns QUIVER_ERROR for strings in non-FK integer columns"
    - "C API create_element writes zero rows when FK resolution fails (no partial writes)"
    - "C API create_element passes non-FK integer values through unchanged"
  artifacts:
    - path: "tests/test_c_api_database_create.cpp"
      provides: "9 C API FK create tests appended at end"
      contains: "CreateElementScalarFkLabel"
  key_links:
    - from: "tests/test_c_api_database_create.cpp"
      to: "quiver_database_create_element"
      via: "C API function call with quiver_element_t containing string labels for FK columns"
      pattern: "quiver_database_create_element.*db.*Child.*element"
---

<objective>
Add 9 FK resolution tests to the C API create test file, mirroring all C++ create-path FK tests.

Purpose: Verify that FK label-to-ID resolution works correctly through the C API layer for all column types (scalar, vector, set, time series), error cases (missing target, non-FK integer), combined operations, no-FK regression, and transactional safety (no partial writes).

Output: 9 new TEST(DatabaseCApi, ...) cases appended to test_c_api_database_create.cpp
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@tests/test_c_api_database_create.cpp
@tests/test_database_create.cpp
@tests/schemas/valid/relations.sql
@tests/test_utils.h
@include/quiver/c/element.h
@include/quiver/c/database.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 9 FK resolution create tests to C API test file</name>
  <files>tests/test_c_api_database_create.cpp</files>
  <action>
Append 9 new TEST(DatabaseCApi, ...) cases at the end of `tests/test_c_api_database_create.cpp`, after the existing `CreateElementWithDatetime` test. Add a section comment banner:

```cpp
// ============================================================================
// FK label resolution in create_element
// ============================================================================
```

Each test is self-contained: creates its own db from `relations.sql` using `quiver_database_from_schema`, creates parent elements inline, then tests FK resolution through the C API. Use `quiver::test::quiet_options()` for options. Mirror the C++ test names exactly with `DatabaseCApi` prefix.

**The 9 tests to add (mirror C++ test names 1:1):**

1. **`ResolveFkLabelInSetCreate`** -- Create 2 parents ("Parent 1", "Parent 2"). Create child with `quiver_element_set_array_string(child, "mentor_id", ...)` passing string labels `{"Parent 1", "Parent 2"}`. Verify via `quiver_database_read_set_integers_by_id` that mentor_id values are resolved to `{1, 2}` (sort before comparing). Free with `quiver_database_free_integer_array`.

2. **`ResolveFkLabelMissingTarget`** -- Create child with `mentor_id` referencing `{"Nonexistent Parent"}`. Verify `quiver_database_create_element` returns `QUIVER_ERROR`. Do NOT check error message substring -- just verify return code per CONTEXT.md decisions.

3. **`RejectStringForNonFkIntegerColumn`** -- Create child with `score` column (non-FK INTEGER in `Child_set_scores`) set to string labels `{"not_a_label"}` via `quiver_element_set_array_string`. Verify `quiver_database_create_element` returns `QUIVER_ERROR`.

4. **`CreateElementScalarFkLabel`** -- Create parent "Parent 1". Create child with `quiver_element_set_string(child, "parent_id", "Parent 1")` (string label, not integer). Verify via `quiver_database_read_scalar_integers` that `parent_id` resolved to `{1}`. Free with `quiver_database_free_integer_array`.

5. **`CreateElementVectorFkLabels`** -- Create parents "Parent 1", "Parent 2". Create child with `quiver_element_set_array_string(child, "parent_ref", {"Parent 1", "Parent 2"})`. Verify via `quiver_database_read_vector_integers_by_id` that `parent_ref` resolved to `{1, 2}`. Free with `quiver_database_free_integer_array`.

6. **`CreateElementTimeSeriesFkLabels`** -- Create parents "Parent 1", "Parent 2". Create child with `date_time` array `{"2024-01-01", "2024-01-02"}` and `sponsor_id` array `{"Parent 1", "Parent 2"}` (both via `quiver_element_set_array_string`). Verify via `quiver_database_read_time_series_group` that `sponsor_id` column (INTEGER type) contains `{1, 2}`. Cast `out_col_data[sponsor_col_index]` to `int64_t*`. Free with `quiver_database_free_time_series_data`.

    NOTE: The time series group name for `Child_time_series_events` is `"events"`. The column layout from `read_time_series_group` will be: col 0 = `date_time` (STRING), col 1 = `sponsor_id` (INTEGER). Verify `out_col_count == 2` and `out_row_count == 2`.

7. **`CreateElementAllFkTypesInOneCall`** -- Create parents "Parent 1", "Parent 2". Create child with ALL FK types:
   - `quiver_element_set_string(child, "parent_id", "Parent 1")` (scalar FK)
   - `quiver_element_set_array_string(child, "mentor_id", {"Parent 2"})` (set FK)
   - `quiver_element_set_array_string(child, "parent_ref", {"Parent 1"})` (vector+set FK)
   - `quiver_element_set_array_string(child, "date_time", {"2024-01-01"})` (time series dimension)
   - `quiver_element_set_array_string(child, "sponsor_id", {"Parent 2"})` (time series FK)

   Verify each via appropriate read function:
   - Scalar: `read_scalar_integers` -> `parent_id == 1`
   - Set (mentor_id): `read_set_integers_by_id` -> `{2}`
   - Vector (parent_ref): `read_vector_integers_by_id` -> `{1}`
   - Time series (sponsor_id): `read_time_series_group` -> sponsor_id col = `{2}`

   Free all read results appropriately.

8. **`CreateElementNoFkColumnsUnchanged`** -- Use `basic.sql` schema (no FK columns). Create element with `label="Config 1"`, `integer_attribute=42`, `float_attribute=3.14`. Verify all values read back correctly via `read_scalar_strings`, `read_scalar_integers`, `read_scalar_floats`. This proves the FK pre-resolve pass is a no-op for non-FK schemas. Free string array with `quiver_database_free_string_array`, integer/float arrays with `quiver_database_free_integer_array`/`quiver_database_free_float_array`.

9. **`ScalarFkResolutionFailureCausesNoPartialWrites`** -- Create child with `parent_id` set to `"Nonexistent Parent"` via `quiver_element_set_string`. Verify `quiver_database_create_element` returns `QUIVER_ERROR`. Then verify no child was created by reading `read_scalar_strings(db, "Child", "label", ...)` and asserting `out_count == 0`. Free any allocated arrays.

**Cleanup pattern for all tests:** Destroy elements with `quiver_element_destroy`, close db with `quiver_database_close`. For error-path tests where create_element fails, still destroy the element and close the db. Use Claude's discretion on whether to free read results that were never allocated (per CONTEXT.md).

**Include directive:** Add `#include <algorithm>` at the top of the file if not already present (needed for `std::sort` in the set test).
  </action>
  <verify>
Build and run C API tests:
```bash
cmake --build build --config Debug && ./build/bin/quiver_c_tests.exe --gtest_filter="DatabaseCApi.*Fk*:DatabaseCApi.*NoFk*:DatabaseCApi.*NonFk*:DatabaseCApi.*PartialWrites*"
```
All 9 new tests pass. Existing tests still pass:
```bash
./build/bin/quiver_c_tests.exe
```
  </verify>
  <done>
9 FK create tests appended to test_c_api_database_create.cpp, all passing. Test names match C++ counterparts exactly. Each test is self-contained with inline setup. Verification uses C API read functions to confirm resolved integer IDs.
  </done>
</task>

</tasks>

<verification>
1. `./build/bin/quiver_c_tests.exe` -- all tests pass (existing + 9 new FK create tests)
2. `./build/bin/quiver_c_tests.exe --gtest_filter="DatabaseCApi.*Fk*"` -- filters show the 9 new create tests
3. `./build/bin/quiver_tests.exe` -- C++ tests still pass (no regressions)
</verification>

<success_criteria>
- 9 new TEST(DatabaseCApi, ...) cases in test_c_api_database_create.cpp
- Test names mirror C++ counterparts: ResolveFkLabelInSetCreate, ResolveFkLabelMissingTarget, RejectStringForNonFkIntegerColumn, CreateElementScalarFkLabel, CreateElementVectorFkLabels, CreateElementTimeSeriesFkLabels, CreateElementAllFkTypesInOneCall, CreateElementNoFkColumnsUnchanged, ScalarFkResolutionFailureCausesNoPartialWrites
- All tests pass when run via quiver_c_tests.exe
- No regressions in existing C API or C++ tests
</success_criteria>

<output>
After completion, create `.planning/phases/05-c-api-fk-tests/05-01-SUMMARY.md`
</output>
