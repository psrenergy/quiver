---
phase: 05-c-api-fk-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [tests/test_c_api_database_update.cpp]
autonomous: true
requirements: [CAPI-02]
must_haves:
  truths:
    - "C API update_element resolves scalar FK string labels to integer IDs"
    - "C API update_element resolves vector FK string labels to integer IDs"
    - "C API update_element resolves set FK string labels to integer IDs"
    - "C API update_element resolves time series FK string labels to integer IDs"
    - "C API update_element resolves all FK types in a single call"
    - "C API update_element passes non-FK integer values through unchanged"
    - "C API update_element failure preserves the element's existing data"
  artifacts:
    - path: "tests/test_c_api_database_update.cpp"
      provides: "7 C API FK update tests appended at end"
      contains: "UpdateElementScalarFkLabel"
  key_links:
    - from: "tests/test_c_api_database_update.cpp"
      to: "quiver_database_update_element"
      via: "C API function call with quiver_element_t containing string labels for FK columns"
      pattern: "quiver_database_update_element.*db.*Child.*1.*update"
---

<objective>
Add 7 FK resolution tests to the C API update test file, mirroring all C++ update-path FK tests.

Purpose: Verify that FK label-to-ID resolution works correctly through the C API layer for update_element across all column types (scalar, vector, set, time series), combined operations, no-FK regression, and transactional safety (failure preserves existing data).

Output: 7 new TEST(DatabaseCApi, ...) cases appended to test_c_api_database_update.cpp
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@tests/test_c_api_database_update.cpp
@tests/test_database_update.cpp
@tests/schemas/valid/relations.sql
@tests/test_utils.h
@include/quiver/c/element.h
@include/quiver/c/database.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 7 FK resolution update tests to C API test file</name>
  <files>tests/test_c_api_database_update.cpp</files>
  <action>
Append 7 new TEST(DatabaseCApi, ...) cases at the end of `tests/test_c_api_database_update.cpp`, after the existing `UpdateSetStringsNullElement` test. Add a section comment banner:

```cpp
// ============================================================================
// Update element FK label resolution tests
// ============================================================================
```

Each test is self-contained: creates its own db from `relations.sql` (or `basic.sql` for the no-FK test), creates parent/child elements inline using `quiver_database_create_element`, then performs an update with FK string labels and verifies resolution. Use `quiver::test::quiet_options()` for options. Mirror the C++ test names exactly with `DatabaseCApi` prefix.

**Setup pattern for FK update tests (tests 1-4, 5, 7):**
Each test needs: (a) create 2 parents, (b) create child with initial FK pointing to Parent 1 via string label, (c) update child to point to Parent 2 via string label, (d) read back and verify resolved IDs.

Use `quiver_element_set_string` for scalar FK labels and `quiver_element_set_array_string` for array FK labels (vector, set, time series). Create elements with `quiver_element_create`, set attributes, call `quiver_database_create_element`, then `quiver_element_destroy`.

For the update step: create a fresh element (`quiver_element_create`), set only the FK attributes being updated, call `quiver_database_update_element(db, "Child", 1, update)`, then `quiver_element_destroy(update)`.

**The 7 tests to add (mirror C++ test names 1:1):**

1. **`UpdateElementScalarFkLabel`** -- Create parents "Parent 1", "Parent 2". Create child with `parent_id` = "Parent 1". Update child: set `parent_id` = "Parent 2". Verify via `quiver_database_read_scalar_integers(db, "Child", "parent_id", ...)` that value is `{2}`. Free with `quiver_database_free_integer_array`.

2. **`UpdateElementVectorFkLabels`** -- Create parents. Create child with `parent_ref` = `{"Parent 1"}`. Update child: set `parent_ref` = `{"Parent 2", "Parent 1"}`. Verify via `quiver_database_read_vector_integers_by_id(db, "Child", "parent_ref", 1, ...)` that values are `{2, 1}` (order preserved). Free with `quiver_database_free_integer_array`.

3. **`UpdateElementSetFkLabels`** -- Create parents. Create child with `mentor_id` = `{"Parent 1"}`. Update child: set `mentor_id` = `{"Parent 2"}`. Verify via `quiver_database_read_set_integers_by_id(db, "Child", "mentor_id", 1, ...)` that value is `{2}`. Free with `quiver_database_free_integer_array`.

4. **`UpdateElementTimeSeriesFkLabels`** -- Create parents. Create child with `date_time` = `{"2024-01-01"}`, `sponsor_id` = `{"Parent 1"}`. Update child: set `date_time` = `{"2024-06-01", "2024-06-02"}`, `sponsor_id` = `{"Parent 2", "Parent 1"}`. Verify via `quiver_database_read_time_series_group(db, "Child", "events", 1, ...)` that `out_row_count == 2`, `out_col_count == 2`, and the sponsor_id column (col index 1, INTEGER type) contains `{2, 1}`. Cast `out_col_data[1]` to `int64_t*`. Free with `quiver_database_free_time_series_data`.

5. **`UpdateElementAllFkTypesInOneCall`** -- Create parents. Create child with ALL FK types pointing to Parent 1:
   - `parent_id` = "Parent 1" (scalar FK)
   - `mentor_id` = `{"Parent 1"}` (set FK)
   - `parent_ref` = `{"Parent 1"}` (vector+set FK)
   - `date_time` = `{"2024-01-01"}`, `sponsor_id` = `{"Parent 1"}` (time series)

   Update child: change ALL FK types to Parent 2:
   - `parent_id` = "Parent 2"
   - `mentor_id` = `{"Parent 2"}`
   - `parent_ref` = `{"Parent 2"}`
   - `date_time` = `{"2025-01-01"}`, `sponsor_id` = `{"Parent 2"}`

   Verify each via appropriate read function:
   - Scalar: `read_scalar_integers` -> `parent_id == 2`
   - Set (mentor_id): `read_set_integers_by_id` -> `{2}`
   - Vector (parent_ref): `read_vector_integers_by_id` -> `{2}`
   - Time series (sponsor_id): `read_time_series_group` -> `out_row_count == 1`, sponsor_id col = `{2}`

   Free all read results appropriately.

6. **`UpdateElementNoFkColumnsUnchanged`** -- Use `basic.sql` schema (no FK columns). Create element with `label="Config 1"`, `integer_attribute=42`, `float_attribute=3.14`, `string_attribute="hello"`. Update via `quiver_database_update_element` with new values: `integer_attribute=100`, `float_attribute=2.71`, `string_attribute="world"`. Verify via `read_scalar_integer_by_id`, `read_scalar_float_by_id`, `read_scalar_string_by_id` that updated values are correct. Free string with `delete[]`. This proves the FK pre-resolve pass is a no-op for non-FK schemas during update.

7. **`UpdateElementFkResolutionFailurePreservesExisting`** -- Create parent "Parent 1". Create child with `parent_id` = "Parent 1". Attempt update with `parent_id` = "Nonexistent Parent". Verify `quiver_database_update_element` returns `QUIVER_ERROR`. Then verify original value preserved: `read_scalar_integers(db, "Child", "parent_id", ...)` returns `{1}`. Free with `quiver_database_free_integer_array`.

**Cleanup pattern:** Destroy all elements with `quiver_element_destroy`, close db with `quiver_database_close`. For error-path tests, still destroy elements and close db.
  </action>
  <verify>
Build and run C API tests:
```bash
cmake --build build --config Debug && ./build/bin/quiver_c_tests.exe --gtest_filter="DatabaseCApi.UpdateElement*Fk*:DatabaseCApi.UpdateElement*NoFk*:DatabaseCApi.UpdateElement*Preserves*"
```
All 7 new tests pass. Existing tests still pass:
```bash
./build/bin/quiver_c_tests.exe
```
  </verify>
  <done>
7 FK update tests appended to test_c_api_database_update.cpp, all passing. Test names match C++ counterparts exactly. Each test is self-contained with inline setup. Verification uses C API read functions to confirm resolved integer IDs after update. Failure-preserves-existing test confirms transactional safety.
  </done>
</task>

</tasks>

<verification>
1. `./build/bin/quiver_c_tests.exe` -- all tests pass (existing + 7 new FK update tests)
2. `./build/bin/quiver_c_tests.exe --gtest_filter="DatabaseCApi.UpdateElement*Fk*"` -- filters show the new update tests
3. `./build/bin/quiver_tests.exe` -- C++ tests still pass (no regressions)
</verification>

<success_criteria>
- 7 new TEST(DatabaseCApi, ...) cases in test_c_api_database_update.cpp
- Test names mirror C++ counterparts: UpdateElementScalarFkLabel, UpdateElementVectorFkLabels, UpdateElementSetFkLabels, UpdateElementTimeSeriesFkLabels, UpdateElementAllFkTypesInOneCall, UpdateElementNoFkColumnsUnchanged, UpdateElementFkResolutionFailurePreservesExisting
- All tests pass when run via quiver_c_tests.exe
- No regressions in existing C API or C++ tests
</success_criteria>

<output>
After completion, create `.planning/phases/05-c-api-fk-tests/05-02-SUMMARY.md`
</output>
