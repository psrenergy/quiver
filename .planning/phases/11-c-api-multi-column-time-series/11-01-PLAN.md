---
phase: 11-c-api-multi-column-time-series
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/schemas/valid/mixed_time_series.sql
  - src/c/internal.h
  - include/quiver/c/database.h
  - src/c/database_time_series.cpp
autonomous: true
requirements: [CAPI-01, CAPI-02, CAPI-03, CAPI-04, CAPI-05, MIGR-01]
must_haves:
  truths:
    - "C API update function accepts N typed columns (column_names[], column_types[], column_data[], column_count, row_count) and writes multi-column time series data"
    - "C API read function returns self-describing multi-column results with column names, types, and typed data arrays in schema definition order"
    - "C API free function deallocates variable-column read results correctly based on column_types (string columns: per-element cleanup, numeric columns: single delete[])"
    - "C API validates column names and types against schema metadata, returning clear error messages on mismatch"
    - "Dimension column is unified -- treated as a regular column in column_names[], discovered from metadata internally"
    - "Mixed-type test schema (INTEGER + REAL + TEXT value columns) exists in tests/schemas/valid/"
  artifacts:
    - path: "tests/schemas/valid/mixed_time_series.sql"
      provides: "Multi-column time series test schema with mixed types"
      contains: "Sensor_time_series_readings"
    - path: "include/quiver/c/database.h"
      provides: "New multi-column time series function signatures"
      contains: "column_names"
    - path: "src/c/database_time_series.cpp"
      provides: "Implementation of multi-column update, read, and free functions"
      min_lines: 150
    - path: "src/c/internal.h"
      provides: "Extended QUIVER_REQUIRE macro supporting 7+ arguments"
      contains: "QUIVER_REQUIRE_9"
  key_links:
    - from: "include/quiver/c/database.h"
      to: "src/c/database_time_series.cpp"
      via: "function declaration matches implementation"
      pattern: "quiver_database_update_time_series_group.*column_names"
    - from: "src/c/database_time_series.cpp"
      to: "include/quiver/attribute_metadata.h"
      via: "metadata lookup for validation and column ordering"
      pattern: "get_time_series_metadata"
    - from: "src/c/database_time_series.cpp"
      to: "src/c/database_helpers.h"
      via: "to_c_data_type for type validation"
      pattern: "to_c_data_type"
---

<objective>
Implement the multi-column time series C API: new function signatures for update, read, and free that support N typed value columns, plus schema validation and the mixed-type test schema.

Purpose: Replace the hardcoded single-column (date_times, values) C API with a columnar typed-array interface that supports any number of typed value columns (INTEGER, REAL, TEXT), enabling multi-column time series workflows through FFI.

Output: New C API header signatures, full implementation in database_time_series.cpp, extended QUIVER_REQUIRE macro, and mixed_time_series.sql test schema.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-c-api-multi-column-time-series/11-CONTEXT.md
@.planning/phases/11-c-api-multi-column-time-series/11-RESEARCH.md

@include/quiver/c/database.h
@src/c/database_time_series.cpp
@src/c/internal.h
@src/c/database_helpers.h
@include/quiver/attribute_metadata.h
@include/quiver/data_type.h
@include/quiver/value.h
@tests/schemas/valid/collections.sql
@tests/schemas/valid/multi_time_series.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mixed-type test schema and extend QUIVER_REQUIRE macro</name>
  <files>
    tests/schemas/valid/mixed_time_series.sql
    src/c/internal.h
  </files>
  <action>
**mixed_time_series.sql:** Create a new test schema at `tests/schemas/valid/mixed_time_series.sql` with:
- Configuration table (standard pattern)
- Sensor table (id, label)
- `Sensor_time_series_readings` table with mixed-type value columns:
  - `id INTEGER NOT NULL REFERENCES Sensor(id) ON DELETE CASCADE ON UPDATE CASCADE`
  - `date_time TEXT NOT NULL` (dimension column)
  - `temperature REAL NOT NULL` (FLOAT type)
  - `humidity INTEGER NOT NULL` (INTEGER type)
  - `status TEXT NOT NULL` (STRING type)
  - `PRIMARY KEY (id, date_time)`
- All tables STRICT, PRAGMA foreign_keys = ON

This schema tests all three value types (REAL, INTEGER, TEXT) in a single time series group. It satisfies MIGR-01.

**internal.h:** Extend the QUIVER_REQUIRE macro to support up to 9 arguments. The new read signature has 9 parameters that need null checking. Add:
- `QUIVER_REQUIRE_7(a,b,c,d,e,f,g)` — chains QUIVER_REQUIRE_1 for each
- `QUIVER_REQUIRE_8(a,b,c,d,e,f,g,h)` — chains QUIVER_REQUIRE_1 for each
- `QUIVER_REQUIRE_9(a,b,c,d,e,f,g,h,i)` — chains QUIVER_REQUIRE_1 for each
- Update the `QUIVER_REQUIRE_N` counting macro to include `_7, _8, _9` (expand the argument list and add the three new dispatch entries)

Follow the exact pattern used by QUIVER_REQUIRE_1 through QUIVER_REQUIRE_6. The counting macro needs extra dummy args in its parameter list to count up to 9.
  </action>
  <verify>
Both files exist. `mixed_time_series.sql` contains CREATE TABLE for Sensor_time_series_readings with temperature REAL, humidity INTEGER, status TEXT columns. `internal.h` contains QUIVER_REQUIRE_9 definition and updated QUIVER_REQUIRE_N macro.
  </verify>
  <done>
Mixed-type test schema exists with 3 typed value columns (REAL, INTEGER, TEXT). QUIVER_REQUIRE macro supports up to 9 arguments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace C API time series header declarations and implement multi-column update/read/free</name>
  <files>
    include/quiver/c/database.h
    src/c/database_time_series.cpp
  </files>
  <action>
**include/quiver/c/database.h:** Replace the three existing time series function declarations with new multi-column signatures. Keep function names identical (no `_multi`/`_v2` suffixes — locked decision).

Replace `quiver_database_update_time_series_group` declaration with:
```c
quiver_error_t quiver_database_update_time_series_group(
    quiver_database_t* db,
    const char* collection,
    const char* group,
    int64_t id,
    const char* const* column_names,
    const int* column_types,
    const void* const* column_data,
    size_t column_count,
    size_t row_count);
```

Replace `quiver_database_read_time_series_group` declaration with:
```c
quiver_error_t quiver_database_read_time_series_group(
    quiver_database_t* db,
    const char* collection,
    const char* group,
    int64_t id,
    char*** out_column_names,
    int** out_column_types,
    void*** out_column_data,
    size_t* out_column_count,
    size_t* out_row_count);
```

Replace `quiver_database_free_time_series_data` declaration with:
```c
quiver_error_t quiver_database_free_time_series_data(
    char** column_names,
    int* column_types,
    void** column_data,
    size_t column_count,
    size_t row_count);
```

Update the comments above each function to reflect multi-column behavior. The existing `quiver_data_type_t` enum (INTEGER=0, FLOAT=1, STRING=2, DATE_TIME=3, NULL=4) is reused unchanged (CAPI-04).

**src/c/database_time_series.cpp:** Replace the implementations of the three functions. Keep metadata/list functions and time series files functions unchanged.

**Update implementation flow:**
1. Use two QUIVER_REQUIRE calls: first for `(db, collection, group)`, then validate column arrays when row_count > 0
2. Handle clear operation: if `column_count == 0 && row_count == 0`, call `update_time_series_group` with empty rows vector
3. Validate `column_count > 0` when `row_count > 0` (set error and return QUIVER_ERROR if violated)
4. Validate column arrays non-null when column_count > 0
5. Get metadata via `db->db.get_time_series_metadata(collection, group)`
6. Build schema lookup map: `map<string, quiver_data_type_t>` from metadata (dimension_column -> STRING type for the dimension, value_columns -> to_c_data_type for each)
7. Validate dimension column present in caller's column_names[] (fail with: `"Cannot update_time_series_group: dimension column '{dim}' missing from column_names"`)
8. Validate each column_name exists in schema (fail with: `"Cannot update_time_series_group: column '{name}' not found in group '{group}' for collection '{collection}'"`)
9. Validate each column_type matches schema type. Treat DATE_TIME and STRING as interchangeable (both map to char* in C API). For type mismatch, use a local `c_type_name()` helper to produce: `"Cannot update_time_series_group: column '{name}' has type {expected} but received {actual}"`
10. Convert columnar to row format: build `vector<map<string, Value>>` by iterating rows, then columns. Type-dispatch on column_types[c]: INTEGER -> `static_cast<const int64_t*>(column_data[c])[r]`, FLOAT -> `static_cast<const double*>(column_data[c])[r]`, STRING/DATE_TIME -> `string(static_cast<const char* const*>(column_data[c])[r])`
11. Call `db->db.update_time_series_group(collection, group, id, rows)`

**Read implementation flow:**
1. QUIVER_REQUIRE(db, collection, group, out_column_names, out_column_types) then QUIVER_REQUIRE(out_column_data, out_column_count, out_row_count) — split into two calls because 9 args exceeds 6-arg macro (even with the extension, splitting is cleaner for readability)
2. Get metadata for column ordering (schema definition order per locked decision)
3. Call `db->db.read_time_series_group(collection, group, id)`
4. If empty: set all 5 out-params to NULL/0, return QUIVER_OK
5. Build column list from metadata: dimension column first (always STRING/DATE_TIME type), then value_columns in metadata order (using `to_c_data_type`)
6. Allocate outer arrays: `column_names = new char*[col_count]`, `column_types = new int[col_count]`, `column_data = new void*[col_count]`
7. Initialize all `column_data[i]` to nullptr (for leak-safe cleanup on exception)
8. Wrap per-column allocation in try/catch. For each column:
   - Set `column_names[c] = strdup_safe(name)`, `column_types[c] = type`
   - INTEGER: `new int64_t[row_count]`, fill from rows (handle both int64_t and double variants with static_cast)
   - FLOAT: `new double[row_count]`, fill from rows (handle both double and int64_t variants with static_cast)
   - STRING/DATE_TIME: `new char*[row_count]`, fill with `strdup_safe(get<string>(...))`
9. On exception in allocation loop: call the free function on partially allocated results, then rethrow
10. Set out-params and return QUIVER_OK

**Free implementation flow:**
1. If column_names is NULL and column_data is NULL (empty result), return QUIVER_OK early — do NOT call QUIVER_REQUIRE on all params (empty results have NULL pointers)
2. Free column_names: `for each delete[] column_names[i]; delete[] column_names`
3. Free column_data based on column_types[i]: INTEGER -> `delete[] (int64_t*)`, FLOAT -> `delete[] (double*)`, STRING/DATE_TIME -> `for each delete[] strings[j]; delete[] strings`
4. `delete[] column_data`
5. `delete[] column_types`
6. Return QUIVER_OK

Add a local helper `static const char* c_type_name(int type)` at the top of database_time_series.cpp that maps QUIVER_DATA_TYPE_INTEGER -> "INTEGER", FLOAT -> "FLOAT", STRING -> "STRING", DATE_TIME -> "DATE_TIME", default -> "UNKNOWN". Used for error messages in validation.

The project builds with: `cmake --build build --config Debug`
  </action>
  <verify>
Run `cmake --build build --config Debug` — build must succeed with no errors. Verify that the header contains the new signatures (search for `column_names` in database.h). Verify that the old `date_times` / `double* values` parameters are completely gone from both header and implementation for the three replaced functions.
  </verify>
  <done>
C API header has new multi-column signatures for update, read, and free. Implementation handles columnar-to-row conversion, row-to-columnar conversion, type-aware deallocation, schema validation with correct error messages, and DATE_TIME/STRING interchangeability. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` succeeds with no compilation errors
2. `include/quiver/c/database.h` contains `column_names`, `column_types`, `column_data` parameters in all three time series functions
3. `src/c/database_time_series.cpp` contains schema validation with dimension column check and type mismatch check
4. `tests/schemas/valid/mixed_time_series.sql` exists with Sensor_time_series_readings table containing temperature REAL, humidity INTEGER, status TEXT columns
5. `src/c/internal.h` contains QUIVER_REQUIRE_9 macro definition
6. Old signatures (`date_times`, `double* values` for update; `out_date_times`, `double** out_values` for read) are completely removed
</verification>

<success_criteria>
- Build compiles cleanly with new multi-column C API signatures
- Header declarations match implementation signatures exactly
- Schema validation produces error messages matching the locked decision patterns
- Mixed-type test schema covers INTEGER, REAL, and TEXT value column types
- QUIVER_REQUIRE macro supports up to 9 arguments
- No old single-column time series function signatures remain
</success_criteria>

<output>
After completion, create `.planning/phases/11-c-api-multi-column-time-series/11-01-SUMMARY.md`
</output>
