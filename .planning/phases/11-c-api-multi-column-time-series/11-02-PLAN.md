---
phase: 11-c-api-multi-column-time-series
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - tests/test_c_api_database_time_series.cpp
autonomous: true
requirements: [CAPI-01, CAPI-02, CAPI-03, CAPI-04, CAPI-05, MIGR-01]
must_haves:
  truths:
    - "C API tests exercise multi-column update with mixed types (INTEGER + REAL + TEXT) and verify correct round-trip"
    - "C API tests verify read returns columns in schema definition order with correct types per column"
    - "C API tests verify free function correctly deallocates without leaks for all column type combinations"
    - "C API tests verify validation errors for unknown columns, type mismatches, and missing dimension column"
    - "C API tests verify empty result handling (NULL pointers with count 0)"
    - "C API tests verify clear operation (column_count=0, row_count=0)"
    - "All existing C++ tests and non-time-series C API tests continue to pass"
  artifacts:
    - path: "tests/test_c_api_database_time_series.cpp"
      provides: "Complete C API test coverage for multi-column time series"
      min_lines: 300
  key_links:
    - from: "tests/test_c_api_database_time_series.cpp"
      to: "include/quiver/c/database.h"
      via: "tests call the new multi-column function signatures"
      pattern: "quiver_database_update_time_series_group.*column_names"
    - from: "tests/test_c_api_database_time_series.cpp"
      to: "tests/schemas/valid/mixed_time_series.sql"
      via: "tests use mixed-type schema for multi-column tests"
      pattern: "mixed_time_series.sql"
---

<objective>
Rewrite all C API time series tests to use the new multi-column signatures and add comprehensive tests for mixed-type schemas, validation errors, and edge cases.

Purpose: Verify that the new multi-column C API functions correctly handle update, read, free, validation, empty results, and clear operations across both single-column and mixed-type multi-column schemas. This is the test gate that proves Phase 11 requirements are met.

Output: Fully rewritten `test_c_api_database_time_series.cpp` with all tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-c-api-multi-column-time-series/11-CONTEXT.md
@.planning/phases/11-c-api-multi-column-time-series/11-RESEARCH.md
@.planning/phases/11-c-api-multi-column-time-series/11-01-SUMMARY.md

@include/quiver/c/database.h
@src/c/database_time_series.cpp
@tests/test_c_api_database_time_series.cpp
@tests/schemas/valid/collections.sql
@tests/schemas/valid/mixed_time_series.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite existing time series tests for new multi-column signatures</name>
  <files>tests/test_c_api_database_time_series.cpp</files>
  <action>
Rewrite `tests/test_c_api_database_time_series.cpp` to use the new multi-column function signatures. The file has several test sections -- time series metadata tests, time series files tests, and time series read/update tests. **Only the read/update/free tests change.** Metadata and files tests stay unchanged (those functions have the same signatures).

**Rewrite these existing tests to use new signatures:**

1. **ReadTimeSeriesGroupById** — Update to use new multi-column signatures. The `collections.sql` schema has a single value column (date_time TEXT, value REAL). Set up columnar arrays for update:
   ```cpp
   const char* col_names[] = {"date_time", "value"};
   int col_types[] = {QUIVER_DATA_TYPE_STRING, QUIVER_DATA_TYPE_FLOAT};
   const char* date_times[] = {"2024-01-01T10:00:00", "2024-01-01T11:00:00", "2024-01-01T12:00:00"};
   double values[] = {1.5, 2.5, 3.5};
   const void* col_data[] = {(const void*)date_times, (const void*)values};
   ```
   Call `quiver_database_update_time_series_group(db, "Collection", "data", id, col_names, col_types, col_data, 2, 3)`.
   For read, use the new out-parameters: `char** out_col_names`, `int* out_col_types`, `void** out_col_data`, `size_t out_col_count`, `size_t out_row_count`.
   After read, verify: `out_col_count == 2`, columns are in schema order (date_time first, value second), types match, data values match. Free with `quiver_database_free_time_series_data(out_col_names, out_col_types, out_col_data, out_col_count, out_row_count)`.

2. **ReadTimeSeriesGroupByIdEmpty** — Same setup minus the update. Read should return all NULL/0. No free call needed for empty results.

3. **UpdateTimeSeriesGroup** — Update with initial data, then replace with new data. Verify replacement worked via read. Use columnar arrays for both updates.

4. **UpdateTimeSeriesGroupClear** — Insert data, then clear with `(db, collection, group, id, nullptr, nullptr, nullptr, 0, 0)`. Verify empty after clear.

5. **TimeSeriesNullArguments** — Update null-argument tests for the new signatures. Test null db, null collection, null group for both read and update. For read, test null out-params.

**Important pattern for accessing read results:**
```cpp
// After read succeeds with out_col_count columns and out_row_count rows:
// Column at index c has type out_col_types[c]
// For STRING/DATE_TIME: char** strings = (char**)out_col_data[c]; strings[r] is row r
// For FLOAT: double* floats = (double*)out_col_data[c]; floats[r] is row r
// For INTEGER: int64_t* ints = (int64_t*)out_col_data[c]; ints[r] is row r
```
  </action>
  <verify>
Run `cmake --build build --config Debug && ./build/bin/quiver_c_tests.exe --gtest_filter="DatabaseCApi.*TimeSeries*"` — all rewritten time series tests pass.
  </verify>
  <done>
All existing time series tests converted to new multi-column signatures and passing. Single-column schema (collections.sql) works correctly through the new multi-column interface.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add multi-column and validation error tests using mixed-type schema</name>
  <files>tests/test_c_api_database_time_series.cpp</files>
  <action>
Add new tests to `tests/test_c_api_database_time_series.cpp` that exercise the mixed-type schema and validation logic. Add these tests after the existing rewritten tests:

**Multi-column round-trip tests (using `mixed_time_series.sql`):**

1. **ReadTimeSeriesGroupMultiColumn** — Full round-trip with 4 columns (date_time TEXT, temperature REAL, humidity INTEGER, status TEXT):
   ```cpp
   const char* col_names[] = {"date_time", "temperature", "humidity", "status"};
   int col_types[] = {QUIVER_DATA_TYPE_STRING, QUIVER_DATA_TYPE_FLOAT, QUIVER_DATA_TYPE_INTEGER, QUIVER_DATA_TYPE_STRING};
   const char* dts[] = {"2024-01-01T10:00:00", "2024-01-01T11:00:00"};
   double temps[] = {20.5, 21.0};
   int64_t humids[] = {65, 70};
   const char* stats[] = {"ok", "warn"};
   const void* col_data[] = {dts, temps, humids, stats};
   ```
   After update, read back and verify: out_col_count == 4, columns in schema order (date_time, temperature, humidity, status), types match (STRING, FLOAT, INTEGER, STRING), values match. Cast and compare each column's data array.

2. **UpdateTimeSeriesGroupPartialColumns** — Update with only dimension + a subset of value columns. Use `mixed_time_series.sql` but pass only `{date_time, temperature}` (omitting humidity and status). This tests the locked decision that partial column updates are allowed (only dimension is mandatory). Per the C++ layer behavior, this should succeed — the C++ layer handles partial columns in its `update_time_series_group` method.

3. **UpdateTimeSeriesGroupColumnOrderIndependent** — Pass columns in a different order than schema definition (e.g., status, date_time, temperature, humidity). Verify update succeeds and read returns columns in schema definition order regardless. This validates that update is order-agnostic but read output is schema-ordered.

**Validation error tests:**

4. **UpdateTimeSeriesGroupMissingDimension** — Try to update with only value columns (no date_time). Expect QUIVER_ERROR. Check `quiver_get_last_error()` contains `"Cannot update_time_series_group: dimension column 'date_time' missing from column_names"`.

5. **UpdateTimeSeriesGroupUnknownColumn** — Include a column name not in the schema (e.g., "pressure"). Expect QUIVER_ERROR. Check error message contains `"Cannot update_time_series_group: column 'pressure' not found in group"`.

6. **UpdateTimeSeriesGroupTypeMismatch** — Pass INTEGER type for a REAL column (or vice versa). Expect QUIVER_ERROR. Check error message contains `"Cannot update_time_series_group: column"` and `"has type"` and `"but received"`.

7. **UpdateTimeSeriesGroupDateTimeStringInterchangeable** — Pass QUIVER_DATA_TYPE_DATE_TIME for the dimension column (instead of STRING). Verify this succeeds — DATE_TIME and STRING are interchangeable per locked decision.

**Edge case tests:**

8. **ReadTimeSeriesGroupMultiColumnEmpty** — Read from mixed_time_series.sql without inserting data. Verify all out-params are NULL/0.

9. **FreeTimeSeriesDataNull** — Call free with all NULLs and 0 counts. Verify it returns QUIVER_OK without crashing (matches empty result convention).

**All tests must follow the existing test fixture pattern:**
- Create options with `quiver_database_options_default()`, set `console_level = QUIVER_LOG_OFF`
- Use `quiver_database_from_schema(":memory:", VALID_SCHEMA("mixed_time_series.sql").c_str(), ...)`
- Create Configuration element first (required by schema)
- Create Sensor element
- Clean up with `quiver_database_close`

Run the full test suite to confirm no regressions: `./build/bin/quiver_c_tests.exe` (all tests) and `./build/bin/quiver_tests.exe` (C++ tests unchanged).
  </action>
  <verify>
Run `cmake --build build --config Debug && ./build/bin/quiver_c_tests.exe` — ALL C API tests pass (not just time series). Then run `./build/bin/quiver_tests.exe` — all C++ tests pass (no regressions). Report total test counts for both suites.
  </verify>
  <done>
Full test coverage for multi-column time series: mixed-type round-trip, partial columns, column order independence, schema validation errors (missing dimension, unknown column, type mismatch), DATE_TIME/STRING interchangeability, empty results, and null free. All C API and C++ tests pass with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` succeeds
2. `./build/bin/quiver_c_tests.exe` — all tests pass, including all new and rewritten time series tests
3. `./build/bin/quiver_tests.exe` — all C++ tests pass (no regressions from header changes)
4. Multi-column update + read round-trip verified with mixed types (INTEGER, REAL, TEXT)
5. Validation errors produce correct messages for: missing dimension column, unknown column name, type mismatch
6. DATE_TIME and STRING accepted interchangeably for dimension column
7. Empty result and clear operations work correctly
8. Free function handles all column types without leaks
</verification>

<success_criteria>
- All C API tests pass (existing + new multi-column tests)
- All C++ tests pass (no regressions)
- Multi-column round-trip with mixed types verified
- Schema validation errors tested with correct error messages
- Edge cases (empty, clear, null free, partial columns) all covered
</success_criteria>

<output>
After completion, create `.planning/phases/11-c-api-multi-column-time-series/11-02-SUMMARY.md`
</output>
