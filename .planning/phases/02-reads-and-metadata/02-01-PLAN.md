---
phase: 02-reads-and-metadata
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/python/src/quiver/_c_api.py
  - bindings/python/src/quiver/metadata.py
  - bindings/python/src/quiver/database.py
  - bindings/python/src/quiver/__init__.py
  - bindings/python/tests/conftest.py
  - bindings/python/tests/test_database_read_scalar.py
autonomous: true
requirements: [READ-01, READ-02, READ-07, READ-08]
must_haves:
  truths:
    - "read_scalar_integers returns a list of ints from all elements in a collection"
    - "read_scalar_float_by_id returns a float or None for absent values"
    - "read_scalar_string_by_id returns None for NULL strings and '' for empty strings"
    - "read_element_ids returns a list of all element IDs in a collection"
    - "read_scalar_relation returns list with int|None per element, mapping NULL/empty to None"
    - "All C-allocated memory is freed via try/finally even when marshaling fails"
  artifacts:
    - path: "bindings/python/src/quiver/_c_api.py"
      provides: "CFFI declarations for all read, metadata, and free C API functions"
      contains: "quiver_database_read_scalar_integers"
    - path: "bindings/python/src/quiver/metadata.py"
      provides: "ScalarMetadata and GroupMetadata frozen dataclasses"
      contains: "@dataclass(frozen=True)"
    - path: "bindings/python/src/quiver/database.py"
      provides: "Scalar read methods, element ID reads, relation reads, create_element helper"
      contains: "def read_scalar_integers"
    - path: "bindings/python/tests/test_database_read_scalar.py"
      provides: "Tests for scalar reads, by-id reads, element IDs, relation reads"
      contains: "def test_read_scalar_integers"
  key_links:
    - from: "bindings/python/src/quiver/database.py"
      to: "C API via get_lib()"
      via: "check(lib.quiver_database_read_scalar_integers(...))"
      pattern: "quiver_database_free_integer_array"
    - from: "bindings/python/tests/test_database_read_scalar.py"
      to: "bindings/python/src/quiver/database.py"
      via: "db.read_scalar_integers() calls in test assertions"
      pattern: "read_scalar_integers"
---

<objective>
Add all CFFI declarations for Phase 2 read/metadata/free functions, create ScalarMetadata and GroupMetadata dataclasses, implement scalar read operations (bulk, by-id, element IDs, relations), and verify with comprehensive tests.

Purpose: Establishes the read infrastructure (declarations, dataclasses, test fixtures, create_element helper) that all subsequent read and metadata plans depend on. Scalar reads are the simplest read pattern and validate the try/finally free approach.

Output: Working scalar read methods on Database class with passing tests covering integers, floats, strings, nulls, element IDs, and relations.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/02-reads-and-metadata/02-RESEARCH.md
@bindings/python/src/quiver/_c_api.py
@bindings/python/src/quiver/_helpers.py
@bindings/python/src/quiver/database.py
@bindings/python/src/quiver/__init__.py
@bindings/python/tests/conftest.py
@bindings/julia/src/database_read.jl
@bindings/julia/src/database_metadata.jl
@include/quiver/c/database.h
@tests/schemas/valid/basic.sql
@tests/schemas/valid/collections.sql
@tests/schemas/valid/relations.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: CFFI declarations, metadata dataclasses, create_element helper, test fixtures</name>
  <files>
    bindings/python/src/quiver/_c_api.py
    bindings/python/src/quiver/metadata.py
    bindings/python/src/quiver/database.py
    bindings/python/src/quiver/__init__.py
    bindings/python/tests/conftest.py
  </files>
  <action>
**1. Extend _c_api.py** with ALL read, metadata, and free function declarations needed for the entire Phase 2.

Add to the existing `ffi.cdef()` call (before the closing `"""`), organized in sections:

```
// Data type enum
typedef enum {
    QUIVER_DATA_TYPE_INTEGER = 0,
    QUIVER_DATA_TYPE_FLOAT = 1,
    QUIVER_DATA_TYPE_STRING = 2,
    QUIVER_DATA_TYPE_DATE_TIME = 3,
    QUIVER_DATA_TYPE_NULL = 4,
} quiver_data_type_t;
```

Then add ALL declarations from the 02-RESEARCH.md "CFFI Declarations to Add" section verbatim. This includes:
- Read scalar (bulk + by-id) for int/float/string
- Read vector (bulk + by-id) for int/float/string
- Read set (bulk + by-id) for int/float/string
- Read element IDs
- Read scalar relation
- All free functions (arrays, vectors, string arrays)
- Metadata struct definitions (quiver_scalar_metadata_t, quiver_group_metadata_t)
- Metadata query functions (get_scalar/vector/set/time_series_metadata)
- Metadata free functions
- Metadata list functions (list_scalar_attributes, list_vector/set/time_series_groups)
- Metadata array free functions

Use `int*` for boolean out-parameters (not `_Bool*`). Use `quiver_error_t` return type for all free functions (they return error codes, not void).

**2. Create metadata.py** with frozen dataclasses:

```python
from __future__ import annotations
from dataclasses import dataclass

@dataclass(frozen=True)
class ScalarMetadata:
    """Metadata for a scalar attribute in a collection."""
    name: str
    data_type: int
    not_null: bool
    primary_key: bool
    default_value: str | None
    is_foreign_key: bool
    references_collection: str | None
    references_column: str | None

@dataclass(frozen=True)
class GroupMetadata:
    """Metadata for a vector, set, or time series group in a collection."""
    group_name: str
    dimension_column: str  # empty string for vector/set groups
    value_columns: list[ScalarMetadata]
```

Field names match C struct exactly per user decision. `data_type` stored as `int` (matching Julia/Dart raw C enum value).

**3. Add minimal create_element()** to database.py so tests can insert data:

```python
def create_element(self, collection: str, element) -> int:
    """Create a new element. Returns the new element ID."""
    self._ensure_open()
    lib = get_lib()
    out_id = ffi.new("int64_t*")
    check(lib.quiver_database_create_element(
        self._ptr, collection.encode("utf-8"), element._ptr, out_id,
    ))
    return out_id[0]
```

This uses the existing cdef declaration from Phase 1. Phase 3 (WRITE-01) will validate/enhance.

**4. Update __init__.py** to export ScalarMetadata and GroupMetadata:

```python
from quiver.metadata import ScalarMetadata, GroupMetadata
```

Add both to `__all__`.

**5. Update conftest.py** with new fixtures:

```python
@pytest.fixture
def collections_schema_path(schemas_path: Path) -> Path:
    return schemas_path / "valid" / "collections.sql"

@pytest.fixture
def relations_schema_path(schemas_path: Path) -> Path:
    return schemas_path / "valid" / "relations.sql"

@pytest.fixture
def collections_db(collections_schema_path: Path, tmp_path: Path) -> Generator[Database, None, None]:
    database = Database.from_schema(str(tmp_path / "collections.db"), str(collections_schema_path))
    yield database
    database.close()

@pytest.fixture
def relations_db(relations_schema_path: Path, tmp_path: Path) -> Generator[Database, None, None]:
    database = Database.from_schema(str(tmp_path / "relations.db"), str(relations_schema_path))
    yield database
    database.close()
```

Also add `from quiver import Element` import to conftest.py for use in test data creation.
  </action>
  <verify>
Run `cd C:/Development/DatabaseTmp/quiver && python -c "from quiver import Database, Element, ScalarMetadata, GroupMetadata; print('imports OK')"` to confirm all imports work without errors.

Run existing tests: `cd C:/Development/DatabaseTmp/quiver/bindings/python && python -m pytest tests/test_database_lifecycle.py tests/test_element.py -v` to confirm no regressions.
  </verify>
  <done>
- _c_api.py contains CFFI declarations for all 30+ read functions, 10+ metadata functions, and all free functions
- metadata.py defines frozen ScalarMetadata and GroupMetadata dataclasses with correct field names
- database.py has create_element() method
- __init__.py exports ScalarMetadata and GroupMetadata
- conftest.py has collections_db and relations_db fixtures
- All existing Phase 1 tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Scalar read methods, element ID reads, relation reads, and tests</name>
  <files>
    bindings/python/src/quiver/database.py
    bindings/python/tests/test_database_read_scalar.py
  </files>
  <action>
**1. Add scalar read methods to Database class** in database.py. Follow the patterns from 02-RESEARCH.md exactly.

**Bulk scalar reads** (READ-01): `read_scalar_integers`, `read_scalar_floats`, `read_scalar_strings`
- Pattern: allocate out_values + out_count via ffi.new, call C API via check(), early return `[]` for count==0 or NULL, copy to Python list in try block, free in finally block.
- `read_scalar_strings` returns `list[str | None]` -- check each pointer for NULL, append None for NULL pointers.
- `read_scalar_integers` returns `list[int]`, `read_scalar_floats` returns `list[float]`.
- Free via `quiver_database_free_integer_array`, `quiver_database_free_float_array`, `quiver_database_free_string_array`.

**Scalar by-ID reads** (READ-02): `read_scalar_integer_by_id`, `read_scalar_float_by_id`, `read_scalar_string_by_id`
- Pattern: allocate out_value + out_has_value via ffi.new, call C API, return None if out_has[0]==0.
- `read_scalar_string_by_id`: if has_value, wrap decode + free in try/finally with `quiver_element_free_string`. Return None for no-value.
- Parameter order: `(self, collection: str, attribute: str, id: int)` -- match the C API parameter order where collection and attribute come before id.

Wait -- check the C API signature order. The C API is: `quiver_database_read_scalar_integer_by_id(db, collection, attribute, id, out_value, out_has_value)`. So Python method signature should be `(self, collection, attribute, id)` matching the Julia binding order.

**Element ID reads** (READ-07): `read_element_ids`
- Pattern: same as read_scalar_integers but only takes collection parameter.
- `read_element_ids(self, collection: str) -> list[int]`
- Free with `quiver_database_free_integer_array`.

**Relation reads** (READ-08): `read_scalar_relation`
- Returns `list[int | None]` -- per user decision, nullable foreign keys use None.
- C API returns string array (char***). Each string is a label of the related element. BUT looking at the Julia code more carefully, `read_scalar_relation` returns `Union{String, Nothing}[]` -- it returns labels (strings), not IDs!
- Correction: `read_scalar_relation` returns `list[str | None]`. Check both NULL pointer AND empty string -- map both to None (per research pitfall 3). The Julia code does `isempty(s) ? nothing : s`.
- Free with `quiver_database_free_string_array`.

**2. Write test_database_read_scalar.py** with comprehensive tests.

Use the `db` fixture (basic.sql schema with Configuration table) for scalar reads.
Use `relations_db` fixture for relation reads.

Test data setup: In each test (or a module-scoped fixture), use `db.create_element("Configuration", Element().set("label", "item1").set("integer_attribute", 42).set("float_attribute", 3.14).set("string_attribute", "hello"))` to insert test data.

Test cases:
- `test_read_scalar_integers`: Insert 2+ elements, read integer_attribute, verify list matches inserted values
- `test_read_scalar_floats`: Insert elements, read float_attribute, verify float values
- `test_read_scalar_strings`: Insert elements with and without string_attribute, verify list with None entries
- `test_read_scalar_strings_empty_collection`: Read from empty collection, verify returns empty list
- `test_read_scalar_integer_by_id`: Insert element, read by its ID, verify correct value
- `test_read_scalar_integer_by_id_null`: Insert element without setting integer_attribute (use the default), verify returns value or None appropriately
- `test_read_scalar_float_by_id`: Similar for float
- `test_read_scalar_float_by_id_null`: Float that is NULL returns None
- `test_read_scalar_string_by_id`: Read a string by ID, verify correct string
- `test_read_scalar_string_by_id_null`: NULL string returns None
- `test_read_element_ids`: Insert elements, verify IDs returned
- `test_read_element_ids_empty`: Empty collection returns empty list
- `test_read_scalar_relation`: Using relations.sql, create Parent and Child elements, set parent_id relation, read scalar relation and verify labels (Note: test will need to use the relations_db fixture and create parent/child elements with proper FK setup. If setting FK directly via create_element is tricky, use integer_attribute approach or test with what's feasible given create_element only.)

For the relation test, create a Parent with label "P1", then a Child with label "C1" and parent_id set to 1 (the Parent's ID). Then `read_scalar_relation("Child", "parent_id")` should return a list of related element labels.

Note: Since `read_scalar_relation` returns string labels from the C API, the test asserts string labels, not integer IDs.
  </action>
  <verify>
Run: `cd C:/Development/DatabaseTmp/quiver/bindings/python && python -m pytest tests/test_database_read_scalar.py -v`

All tests must pass with no memory warnings or segfaults.

Also run: `python -m pytest tests/ -v` to verify no regressions across all test files.
  </verify>
  <done>
- Database class has read_scalar_integers, read_scalar_floats, read_scalar_strings (bulk reads)
- Database class has read_scalar_integer_by_id, read_scalar_float_by_id, read_scalar_string_by_id (by-id reads)
- Database class has read_element_ids (element ID listing)
- Database class has read_scalar_relation (relation reads returning labels or None)
- All methods use try/finally for C memory cleanup
- test_database_read_scalar.py has 10+ tests covering all scalar read variants, null handling, empty collections
  </done>
</task>

</tasks>

<verification>
1. Run full Python test suite: `cd C:/Development/DatabaseTmp/quiver/bindings/python && python -m pytest tests/ -v` -- all tests pass
2. Verify imports: `python -c "from quiver import Database, Element, ScalarMetadata, GroupMetadata; print('OK')"`
3. Spot-check memory: Run tests under `-W error::ResourceWarning` to catch any unclosed handles
</verification>

<success_criteria>
- All CFFI declarations for Phase 2 are present in _c_api.py (30+ read functions, 10+ metadata functions, all free functions)
- ScalarMetadata and GroupMetadata frozen dataclasses exist in metadata.py and are exported from quiver package
- Database.create_element() works for test data insertion
- All 9 scalar/by-id read methods + read_element_ids + read_scalar_relation are implemented on Database
- Every read method uses try/finally to free C-allocated memory
- test_database_read_scalar.py passes with 10+ tests
- No regressions in Phase 1 tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-reads-and-metadata/02-01-SUMMARY.md`
</output>
