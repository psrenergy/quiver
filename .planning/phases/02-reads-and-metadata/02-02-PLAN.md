---
phase: 02-reads-and-metadata
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - bindings/python/src/quiver/database.py
  - bindings/python/tests/test_database_read_vector.py
  - bindings/python/tests/test_database_read_set.py
  - bindings/python/tests/test_database_metadata.py
autonomous: true
requirements: [READ-03, READ-04, READ-05, READ-06, META-01, META-02, META-03]
must_haves:
  truths:
    - "read_vector_integers returns a list of lists of ints (one list per element in the collection)"
    - "read_vector_strings_by_id returns a list of strings for one element's vector attribute"
    - "read_set_strings_by_id returns a list (not set) of strings per user decision"
    - "get_scalar_metadata returns a frozen ScalarMetadata dataclass with correct field values"
    - "get_vector_metadata returns a GroupMetadata with nested list[ScalarMetadata] value_columns"
    - "list_scalar_attributes returns list[ScalarMetadata] (full metadata objects, not just names)"
    - "Empty vectors/sets return empty list, not None"
  artifacts:
    - path: "bindings/python/src/quiver/database.py"
      provides: "Vector, set, and metadata read methods"
      contains: "def read_vector_integers"
    - path: "bindings/python/tests/test_database_read_vector.py"
      provides: "Tests for vector bulk and by-id reads"
      contains: "def test_read_vector_integers"
    - path: "bindings/python/tests/test_database_read_set.py"
      provides: "Tests for set bulk and by-id reads"
      contains: "def test_read_set"
    - path: "bindings/python/tests/test_database_metadata.py"
      provides: "Tests for metadata get and list operations"
      contains: "def test_get_scalar_metadata"
  key_links:
    - from: "bindings/python/src/quiver/database.py"
      to: "C API via get_lib()"
      via: "check(lib.quiver_database_read_vector_integers(...))"
      pattern: "quiver_database_free_integer_vectors"
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/metadata.py"
      via: "_parse_scalar_metadata and _parse_group_metadata helpers"
      pattern: "ScalarMetadata\\("
---

<objective>
Implement vector/set read operations (bulk and by-id) and all metadata query operations (get, list) on the Database class, with comprehensive tests for each.

Purpose: Completes the Phase 2 read surface. Vector/set reads involve more complex memory patterns (nested arrays via triple/quadruple pointers). Metadata queries introduce struct parsing into frozen dataclasses with nested composition.

Output: Fully functional vector, set, and metadata read methods with passing tests covering integers, floats, strings, empty collections, by-id access, and metadata field validation.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-reads-and-metadata/02-RESEARCH.md
@.planning/phases/02-reads-and-metadata/02-01-SUMMARY.md
@bindings/python/src/quiver/_c_api.py
@bindings/python/src/quiver/_helpers.py
@bindings/python/src/quiver/database.py
@bindings/python/src/quiver/metadata.py
@bindings/python/tests/conftest.py
@bindings/julia/src/database_read.jl
@bindings/julia/src/database_metadata.jl
@tests/schemas/valid/collections.sql
@tests/schemas/valid/basic.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Vector and set read methods with tests</name>
  <files>
    bindings/python/src/quiver/database.py
    bindings/python/tests/test_database_read_vector.py
    bindings/python/tests/test_database_read_set.py
  </files>
  <action>
**1. Add vector bulk read methods** (READ-03) to database.py: `read_vector_integers`, `read_vector_floats`, `read_vector_strings`

Follow Pattern 4 (Bulk Nested Array Read) from 02-RESEARCH.md:
- Allocate triple-pointer + sizes array + count via ffi.new
- For integers: `out_vectors = ffi.new("int64_t***")`, `out_sizes = ffi.new("size_t**")`, `out_count = ffi.new("size_t*")`
- For strings: `out_vectors = ffi.new("char****")` (quadruple pointer for bulk string vectors)
- Call C API, check for empty/NULL, iterate outer array building list of lists
- For each inner array: check for NULL/zero-size, build inner list
- For string inner arrays: `ffi.string(out_vectors[0][i][j]).decode("utf-8")` for each string
- Free in finally block: `quiver_database_free_integer_vectors`, `quiver_database_free_float_vectors`, `quiver_database_free_string_vectors`
- Return type: `list[list[int]]`, `list[list[float]]`, `list[list[str]]`

**2. Add vector by-id read methods** (READ-04): `read_vector_integers_by_id`, `read_vector_floats_by_id`, `read_vector_strings_by_id`

Same pattern as bulk scalar reads but returns a flat list for one element:
- `out_values = ffi.new("int64_t**")`, `out_count = ffi.new("size_t*")`
- For strings: `out_values = ffi.new("char***")`, free with `quiver_database_free_string_array`
- Return type: `list[int]`, `list[float]`, `list[str]`
- Empty vector returns `[]` (not None) per user decision
- Parameter order: `(self, collection: str, attribute: str, id: int)`

**3. Add set bulk read methods** (READ-05): `read_set_integers`, `read_set_floats`, `read_set_strings`

Identical structure to vector bulk reads. Same triple/quadruple pointer patterns. Same free functions (`quiver_database_free_integer_vectors`, `quiver_database_free_float_vectors`, `quiver_database_free_string_vectors`).
Return `list[list[int]]`, `list[list[float]]`, `list[list[str]]` -- sets return list (not Python set) per user decision.

**4. Add set by-id read methods** (READ-06): `read_set_integers_by_id`, `read_set_floats_by_id`, `read_set_strings_by_id`

Same pattern as vector by-id. Same free functions. Return `list[int]`, `list[float]`, `list[str]`.

**5. Write test_database_read_vector.py** using `collections_db` fixture (collections.sql schema).

Test data setup: Use `create_element` to insert Collection elements with vector data:
```python
elem = Element().set("label", "item1").set("some_integer", 10).set("some_float", 1.5)
id1 = db.create_element("Collection", elem)
```
Then insert vector values. NOTE: The vector table `Collection_vector_values` has columns `value_int` (INTEGER) and `value_float` (REAL). These are multi-column vectors, not single-value. So `read_vector_integers_by_id(collection, "value_int", id)` reads the integer column of the vector group.

However, since we don't have `update_vector_*` yet (Phase 3), test data insertion for vectors requires either:
- Using `create_element` with array values if the Element builder supports it (it does -- `Element().set("value_int", [1, 2, 3])`)
- Or using raw SQL

The Element builder from Phase 1 supports `set(name, list[int])` which calls `quiver_element_set_array_integer`. When `create_element` is called, the C++ layer should handle inserting the array into the vector table.

Test cases:
- `test_read_vector_integers_by_id`: Create element with integer vector, read back, verify values
- `test_read_vector_floats_by_id`: Create element with float vector, read back, verify values
- `test_read_vector_integers_by_id_empty`: Element with no vector data returns `[]`
- `test_read_vector_integers`: Bulk read across multiple elements, verify list of lists
- `test_read_vector_integers_empty_collection`: Empty collection returns `[]`

**6. Write test_database_read_set.py** using `collections_db` fixture.

The set table `Collection_set_tags` has column `tag` (TEXT). So read via `read_set_strings_by_id("Collection", "tag", id)`.

Test cases:
- `test_read_set_strings_by_id`: Create element with set values, read back, verify values
- `test_read_set_strings_by_id_empty`: Element with no set data returns `[]`
- `test_read_set_strings`: Bulk read across multiple elements
- `test_read_set_strings_empty_collection`: Empty collection returns `[]`

Set data insertion: `Element().set("tag", ["alpha", "beta"])` should work via `quiver_element_set_array_string`.
  </action>
  <verify>
Run: `cd C:/Development/DatabaseTmp/quiver/bindings/python && python -m pytest tests/test_database_read_vector.py tests/test_database_read_set.py -v`

All tests must pass. Then run full suite: `python -m pytest tests/ -v` for no regressions.
  </verify>
  <done>
- 6 vector read methods implemented (3 bulk + 3 by-id) with try/finally free patterns
- 6 set read methods implemented (3 bulk + 3 by-id) with try/finally free patterns
- test_database_read_vector.py has 5+ tests covering integer/float vectors, empty vectors, bulk reads
- test_database_read_set.py has 4+ tests covering string sets, empty sets, bulk reads
- All methods return list (not set) per user decision
- All existing tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Metadata get/list methods and tests</name>
  <files>
    bindings/python/src/quiver/database.py
    bindings/python/tests/test_database_metadata.py
  </files>
  <action>
**1. Add metadata parsing helpers** to database.py (module-level private functions):

```python
from quiver.metadata import ScalarMetadata, GroupMetadata
from quiver._helpers import decode_string, decode_string_or_none

def _parse_scalar_metadata(meta) -> ScalarMetadata:
    return ScalarMetadata(
        name=decode_string(meta.name),
        data_type=int(meta.data_type),
        not_null=bool(meta.not_null),
        primary_key=bool(meta.primary_key),
        default_value=decode_string_or_none(meta.default_value),
        is_foreign_key=bool(meta.is_foreign_key),
        references_collection=decode_string_or_none(meta.references_collection),
        references_column=decode_string_or_none(meta.references_column),
    )

def _parse_group_metadata(meta) -> GroupMetadata:
    value_columns = []
    for i in range(meta.value_column_count):
        value_columns.append(_parse_scalar_metadata(meta.value_columns[i]))
    return GroupMetadata(
        group_name=decode_string(meta.group_name),
        dimension_column="" if meta.dimension_column == ffi.NULL else decode_string(meta.dimension_column),
        value_columns=value_columns,
    )
```

**2. Add metadata get methods** (META-01, META-02) to Database class:

`get_scalar_metadata(self, collection: str, attribute: str) -> ScalarMetadata`
- Allocate `ffi.new("quiver_scalar_metadata_t*")`, call C API, parse to dataclass in try, free in finally
- Free via `quiver_database_free_scalar_metadata`

`get_vector_metadata(self, collection: str, group_name: str) -> GroupMetadata`
- Allocate `ffi.new("quiver_group_metadata_t*")`, call C API, parse to dataclass in try, free in finally
- Free via `quiver_database_free_group_metadata`
- Parse value_columns nested array before freeing

`get_set_metadata(self, collection: str, group_name: str) -> GroupMetadata` -- same as vector
`get_time_series_metadata(self, collection: str, group_name: str) -> GroupMetadata` -- same, but dimension_column will be non-empty

**3. Add metadata list methods** (META-03) to Database class:

`list_scalar_attributes(self, collection: str) -> list[ScalarMetadata]`
- Allocate `ffi.new("quiver_scalar_metadata_t**")` + `ffi.new("size_t*")`
- Call C API, check empty/NULL, iterate via pointer indexing `out_metadata[0][i]`, parse each, free array
- Free via `quiver_database_free_scalar_metadata_array`

`list_vector_groups(self, collection: str) -> list[GroupMetadata]`
- Allocate `ffi.new("quiver_group_metadata_t**")` + `ffi.new("size_t*")`
- Same pattern, parse each group metadata (including nested value_columns), free array
- Free via `quiver_database_free_group_metadata_array`

`list_set_groups(self, collection: str) -> list[GroupMetadata]` -- same as vector groups
`list_time_series_groups(self, collection: str) -> list[GroupMetadata]` -- same, dimension_column populated

**IMPORTANT:** Per research discretion recommendation, list functions return full metadata objects (`list[ScalarMetadata]` / `list[GroupMetadata]`), not just names. This matches Julia/Dart and enables Phase 6 convenience methods.

**4. Write test_database_metadata.py** using `db` fixture (basic.sql) and `collections_db` fixture (collections.sql).

Test cases:
- `test_get_scalar_metadata_integer`: Get metadata for integer_attribute in Configuration, verify name, data_type (0=INTEGER), not_null, etc.
- `test_get_scalar_metadata_string`: Get metadata for string_attribute, verify data_type (2=STRING)
- `test_get_scalar_metadata_nullable`: Verify is_nullable correctly reflects schema (string_attribute allows NULL)
- `test_get_scalar_metadata_with_default`: integer_attribute has DEFAULT 6, verify default_value field
- `test_get_vector_metadata`: Using collections_db, get vector metadata for "values" group, verify group_name, verify value_columns contains ScalarMetadata entries for value_int and value_float
- `test_get_set_metadata`: Using collections_db, get set metadata for "tags" group, verify group_name, verify value_columns contains ScalarMetadata for tag column
- `test_get_scalar_metadata_foreign_key`: Using relations_db fixture, get metadata for "parent_id" in Child, verify is_foreign_key=True, references_collection="Parent", references_column="id"
- `test_list_scalar_attributes`: List scalar attributes of Configuration (basic.sql), verify returns list of ScalarMetadata, verify attribute names include "label", "integer_attribute", etc.
- `test_list_vector_groups`: Using collections_db, list vector groups of Collection, verify returns list of GroupMetadata
- `test_list_set_groups`: Using collections_db, list set groups of Collection
- `test_list_time_series_groups`: Using collections_db, list time series groups of Collection
- `test_scalar_metadata_frozen`: Verify that ScalarMetadata is immutable (assigning a field raises FrozenInstanceError)
- `test_group_metadata_frozen`: Verify GroupMetadata is immutable
  </action>
  <verify>
Run: `cd C:/Development/DatabaseTmp/quiver/bindings/python && python -m pytest tests/test_database_metadata.py -v`

All tests must pass. Then run full suite: `python -m pytest tests/ -v` for no regressions.
  </verify>
  <done>
- _parse_scalar_metadata and _parse_group_metadata helpers correctly parse C structs to Python dataclasses
- 4 metadata get methods implemented: get_scalar_metadata, get_vector_metadata, get_set_metadata, get_time_series_metadata
- 4 metadata list methods implemented: list_scalar_attributes, list_vector_groups, list_set_groups, list_time_series_groups
- All metadata methods use try/finally for C memory cleanup
- test_database_metadata.py has 10+ tests covering get/list operations, field validation, FK metadata, frozen dataclass behavior
- All tests pass with no regressions
  </done>
</task>

</tasks>

<verification>
1. Run full Python test suite: `cd C:/Development/DatabaseTmp/quiver/bindings/python && python -m pytest tests/ -v` -- all tests pass
2. Verify vector/set return types are list (not set): `python -c "from quiver import Database; help(Database.read_set_strings_by_id)"` shows list return
3. Verify metadata objects are frozen: `python -c "from quiver import ScalarMetadata; m = ScalarMetadata('x', 0, False, False, None, False, None, None); m.name = 'y'"` raises FrozenInstanceError
4. Spot-check all Phase 2 read methods exist on Database: `python -c "from quiver import Database; methods = [m for m in dir(Database) if m.startswith('read_') or m.startswith('get_') or m.startswith('list_')]; print(sorted(methods))"`
</verification>

<success_criteria>
- 12 vector/set read methods implemented (6 vector + 6 set, bulk + by-id for each type)
- 4 metadata get methods + 4 metadata list methods implemented
- Metadata parsing correctly handles nested value_columns for GroupMetadata
- test_database_read_vector.py, test_database_read_set.py, test_database_metadata.py all pass
- Full Python test suite passes with zero failures
- No regressions from Phase 1 or Plan 01
</success_criteria>

<output>
After completion, create `.planning/phases/02-reads-and-metadata/02-02-SUMMARY.md`
</output>
