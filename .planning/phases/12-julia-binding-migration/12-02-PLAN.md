---
phase: 12-julia-binding-migration
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - bindings/julia/test/test_database_time_series.jl
autonomous: true
requirements: [BIND-01, BIND-02]

must_haves:
  truths:
    - "Julia tests pass for single-column time series using new kwargs interface"
    - "Julia tests pass for multi-column mixed-type time series (INTEGER + REAL + TEXT)"
    - "Julia tests verify DateTime parsing on dimension column"
    - "Julia tests verify auto-coercion of Int to Float for REAL columns"
    - "Julia tests verify clear operation (no kwargs)"
    - "Julia tests verify empty read returns Dict{String, Vector}()"
    - "All existing Julia tests still pass (no regressions)"
  artifacts:
    - path: "bindings/julia/test/test_database_time_series.jl"
      provides: "Rewritten time series tests using kwargs/Dict interface plus multi-column mixed-type tests"
      contains: "mixed_time_series"
  key_links:
    - from: "bindings/julia/test/test_database_time_series.jl"
      to: "bindings/julia/src/database_update.jl"
      via: "update_time_series_group! kwargs calls"
      pattern: "update_time_series_group!"
    - from: "bindings/julia/test/test_database_time_series.jl"
      to: "bindings/julia/src/database_read.jl"
      via: "read_time_series_group Dict return verification"
      pattern: "read_time_series_group"
    - from: "bindings/julia/test/test_database_time_series.jl"
      to: "tests/schemas/valid/mixed_time_series.sql"
      via: "multi-column test schema reference"
      pattern: "mixed_time_series"
---

<objective>
Rewrite all existing Julia time series tests to use the new kwargs/Dict interface and add comprehensive multi-column mixed-type tests.

Purpose: Verify the Julia binding migration works correctly for single-column schemas (existing tests migrated) and multi-column schemas (new tests), ensuring type correctness, DateTime handling, auto-coercion, and edge cases.

Output: Updated `test_database_time_series.jl` with all tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-julia-binding-migration/12-CONTEXT.md
@.planning/phases/12-julia-binding-migration/12-01-SUMMARY.md
@bindings/julia/test/test_database_time_series.jl
@bindings/julia/src/database_update.jl
@bindings/julia/src/database_read.jl
@tests/schemas/valid/mixed_time_series.sql
@tests/schemas/valid/collections.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite existing time series tests for kwargs/Dict interface</name>
  <files>bindings/julia/test/test_database_time_series.jl</files>
  <action>
Rewrite all existing time series group tests in `test_database_time_series.jl` to use the new kwargs/Dict interface. Keep all Time Series Files tests unchanged (they are not affected by this migration).

**Existing tests to rewrite (preserve same test semantics, change syntax):**

1. **"Read" test**: Replace `update_time_series_group!(db, col, grp, id, [Dict{String,Any}("date_time"=>"...", "value"=>1.5), ...])` with kwargs: `update_time_series_group!(db, "Collection", "data", id; date_time=["2024-01-01T10:00:00", "2024-01-01T11:00:00", "2024-01-01T12:00:00"], value=[1.5, 2.5, 3.5])`. Update read assertions: old `rows[1]["date_time"]` becomes `result["date_time"][1]` (now DateTime type from dimension column parsing). Old `rows[1]["value"]` becomes `result["value"][1]`. Assert `result["date_time"]` elements are `DateTime` type. Assert `result["value"]` is `Vector{Float64}`.

2. **"Read Empty" test**: Assert `read_time_series_group` returns `isempty(result)` where `result isa Dict{String, Vector}`.

3. **"Update" test**: Rewrite both update calls to use kwargs. Verify read returns correct Dict after replacement.

4. **"Update Clear" test**: Replace `update_time_series_group!(db, col, grp, id, Dict{String, Any}[])` with `update_time_series_group!(db, "Collection", "data", id)` (no kwargs = clear). Verify `isempty(result)`.

5. **"Ordering" test**: Rewrite with kwargs. Verify dimension column returns DateTimes in sorted order.

6. **"Metadata" and "Metadata Empty" tests**: These don't call update/read time series group directly -- keep unchanged.

**For all rewritten tests:**
- Use `using Dates` at top of module (it's already available via Quiver module)
- Dimension column values should be asserted as `DateTime` type (parsed from string)
- Value column values should be asserted as their native type (`Float64` for REAL schema)
- Use `Dates.DateTime("2024-01-01T10:00:00", dateformat"yyyy-mm-ddTHH:MM:SS")` for expected DateTime values in assertions
  </action>
  <verify>
    - No `Dict{String, Any}` patterns remain in time series group test calls (only in time series files tests which are unrelated)
    - All test assertions use Dict column access pattern `result["column_name"]` returning vectors
    - `DateTime` assertions present for dimension column values
    - Run Julia tests: `bindings/julia/test/test.bat` -- all time series tests pass
  </verify>
  <done>
    - All existing time series group tests rewritten to use kwargs syntax for update and Dict return for read
    - DateTime parsing verified on dimension column in read results
    - Clear operation uses no-kwargs syntax
    - All rewritten tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add multi-column mixed-type time series tests</name>
  <files>bindings/julia/test/test_database_time_series.jl</files>
  <action>
Add new test sections to `test_database_time_series.jl` using the `mixed_time_series.sql` schema from Phase 11. This schema has a `Sensor` collection with `Sensor_time_series_readings` table containing: `date_time TEXT` (dimension), `temperature REAL`, `humidity INTEGER`, `status TEXT`.

**New tests to add (inside the "Time Series" testset):**

1. **"Multi-Column Update and Read"**: Open mixed_time_series.sql schema. Create Configuration + Sensor element. Call:
   ```julia
   update_time_series_group!(db, "Sensor", "readings", id;
       date_time=[DateTime(2024,1,1,10,0,0), DateTime(2024,1,1,11,0,0)],
       temperature=[20.5, 21.3],
       humidity=[45, 50],
       status=["normal", "high"])
   ```
   Read back and verify:
   - `result["date_time"]` is `Vector{DateTime}` with correct values
   - `result["temperature"]` is `Vector{Float64}` with `[20.5, 21.3]`
   - `result["humidity"]` is `Vector{Int64}` with `[45, 50]`
   - `result["status"]` is `Vector{String}` with `["normal", "high"]`
   - `length(result) == 4` (4 columns)

2. **"Multi-Column Auto-Coercion Int to Float"**: Pass integer vector for temperature (REAL column):
   ```julia
   update_time_series_group!(db, "Sensor", "readings", id;
       date_time=["2024-01-01T10:00:00"],
       temperature=[20],  # Int, should auto-coerce to Float64
       humidity=[45],
       status=["normal"])
   ```
   Read back and verify `result["temperature"] == [20.0]` and `result["temperature"] isa Vector{Float64}`.

3. **"Multi-Column DateTime on Dimension"**: Pass DateTime objects for dimension column in update, verify they round-trip through string format and come back as DateTime on read.
   ```julia
   dt = DateTime(2024, 6, 15, 14, 30, 0)
   update_time_series_group!(db, "Sensor", "readings", id;
       date_time=[dt], temperature=[25.0], humidity=[60], status=["ok"])
   result = read_time_series_group(db, "Sensor", "readings", id)
   @test result["date_time"][1] == dt
   ```

4. **"Multi-Column String Dimension"**: Pass string values for dimension column (not DateTime), verify they come back parsed to DateTime on read.

5. **"Multi-Column Clear"**: Update with data, then call with no kwargs, verify empty Dict returned.

6. **"Multi-Column Replace"**: Update twice, verify second update fully replaces first.

7. **"Multi-Column Read Empty"**: Read without any update, verify empty Dict.

8. **"Multi-Column Row Count Mismatch"**: Pass vectors of different lengths, verify `ArgumentError` is thrown.
   ```julia
   @test_throws ArgumentError update_time_series_group!(db, "Sensor", "readings", id;
       date_time=["2024-01-01T10:00:00", "2024-01-01T11:00:00"],
       temperature=[20.5],  # length 1 vs length 2
       humidity=[45, 50],
       status=["normal", "high"])
   ```

**Important notes:**
- Use `using Dates` -- import DateTime constructor
- Schema path: `joinpath(tests_path(), "schemas", "valid", "mixed_time_series.sql")`
- Each test should create its own fresh `:memory:` database
- Remember to create Configuration element before Sensor element (schema requires it)
  </action>
  <verify>
    - Run Julia tests: `bindings/julia/test/test.bat` -- ALL tests pass (not just time series)
    - Multi-column tests cover: update+read, auto-coercion, DateTime, clear, replace, empty read, row count mismatch
    - Mixed types verified: Int64 for humidity, Float64 for temperature, String for status, DateTime for date_time
    - Run full test suite: `scripts/test-all.bat` to verify no cross-layer regressions
  </verify>
  <done>
    - Multi-column mixed-type tests added using mixed_time_series.sql schema
    - Auto-coercion (Int->Float) tested and passing
    - DateTime round-trip on dimension column tested and passing
    - Clear, replace, empty read, row count mismatch edge cases covered
    - Full Julia test suite passes
    - Full cross-layer test suite passes (C++, C API, Julia)
  </done>
</task>

</tasks>

<verification>
1. All existing time series group tests rewritten for kwargs/Dict interface
2. New multi-column mixed-type tests pass with INTEGER + REAL + TEXT value columns
3. DateTime parsing verified on dimension column (both directions)
4. Auto-coercion (Int->Float) verified
5. Edge cases covered: clear, empty read, replace, row count mismatch
6. Full Julia test suite passes: `bindings/julia/test/test.bat`
7. Full cross-layer test suite passes: `scripts/test-all.bat`
</verification>

<success_criteria>
- All existing time series tests migrated to new kwargs/Dict interface and passing
- Multi-column mixed-type tests added and passing with correct types per column
- DateTime round-trip verified on dimension column
- Auto-coercion verified (Int vector for REAL column)
- Error case verified (row count mismatch throws ArgumentError)
- Full Julia test suite green
- Full cross-layer test suite green (no regressions in C++, C API)
</success_criteria>

<output>
After completion, create `.planning/phases/12-julia-binding-migration/12-02-SUMMARY.md`
</output>
