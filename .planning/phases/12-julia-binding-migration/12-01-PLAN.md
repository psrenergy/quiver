---
phase: 12-julia-binding-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/julia/src/c_api.jl
  - bindings/julia/src/database_update.jl
  - bindings/julia/src/database_read.jl
autonomous: true
requirements: [BIND-01, BIND-02]

must_haves:
  truths:
    - "update_time_series_group! accepts kwargs matching schema column names"
    - "update_time_series_group! with no kwargs clears all rows for the element"
    - "update_time_series_group! auto-coerces Int vectors to Float64 when schema expects REAL"
    - "update_time_series_group! accepts DateTime values for dimension column and formats to string"
    - "read_time_series_group returns Dict{String, Vector} with typed columns"
    - "read_time_series_group parses dimension column strings to DateTime"
    - "read_time_series_group returns empty Dict for no data"
  artifacts:
    - path: "bindings/julia/src/c_api.jl"
      provides: "Regenerated FFI bindings with new 9-arg time series signatures"
      contains: "quiver_database_read_time_series_group"
    - path: "bindings/julia/src/database_update.jl"
      provides: "Kwargs-based update_time_series_group! with auto-coercion"
      contains: "kwargs"
    - path: "bindings/julia/src/database_read.jl"
      provides: "Columnar read_time_series_group returning Dict{String, Vector}"
      contains: "Dict{String, Vector}"
  key_links:
    - from: "bindings/julia/src/database_update.jl"
      to: "bindings/julia/src/c_api.jl"
      via: "C.quiver_database_update_time_series_group 9-arg call"
      pattern: "quiver_database_update_time_series_group"
    - from: "bindings/julia/src/database_read.jl"
      to: "bindings/julia/src/c_api.jl"
      via: "C.quiver_database_read_time_series_group 9-arg call"
      pattern: "quiver_database_read_time_series_group"
    - from: "bindings/julia/src/database_update.jl"
      to: "bindings/julia/src/database_metadata.jl"
      via: "get_time_series_metadata for auto-coercion"
      pattern: "get_time_series_metadata"
    - from: "bindings/julia/src/database_read.jl"
      to: "bindings/julia/src/date_time.jl"
      via: "string_to_date_time for dimension column parsing"
      pattern: "string_to_date_time"
---

<objective>
Regenerate Julia FFI bindings and rewrite `update_time_series_group!` and `read_time_series_group` to use the new multi-column C API from Phase 11.

Purpose: Enable Julia users to interact with multi-column time series data using idiomatic kwargs (update) and typed Dict (read), replacing the old single-value-column row-dict interface.

Output: Updated `c_api.jl` with new signatures, rewritten `update_time_series_group!` with kwargs marshaling, rewritten `read_time_series_group` with columnar-to-Dict unmarshaling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-julia-binding-migration/12-CONTEXT.md
@.planning/phases/12-julia-binding-migration/12-RESEARCH.md
@bindings/julia/src/c_api.jl
@bindings/julia/src/database_update.jl
@bindings/julia/src/database_read.jl
@bindings/julia/src/database_metadata.jl
@bindings/julia/src/date_time.jl
@include/quiver/c/database.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate c_api.jl and rewrite update_time_series_group!</name>
  <files>bindings/julia/src/c_api.jl, bindings/julia/src/database_update.jl</files>
  <action>
1. **Regenerate c_api.jl**: Run `bindings/julia/generator/generator.bat` to regenerate `bindings/julia/src/c_api.jl` with the new C API signatures. Verify the generated file contains:
   - `quiver_database_read_time_series_group` with 9 parameters (db, collection, group, id, out_column_names, out_column_types, out_column_data, out_column_count, out_row_count)
   - `quiver_database_update_time_series_group` with 9 parameters (db, collection, group, id, column_names, column_types, column_data, column_count, row_count)
   - `quiver_database_free_time_series_data` with 5 parameters (column_names, column_types, column_data, column_count, row_count)

2. **Rewrite update_time_series_group!** in `database_update.jl`:
   - Remove the old function signature `update_time_series_group!(db, collection, group, id, rows::Vector{Dict{String, Any}})` entirely
   - Replace with kwargs signature: `update_time_series_group!(db::Database, collection::String, group::String, id::Int64; kwargs...)`
   - **No kwargs = clear**: When `isempty(kwargs)`, call C API with `C_NULL, C_NULL, C_NULL, Csize_t(0), Csize_t(0)` for the 5 columnar args
   - **Row count validation**: All kwarg vectors must have the same length. Throw `ArgumentError("All column vectors must have the same length")` with details if mismatched.
   - **Metadata fetch for auto-coercion**: Call `get_time_series_metadata(db, collection, group)` to build a schema type map (`Dict{String, quiver_data_type_t}`) mapping column names to expected C types. Include dimension column as `QUIVER_DATA_TYPE_STRING`.
   - **Type marshaling per kwarg** (iterate `kwargs`):
     - `Vector{DateTime}` or `eltype <: DateTime`: Format each to string via `date_time_to_string()`, build `Ptr{Cchar}[]` array, set type `QUIVER_DATA_TYPE_STRING`
     - `eltype <: AbstractString`: Build `Ptr{Cchar}[]` array via `Base.cconvert`/`Base.unsafe_convert`, set type `QUIVER_DATA_TYPE_STRING`
     - `eltype <: Integer`: Check schema type. If schema expects `QUIVER_DATA_TYPE_FLOAT`, auto-coerce to `Float64[]`. Otherwise build `Int64[]`. Set type accordingly.
     - `eltype <: Real`: Build `Float64[]`, set type `QUIVER_DATA_TYPE_FLOAT`
     - Else: throw `ArgumentError("Unsupported column type: $(eltype(v)) for column '$col_name'")`
   - **GC safety**: Use a `refs = Any[]` collector pattern. Push all intermediate arrays (cstring conversions, typed data arrays, name pointer arrays, type arrays, data pointer arrays) to `refs`. Wrap the entire `@ccall` in `GC.@preserve refs begin ... end`.
   - **C API call**: Build `name_ptrs::Vector{Ptr{Cchar}}`, `col_types_arr::Vector{Cint}`, `col_data_arr::Vector{Ptr{Cvoid}}` and call `C.quiver_database_update_time_series_group(db.ptr, collection, group, id, name_ptrs, col_types_arr, col_data_arr, Csize_t(column_count), Csize_t(row_count))` inside the GC.@preserve block, wrapped with `check()`.
   - Return `nothing`.
   - Use the code skeleton from 12-RESEARCH.md as reference but adapt to match actual generated c_api.jl types.
  </action>
  <verify>
    - `bindings/julia/src/c_api.jl` contains `quiver_database_update_time_series_group` with 9 parameters
    - `bindings/julia/src/database_update.jl` contains `kwargs...` in the `update_time_series_group!` signature
    - Old `rows::Vector{Dict{String, Any}}` signature is completely removed from `database_update.jl`
    - Build succeeds: `cmake --build build --config Debug`
  </verify>
  <done>
    - c_api.jl regenerated with new 9-arg signatures for read/update/free time series
    - update_time_series_group! accepts kwargs, auto-coerces types, handles clear (no kwargs), validates row counts
    - Old Vector{Dict{String, Any}} parameter removed
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite read_time_series_group to return Dict{String, Vector}</name>
  <files>bindings/julia/src/database_read.jl</files>
  <action>
1. **Rewrite read_time_series_group** in `database_read.jl`:
   - Remove the old implementation that returns `Vector{Dict{String, Any}}` (the function starting around line 549)
   - Replace with new implementation returning `Dict{String, Vector}`:
   - **Out parameters**: Create `Ref` variables for: `out_col_names::Ref{Ptr{Ptr{Cchar}}}`, `out_col_types::Ref{Ptr{Cint}}`, `out_col_data::Ref{Ptr{Ptr{Cvoid}}}`, `out_col_count::Ref{Csize_t}`, `out_row_count::Ref{Csize_t}`
   - **C API call**: `check(C.quiver_database_read_time_series_group(db.ptr, collection, group, id, out_col_names, out_col_types, out_col_data, out_col_count, out_row_count))`
   - **Empty check**: If `col_count == 0 || row_count == 0`, return `Dict{String, Vector}()`
   - **Dimension column detection**: Fetch `get_time_series_metadata(db, collection, group)` to get `metadata.dimension_column` name
   - **Unmarshal columns**: Use `unsafe_wrap` on out arrays, then for each column `i in 1:col_count`:
     - Get `col_name = unsafe_string(name_ptrs[i])`
     - Switch on `col_type = type_vals[i]`:
       - `QUIVER_DATA_TYPE_INTEGER` (Cint(0)): `reinterpret(Ptr{Int64}, data_ptrs[i])` -> `copy(unsafe_wrap(Array, ptr, row_count))` -> `Vector{Int64}`
       - `QUIVER_DATA_TYPE_FLOAT` (Cint(1)): `reinterpret(Ptr{Float64}, data_ptrs[i])` -> `copy(unsafe_wrap(...))` -> `Vector{Float64}`
       - `QUIVER_DATA_TYPE_STRING` (Cint(2)) or `QUIVER_DATA_TYPE_DATE_TIME` (Cint(3)): `reinterpret(Ptr{Ptr{Cchar}}, data_ptrs[i])` -> `unsafe_wrap` to get `str_ptrs`. If `col_name == dim_col`: parse each to `DateTime` via `string_to_date_time(unsafe_string(p))`. Else: `String[unsafe_string(p) for p in str_ptrs]`
   - **Free C memory**: Call `C.quiver_database_free_time_series_data(out_col_names[], out_col_types[], out_col_data[], Csize_t(col_count), Csize_t(row_count))` -- note: must pass Csize_t for the size args to match the C signature. Check what the generated c_api.jl expects.
   - Return the `Dict{String, Vector}` result.
   - Also remove the helper `_get_value_data_type` function (line 397-402) since it was only used by old time series code and by read_all_vectors/sets which use it for single-column groups. Actually, check if `_get_value_data_type` is used elsewhere -- if `read_all_vectors_by_id` and `read_all_sets_by_id` use it, keep it. Only remove if unused after the rewrite.

2. **Verify the `string_to_date_time` function** in `date_time.jl` handles `nothing` input: It doesn't (takes `String`). The read function should never pass `nothing` since C API returns non-null strings for time series data rows.
  </action>
  <verify>
    - `database_read.jl` contains `Dict{String, Vector}` as return type annotation or in function body
    - Old `Vector{Dict{String, Any}}` return pattern removed from `read_time_series_group`
    - Old date_times/values/row_count 3-arg pattern gone from read_time_series_group
    - Grep for `string_to_date_time` in read_time_series_group confirms DateTime parsing on dimension column
  </verify>
  <done>
    - read_time_series_group returns Dict{String, Vector} with typed columns (Int64, Float64, String, DateTime)
    - Dimension column parsed to DateTime, other TEXT columns remain String
    - Empty results return Dict{String, Vector}()
    - C memory properly freed via quiver_database_free_time_series_data with 5 args
  </done>
</task>

</tasks>

<verification>
1. c_api.jl regenerated and contains 9-arg signatures for time series read/update/free
2. update_time_series_group! uses kwargs, no old row-dict interface remains
3. read_time_series_group returns Dict{String, Vector}, no old Vector{Dict{String, Any}} remains
4. Both functions use GC.@preserve for FFI safety
5. Auto-coercion (Int->Float) works via metadata fetch
6. DateTime handling on dimension column for both update and read
7. C++ and C API tests still pass: `./build/bin/quiver_tests.exe && ./build/bin/quiver_c_tests.exe`
</verification>

<success_criteria>
- c_api.jl has been regenerated with new multi-column time series function signatures
- update_time_series_group! accepts kwargs and marshals to C API columnar arrays with auto-coercion
- read_time_series_group returns Dict{String, Vector} with typed columns and DateTime dimension
- No old single-column time series code remains in database_update.jl or database_read.jl
- C++ and C API test suites still pass (no regressions from binding changes)
</success_criteria>

<output>
After completion, create `.planning/phases/12-julia-binding-migration/12-01-SUMMARY.md`
</output>
