---
phase: 09-code-hygiene
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/database_impl.h
  - src/schema.cpp
  - src/database_read.cpp
  - src/database_update.cpp
  - src/database_create.cpp
  - src/database_relations.cpp
  - src/database_time_series.cpp
  - src/database_delete.cpp
  - tests/test_database_read.cpp
  - tests/test_database_update.cpp
autonomous: true
must_haves:
  truths:
    - "Every SQL string concatenation site that uses a column/attribute name validates that name against the loaded Schema before concatenation"
    - "PRAGMA queries in schema.cpp validate table/index names against a safe character pattern before concatenation"
    - "A require_column helper exists on Database::Impl and is used consistently for attribute validation in read paths"
    - "All existing C++ and C API tests pass after adding validation"
  artifacts:
    - path: "src/database_impl.h"
      provides: "require_column() validation helper on Database::Impl"
      contains: "require_column"
    - path: "src/schema.cpp"
      provides: "is_safe_identifier() character validation for PRAGMA queries"
      contains: "is_safe_identifier"
  key_links:
    - from: "src/database_read.cpp"
      to: "src/database_impl.h"
      via: "require_column calls before SQL concatenation"
      pattern: "require_column"
    - from: "src/schema.cpp"
      to: "src/schema.cpp"
      via: "is_safe_identifier calls before PRAGMA concatenation"
      pattern: "is_safe_identifier"
    - from: "tests/test_database_read.cpp"
      to: "src/database_read.cpp"
      via: "Tests that call read methods with invalid column names and expect std::runtime_error"
      pattern: "EXPECT_THROW.*nonexistent"
---

<objective>
Add identifier validation to all SQL string concatenation sites across the C++ core, closing the gap where column/attribute names are concatenated into SQL without schema verification.

Purpose: Eliminate SQL injection risk from unvalidated identifiers. The codebase already validates collection names via `require_collection()` and derived table names via `Schema::find_*_table()`, but column/attribute names in read operations and PRAGMA identifiers in schema loading are not validated.

Output: All ~73 SQL concatenation sites validated; a `require_column` helper added to `Database::Impl`; character-class validation added for 4 PRAGMA queries in `schema.cpp`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/database_impl.h
@src/database_read.cpp
@src/database_update.cpp
@src/database_create.cpp
@src/database_delete.cpp
@src/database_relations.cpp
@src/database_time_series.cpp
@src/schema.cpp
@include/quiver/schema.h
@src/database_internal.h
@.planning/phases/09-code-hygiene/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add require_column helper and is_safe_identifier, validate read and update paths</name>
  <files>
    src/database_impl.h
    src/schema.cpp
    src/database_read.cpp
    src/database_update.cpp
  </files>
  <action>
**Step 1: Add `require_column` to `Database::Impl` in `src/database_impl.h`.**

Add after `require_collection`:
```cpp
void require_column(const std::string& table, const std::string& column, const char* operation) const {
    require_schema(operation);
    const auto* table_def = schema->get_table(table);
    if (!table_def) {
        throw std::runtime_error(std::string("Cannot ") + operation + ": table not found: " + table);
    }
    if (!table_def->has_column(column)) {
        throw std::runtime_error(std::string("Cannot ") + operation +
                                  ": column '" + column + "' not found in table '" + table + "'");
    }
}
```

**Step 2: Add `is_safe_identifier` to `src/schema.cpp`.**

Add as a file-local static function near the top of the file (after includes, inside the quiver namespace):
```cpp
static bool is_safe_identifier(const std::string& name) {
    if (name.empty()) return false;
    return std::all_of(name.begin(), name.end(), [](char c) {
        return std::isalnum(static_cast<unsigned char>(c)) || c == '_';
    });
}
```
Add `#include <algorithm>` and `#include <cctype>` if not already included.

Then wrap each of the 4 PRAGMA concatenation sites in `schema.cpp` with a guard:
- `query_columns`: Before `"PRAGMA table_info(" + table + ")"`, add:
  ```cpp
  if (!is_safe_identifier(table)) {
      throw std::runtime_error("Cannot query columns: invalid table name: " + table);
  }
  ```
- `query_foreign_keys`: Same pattern before `"PRAGMA foreign_key_list(" + table + ")"`.
- `query_indexes`: Same pattern before `"PRAGMA index_list(" + table + ")"`.
- Inside `query_indexes`, before `"PRAGMA index_info(" + idx.name + ")"`, add:
  ```cpp
  if (!is_safe_identifier(idx.name)) continue;
  ```

**Step 3: Validate column names in `database_read.cpp`.**

This is the biggest gap (19 sites). For each scalar read method (`read_scalar_integers`, `read_scalar_floats`, `read_scalar_strings`), add after `require_collection`:
```cpp
impl_->require_column(collection, attribute, "read_scalar_integers");
```
Use the matching operation name for each method.

For each `_by_id` variant (`read_scalar_integer_by_id`, `read_scalar_float_by_id`, `read_scalar_string_by_id`), add the same pattern with the corresponding operation name.

For vector reads (`read_vector_integers/floats/strings` and their `_by_id` variants): `find_vector_table` already validates the table exists, but add `require_column` against the returned vector_table:
```cpp
auto vector_table = impl_->schema->find_vector_table(collection, attribute);
impl_->require_column(vector_table, attribute, "read_vector_integers");
```

For set reads: same pattern with the set_table.

`read_element_ids`: No change needed -- uses hardcoded "id" column which is always present.

**Step 4: Validate column names in `database_update.cpp`.**

For `update_element` scalar section: Already validated by `type_validator->validate_scalar()` which internally calls `schema_.get_data_type(table, column)` and throws if column not found. **No additional validation needed.**

For `update_element` array routing: `find_table_for_column` validates column existence. **Already validated.**

For `update_scalar_integer/float/string`: `type_validator->validate_scalar()` already validates column exists. **Already validated.**

For `update_vector_integers/floats/strings`: `find_vector_table` validates the table. Add `require_column` for the attribute against the vector_table, once before the transaction guard:
```cpp
auto vector_table = impl_->schema->find_vector_table(collection, attribute);
impl_->require_column(vector_table, attribute, "update_vector_integers");
```

For `update_set_integers/floats/strings`: Same pattern with set_table.
  </action>
  <verify>
Build and run all C++ and C API tests:
```bash
cmake --build build --config Debug && ./build/bin/quiver_tests.exe && ./build/bin/quiver_c_tests.exe
```
All tests must pass. The validation is defense-in-depth -- existing tests should work because they use valid identifiers. Verify no regressions.
  </verify>
  <done>
`require_column` helper exists on Database::Impl. `is_safe_identifier` guards all 4 PRAGMA queries in schema.cpp. All read and vector/set update paths have `require_column` calls. All C++ and C API tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate remaining paths and confirm already-validated sites</name>
  <files>
    src/database_create.cpp
    src/database_relations.cpp
    src/database_time_series.cpp
    src/database_delete.cpp
  </files>
  <action>
**Step 1: Validate in `database_time_series.cpp`.**

`read_time_series_group` and `update_time_series_group`: `find_time_series_table` validates the table. Column names come from `table_def->columns` (schema metadata, trusted). `dim_col` comes from `find_dimension_column` (schema metadata). **Already validated.**

`read_time_series_files` and `update_time_series_files`: `find_time_series_files_table` validates the table. Column names come from `table_def->columns`. For `update_time_series_files`, the `paths` map keys are column names provided by the caller -- add validation that each key exists in the table:
```cpp
for (const auto& [col_name, path] : paths) {
    if (!table_def->has_column(col_name)) {
        throw std::runtime_error("Cannot update_time_series_files: column '" + col_name +
                                  "' not found in table '" + tsf + "'");
    }
}
```
Add this after the `table_def` retrieval and before the transaction guard.

**Step 2: Confirm `database_create.cpp` is already validated.**

`create_element`: Scalars validated by `type_validator->validate_scalar()`. Arrays validated by `type_validator->validate_array()` which calls `schema_.get_data_type()`. FK lookup `fk.to_table` comes from schema metadata (trusted). **No changes needed.**

**Step 3: Confirm `database_relations.cpp` is already validated.**

`update_scalar_relation` and `read_scalar_relation`: The `to_table` comes from `table_def->foreign_keys` (schema metadata, trusted). The `attribute` is checked against FK list and throws if not found. `collection` is validated by `require_collection`. **No changes needed.**

**Step 4: Confirm `database_delete.cpp` is already validated.**

Uses only `collection` name (already validated by `require_collection`). **No changes needed.**

**Step 5: Verify existing validation coverage.**

Run these grep commands to confirm the "already validated" claims are correct:

```bash
grep -n "type_validator\|find_table_for_column\|find_vector_table" src/database_create.cpp
```
Expected: `type_validator->validate_scalar` and `type_validator->validate_array` calls present, confirming column validation.

```bash
grep -n "foreign_keys\|require_collection" src/database_relations.cpp
```
Expected: FK lookup validates attribute against schema, `require_collection` validates collection.

```bash
grep -n "find_time_series_table\|find_dimension_column\|table_def->columns" src/database_time_series.cpp
```
Expected: Table lookup validates table name, column names come from schema metadata.

```bash
grep -n "require_collection" src/database_delete.cpp
```
Expected: `require_collection` present, confirming collection name validation.

If any of these greps reveal an unvalidated SQL concatenation site, add `require_column` or `is_safe_identifier` validation at that site following the same patterns from Task 1.

**Summary of actual changes in this task:**
- `database_time_series.cpp`: Add column validation to `update_time_series_files`
- `database_create.cpp`: No changes (already validated by TypeValidator)
- `database_relations.cpp`: No changes (already validated by FK lookup)
- `database_delete.cpp`: No changes (only uses collection name)
  </action>
  <verify>
Build and run all C++ and C API tests:
```bash
cmake --build build --config Debug && ./build/bin/quiver_tests.exe && ./build/bin/quiver_c_tests.exe
```
All tests must pass.

Then verify existing validation coverage by running the grep commands from Step 5. Each grep must show the expected validation patterns.
  </verify>
  <done>
`update_time_series_files` validates caller-provided column names. All other sites in `database_create.cpp`, `database_relations.cpp`, and `database_delete.cpp` are confirmed validated by existing mechanisms (TypeValidator, FK lookup, require_collection). All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add identifier validation tests</name>
  <files>
    tests/test_database_read.cpp
    tests/test_database_update.cpp
  </files>
  <action>
Add a small number of targeted tests that verify the new validation catches invalid identifiers. The existing test files use the `TEST(Database, ...)` pattern (no test fixture class), so new tests must follow the same pattern.

**In `tests/test_database_read.cpp`:**

Add a test that creates a database from the standard schema, calls `read_scalar_integers` with a nonexistent column name, and expects `std::runtime_error` with the "not found" message pattern. Follow the same setup pattern as existing tests (e.g., `ReadScalarIntegers`):
```cpp
TEST(Database, ReadScalarIntegersInvalidColumnThrows) {
    auto db = Database::from_schema(":memory:", SCHEMA_BASIC);
    EXPECT_THROW({
        try {
            db.read_scalar_integers("Items", "nonexistent_column");
        } catch (const std::runtime_error& e) {
            EXPECT_THAT(std::string(e.what()), testing::HasSubstr("not found"));
            throw;
        }
    }, std::runtime_error);
}
```

Add a similar test for `read_vector_integers` with an invalid attribute name:
```cpp
TEST(Database, ReadVectorIntegersInvalidColumnThrows) {
    auto db = Database::from_schema(":memory:", SCHEMA_BASIC);
    EXPECT_THROW({
        try {
            db.read_vector_integers("Items", "nonexistent_column");
        } catch (const std::runtime_error& e) {
            EXPECT_THAT(std::string(e.what()), testing::HasSubstr("not found"));
            throw;
        }
    }, std::runtime_error);
}
```

Check the top of the test file for existing includes and the schema path constant name (likely `SCHEMA_BASIC` or similar). Use the same constant and includes. Ensure `#include <gmock/gmock.h>` is present for `testing::HasSubstr`.

**In `tests/test_database_update.cpp`:**

Add a test that calls `update_vector_integers` with a nonexistent column name and expects `std::runtime_error`:
```cpp
TEST(Database, UpdateVectorIntegersInvalidColumnThrows) {
    auto db = Database::from_schema(":memory:", SCHEMA_BASIC);
    // Create an element first so there's a valid ID
    Element e;
    e.set("label", std::string("Test"));
    e.set("value", static_cast<int64_t>(1));
    db.create_element("Items", e);

    EXPECT_THROW({
        try {
            db.update_vector_integers("Items", "nonexistent_column", 1, {1, 2, 3});
        } catch (const std::runtime_error& e) {
            EXPECT_THAT(std::string(e.what()), testing::HasSubstr("not found"));
            throw;
        }
    }, std::runtime_error);
}
```

Again, use the same schema constant and includes as the existing tests in the file.

These are defense-in-depth tests -- they verify the new validation paths work, not just that existing paths still work.
  </action>
  <verify>
```bash
cmake --build build --config Debug && ./build/bin/quiver_tests.exe
```
All tests including the new ones pass.
  </verify>
  <done>
At least 3 new tests exist that specifically verify invalid identifier names are rejected with clear error messages using the `TEST(Database, ...)` pattern. All test suites pass.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` succeeds
2. `./build/bin/quiver_tests.exe` -- all C++ tests pass (including new validation tests)
3. `./build/bin/quiver_c_tests.exe` -- all C API tests pass
4. Grep for SQL concatenation sites confirms every one has a validation call before it (either `require_column`, `require_collection`, `TypeValidator::validate_scalar`, `find_*_table`, or `is_safe_identifier`)
</verification>

<success_criteria>
- Zero SQL concatenation sites with unvalidated identifiers
- `require_column` helper exists and is called in all read paths and vector/set update paths
- `is_safe_identifier` guards all 4 PRAGMA queries in schema.cpp
- New tests cover invalid identifier rejection
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/09-code-hygiene/09-01-SUMMARY.md`
</output>
