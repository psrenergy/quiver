---
phase: 09-code-hygiene
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/database_impl.h
  - src/schema.cpp
  - src/database_read.cpp
  - src/database_update.cpp
  - src/database_create.cpp
  - src/database_relations.cpp
  - src/database_time_series.cpp
  - src/database_delete.cpp
autonomous: true
must_haves:
  truths:
    - "Every SQL string concatenation site that uses a column/attribute name validates that name against the loaded Schema before concatenation"
    - "PRAGMA queries in schema.cpp validate table/index names against a safe character pattern before concatenation"
    - "A require_column helper exists on Database::Impl and is used consistently for attribute validation in read paths"
    - "All existing C++ and C API tests pass after adding validation"
  artifacts:
    - path: "src/database_impl.h"
      provides: "require_column() validation helper on Database::Impl"
      contains: "require_column"
    - path: "src/schema.cpp"
      provides: "is_safe_identifier() character validation for PRAGMA queries"
      contains: "is_safe_identifier"
  key_links:
    - from: "src/database_read.cpp"
      to: "src/database_impl.h"
      via: "require_column calls before SQL concatenation"
      pattern: "require_column"
    - from: "src/schema.cpp"
      to: "src/schema.cpp"
      via: "is_safe_identifier calls before PRAGMA concatenation"
      pattern: "is_safe_identifier"
---

<objective>
Add identifier validation to all SQL string concatenation sites across the C++ core, closing the gap where column/attribute names are concatenated into SQL without schema verification.

Purpose: Eliminate SQL injection risk from unvalidated identifiers. The codebase already validates collection names via `require_collection()` and derived table names via `Schema::find_*_table()`, but column/attribute names in read operations and PRAGMA identifiers in schema loading are not validated.

Output: All ~73 SQL concatenation sites validated; a `require_column` helper added to `Database::Impl`; character-class validation added for 4 PRAGMA queries in `schema.cpp`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/database_impl.h
@src/database_read.cpp
@src/database_update.cpp
@src/database_create.cpp
@src/database_delete.cpp
@src/database_relations.cpp
@src/database_time_series.cpp
@src/schema.cpp
@include/quiver/schema.h
@src/database_internal.h
@.planning/phases/09-code-hygiene/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add require_column helper and is_safe_identifier, validate all SQL concatenation sites</name>
  <files>
    src/database_impl.h
    src/schema.cpp
    src/database_read.cpp
    src/database_update.cpp
    src/database_create.cpp
    src/database_relations.cpp
    src/database_time_series.cpp
    src/database_delete.cpp
  </files>
  <action>
**Step 1: Add `require_column` to `Database::Impl` in `src/database_impl.h`.**

Add after `require_collection`:
```cpp
void require_column(const std::string& table, const std::string& column, const char* operation) const {
    require_schema(operation);
    const auto* table_def = schema->get_table(table);
    if (!table_def) {
        throw std::runtime_error(std::string("Cannot ") + operation + ": table not found: " + table);
    }
    if (!table_def->has_column(column)) {
        throw std::runtime_error(std::string("Cannot ") + operation +
                                  ": column '" + column + "' not found in table '" + table + "'");
    }
}
```

**Step 2: Add `is_safe_identifier` to `src/schema.cpp`.**

Add as a file-local static function near the top of the file (after includes, inside the quiver namespace):
```cpp
static bool is_safe_identifier(const std::string& name) {
    if (name.empty()) return false;
    return std::all_of(name.begin(), name.end(), [](char c) {
        return std::isalnum(static_cast<unsigned char>(c)) || c == '_';
    });
}
```
Add `#include <algorithm>` and `#include <cctype>` if not already included.

Then wrap each of the 4 PRAGMA concatenation sites in `schema.cpp` with a guard:
- `query_columns`: Before `"PRAGMA table_info(" + table + ")"`, add:
  ```cpp
  if (!is_safe_identifier(table)) {
      throw std::runtime_error("Cannot query columns: invalid table name: " + table);
  }
  ```
- `query_foreign_keys`: Same pattern before `"PRAGMA foreign_key_list(" + table + ")"`.
- `query_indexes`: Same pattern before `"PRAGMA index_list(" + table + ")"`.
- Inside `query_indexes`, before `"PRAGMA index_info(" + idx.name + ")"`, add:
  ```cpp
  if (!is_safe_identifier(idx.name)) continue;
  ```

**Step 3: Validate column names in `database_read.cpp`.**

This is the biggest gap (19 sites). For each scalar read method (`read_scalar_integers`, `read_scalar_floats`, `read_scalar_strings`), add after `require_collection`:
```cpp
impl_->require_column(collection, attribute, "read_scalar_integers");
```
Use the matching operation name for each method.

For each `_by_id` variant (`read_scalar_integer_by_id`, `read_scalar_float_by_id`, `read_scalar_string_by_id`), add the same pattern with the corresponding operation name.

For vector reads (`read_vector_integers/floats/strings` and their `_by_id` variants): `find_vector_table` already validates the table exists, but add `require_column` against the returned vector_table:
```cpp
auto vector_table = impl_->schema->find_vector_table(collection, attribute);
impl_->require_column(vector_table, attribute, "read_vector_integers");
```

For set reads: same pattern with the set_table.

`read_element_ids`: No change needed -- uses hardcoded "id" column which is always present.

**Step 4: Validate column names in `database_update.cpp`.**

For `update_element` scalar section: The scalars are already validated by `type_validator->validate_scalar()` which internally calls `schema_.get_data_type(table, column)` and throws if column not found. **No additional validation needed here** -- document this is already covered.

For `update_element` array routing: `find_table_for_column` validates column existence. Column names in the INSERT are from the same map keys. **Already validated**.

For `update_scalar_integer/float/string`: `type_validator->validate_scalar()` already validates column exists. **Already validated**.

For `update_vector_integers/floats/strings`: `find_vector_table` validates the table. Add `require_column` for the attribute against the vector_table, once before the transaction guard:
```cpp
auto vector_table = impl_->schema->find_vector_table(collection, attribute);
impl_->require_column(vector_table, attribute, "update_vector_integers");
```

For `update_set_integers/floats/strings`: Same pattern with set_table.

**Step 5: Validate in `database_create.cpp`.**

`create_element`: Scalars validated by `type_validator->validate_scalar()`. Arrays validated by `type_validator->validate_array()` which calls `schema_.get_data_type()`. FK lookup `fk.to_table` comes from schema metadata (trusted). **Already validated -- no changes needed.**

**Step 6: Validate in `database_relations.cpp`.**

`update_scalar_relation` and `read_scalar_relation`: The `to_table` comes from `table_def->foreign_keys` (schema metadata, trusted). The `attribute` is checked against FK list and throws if not found. `collection` is validated by `require_collection`. **Already validated -- no changes needed.**

**Step 7: Validate in `database_time_series.cpp`.**

`read_time_series_group` and `update_time_series_group`: `find_time_series_table` validates the table. Column names come from `table_def->columns` (schema metadata, trusted). `dim_col` comes from `find_dimension_column` (schema metadata). **Already validated.**

`read_time_series_files` and `update_time_series_files`: `find_time_series_files_table` validates the table. Column names come from `table_def->columns`. For `update_time_series_files`, the `paths` map keys are column names provided by the caller -- add validation that each key exists in the table:
```cpp
for (const auto& [col_name, path] : paths) {
    if (!table_def->has_column(col_name)) {
        throw std::runtime_error("Cannot update_time_series_files: column '" + col_name +
                                  "' not found in table '" + tsf + "'");
    }
}
```
Add this after the `table_def` retrieval and before the transaction guard.

**Step 8: `database_delete.cpp`.**

Uses only `collection` name (already validated by `require_collection`). **No changes needed.**

**Summary of actual changes:**
- `database_impl.h`: Add `require_column` method
- `schema.cpp`: Add `is_safe_identifier` + 4 PRAGMA guards
- `database_read.cpp`: Add `require_column` calls to 18 methods (all except `read_element_ids`)
- `database_update.cpp`: Add `require_column` calls to 6 vector/set update methods
- `database_time_series.cpp`: Add column validation to `update_time_series_files`
- `database_create.cpp`: No changes (already validated by TypeValidator)
- `database_relations.cpp`: No changes (already validated by FK lookup)
- `database_delete.cpp`: No changes (only uses collection name)
  </action>
  <verify>
Build and run all C++ and C API tests:
```bash
cmake --build build --config Debug && ./build/bin/quiver_tests.exe && ./build/bin/quiver_c_tests.exe
```
All tests must pass. The validation is defense-in-depth -- existing tests should work because they use valid identifiers. Verify no regressions.
  </verify>
  <done>
Every SQL concatenation site in the codebase has explicit identifier validation: column/attribute names are checked against the Schema (via `require_column` or `TypeValidator`), and PRAGMA identifiers are checked against a safe character pattern. All C++ and C API tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add identifier validation tests and verify coverage</name>
  <files>
    tests/test_database_read.cpp
    tests/test_database_update.cpp
  </files>
  <action>
Add a small number of targeted tests that verify the new validation catches invalid identifiers:

**In `tests/test_database_read.cpp`:**
Add a test that calls `read_scalar_integers` with a nonexistent column name and expects `std::runtime_error` with the "column '...' not found" message pattern:
```cpp
TEST_F(DatabaseReadTest, ReadScalarIntegersInvalidColumnThrows) {
    EXPECT_THROW({
        try {
            db.read_scalar_integers("Items", "nonexistent_column");
        } catch (const std::runtime_error& e) {
            EXPECT_THAT(std::string(e.what()), testing::HasSubstr("not found"));
            throw;
        }
    }, std::runtime_error);
}
```
Use the existing test fixture (`DatabaseReadTest` or similar). Check the existing test file for the fixture name and patterns used.

Add a similar test for `read_vector_integers` with an invalid attribute name -- this should throw from `find_vector_table` (already existed) but now also has the `require_column` guard.

**In `tests/test_database_update.cpp`:**
Add a test that calls `update_vector_integers` with a nonexistent column name and expects `std::runtime_error`.

These are defense-in-depth tests -- they verify the new validation paths work, not just that existing paths still work.
  </action>
  <verify>
```bash
cmake --build build --config Debug && ./build/bin/quiver_tests.exe
```
All tests including the new ones pass.
  </verify>
  <done>
At least 2-3 new tests exist that specifically verify invalid identifier names are rejected with clear error messages. All test suites pass.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` succeeds
2. `./build/bin/quiver_tests.exe` -- all C++ tests pass (including new validation tests)
3. `./build/bin/quiver_c_tests.exe` -- all C API tests pass
4. Grep for SQL concatenation sites confirms every one has a validation call before it (either `require_column`, `require_collection`, `TypeValidator::validate_scalar`, `find_*_table`, or `is_safe_identifier`)
</verification>

<success_criteria>
- Zero SQL concatenation sites with unvalidated identifiers
- `require_column` helper exists and is called in all read paths and vector/set update paths
- `is_safe_identifier` guards all 4 PRAGMA queries in schema.cpp
- New tests cover invalid identifier rejection
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/09-code-hygiene/09-01-SUMMARY.md`
</output>
