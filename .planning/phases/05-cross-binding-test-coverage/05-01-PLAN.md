---
phase: 05-cross-binding-test-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/julia/src/database.jl
  - bindings/julia/test/test_database_lifecycle.jl
  - bindings/dart/lib/src/database.dart
  - bindings/dart/test/database_lifecycle_test.dart
autonomous: true
requirements:
  - TEST-01
  - PY-03
must_haves:
  truths:
    - "Julia is_healthy() returns true on an open database"
    - "Julia path() returns the database file path as a String"
    - "Dart isHealthy() returns true on an open database"
    - "Dart path() returns the database file path as a String"
    - "Python is_healthy() and path() tests already pass (no changes needed)"
    - "Python convenience helper tests already satisfy PY-03 (no changes needed)"
    - "All five test suites (C++, C API, Julia, Dart, Python) pass"
  artifacts:
    - path: "bindings/julia/src/database.jl"
      provides: "is_healthy and path wrapper functions"
      contains: "function is_healthy"
    - path: "bindings/dart/lib/src/database.dart"
      provides: "isHealthy and path wrapper methods"
      contains: "bool isHealthy()"
    - path: "bindings/julia/test/test_database_lifecycle.jl"
      provides: "is_healthy and path test coverage"
      contains: "@testset \"is_healthy\""
    - path: "bindings/dart/test/database_lifecycle_test.dart"
      provides: "isHealthy and path test coverage"
      contains: "group('Database isHealthy'"
  key_links:
    - from: "bindings/julia/src/database.jl"
      to: "bindings/julia/src/c_api.jl"
      via: "C.quiver_database_is_healthy and C.quiver_database_path FFI calls"
      pattern: "C\\.quiver_database_(is_healthy|path)"
    - from: "bindings/dart/lib/src/database.dart"
      to: "bindings/dart/lib/src/ffi/bindings.dart"
      via: "bindings.quiver_database_is_healthy and bindings.quiver_database_path FFI calls"
      pattern: "bindings\\.quiver_database_(is_healthy|path)"
---

<objective>
Add `is_healthy`/`path` wrapper methods and tests to Julia and Dart bindings, confirming Python already satisfies both TEST-01 and PY-03. Run all five test suites as the final milestone gate.

Purpose: Complete cross-binding test coverage for the v0.5 milestone. Every binding must exercise health check and path accessors with verified assertions.
Output: Julia and Dart wrapper methods + lifecycle tests; all five test suites green.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-cross-binding-test-coverage/05-RESEARCH.md

@bindings/julia/src/database.jl
@bindings/julia/test/test_database_lifecycle.jl
@bindings/dart/lib/src/database.dart
@bindings/dart/test/database_lifecycle_test.dart

<interfaces>
<!-- Julia C API FFI (already generated in c_api.jl) -->
From bindings/julia/src/c_api.jl:
```julia
# line 112
function quiver_database_is_healthy(db, out_healthy)
    ccall((:quiver_database_is_healthy, libquiver_c), Cint, (Ptr{quiver_database}, Ptr{Cint}), db, out_healthy)
end
# line 116
function quiver_database_path(db, out_path)
    ccall((:quiver_database_path, libquiver_c), Cint, (Ptr{quiver_database}, Ptr{Ptr{Cchar}}), db, out_path)
end
```

<!-- Dart FFI bindings (already generated in bindings.dart) -->
From bindings/dart/lib/src/ffi/bindings.dart:
```dart
// line 178
int quiver_database_is_healthy(Pointer<quiver_database_t> db, Pointer<Int> out_healthy)
// line 195
int quiver_database_path(Pointer<quiver_database_t> db, Pointer<Pointer<Char>> out_path)
```

<!-- Julia existing wrapper pattern (from database.jl) -->
From bindings/julia/src/database.jl:
```julia
function current_version(db::Database)
    out_version = Ref{Int64}(0)
    check(C.quiver_database_current_version(db.ptr, out_version))
    return out_version[]
end
```

<!-- Dart existing wrapper pattern (from database_metadata.dart) -->
From bindings/dart/lib/src/database_metadata.dart:
```dart
int currentVersion() {
  _ensureNotClosed();
  final arena = Arena();
  try {
    final outVersion = arena<Int64>();
    check(bindings.quiver_database_current_version(_ptr, outVersion));
    return outVersion.value;
  } finally {
    arena.releaseAll();
  }
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add is_healthy and path wrappers + tests to Julia binding</name>
  <files>bindings/julia/src/database.jl, bindings/julia/test/test_database_lifecycle.jl</files>
  <action>
**In `bindings/julia/src/database.jl`**, add two functions after the `describe` function (after line 53):

```julia
function is_healthy(db::Database)
    out = Ref{Cint}(0)
    check(C.quiver_database_is_healthy(db.ptr, out))
    return out[] != 0
end

function path(db::Database)
    out = Ref{Ptr{Cchar}}(C_NULL)
    check(C.quiver_database_path(db.ptr, out))
    return unsafe_string(out[])
end
```

Pattern follows `current_version` exactly: out-parameter via `Ref`, call through `C.`, unwrap with `check()`. The `path` function uses `unsafe_string` to immediately copy the C string (critical: avoids dangling pointer after close).

**In `bindings/julia/test/test_database_lifecycle.jl`**, add two `@testset` blocks before the final `end` (before line 58):

```julia
@testset "is_healthy" begin
    path_schema = joinpath(tests_path(), "schemas", "valid", "basic.sql")
    db = Quiver.from_schema(":memory:", path_schema)
    @test Quiver.is_healthy(db) == true
    Quiver.close!(db)
end

@testset "path" begin
    path_schema = joinpath(tests_path(), "schemas", "valid", "basic.sql")
    mktempdir() do dir
        db_path = joinpath(dir, "test.db")
        db = Quiver.from_schema(db_path, path_schema)
        result = Quiver.path(db)
        @test result isa String
        @test occursin("test.db", result)
        Quiver.close!(db)
    end
end
```

The `is_healthy` test uses in-memory DB (sufficient for health check). The `path` test uses a file-based DB with `mktempdir() do...end` for automatic cleanup, verifying the returned path contains "test.db". Path is read before close to avoid the dangling pointer issue documented in CONCERNS.md.
  </action>
  <verify>
    <automated>bindings/julia/test/test.bat</automated>
  </verify>
  <done>Julia `is_healthy` and `path` functions exist in database.jl. Lifecycle tests verify `is_healthy` returns true on open DB and `path` returns a String containing the DB filename. Julia test suite passes.</done>
</task>

<task type="auto">
  <name>Task 2: Add isHealthy and path wrappers + tests to Dart binding</name>
  <files>bindings/dart/lib/src/database.dart, bindings/dart/test/database_lifecycle_test.dart</files>
  <action>
**In `bindings/dart/lib/src/database.dart`**, add two methods before the `close()` method (before line 193). Place them after the `_marshalParams` helper, near `describe`:

```dart
/// Returns true if the database passes integrity checks.
bool isHealthy() {
  _ensureNotClosed();
  final arena = Arena();
  try {
    final outHealthy = arena<Int>();
    check(bindings.quiver_database_is_healthy(_ptr, outHealthy));
    return outHealthy.value != 0;
  } finally {
    arena.releaseAll();
  }
}

/// Returns the database file path.
String path() {
  _ensureNotClosed();
  final arena = Arena();
  try {
    final outPath = arena<Pointer<Char>>();
    check(bindings.quiver_database_path(_ptr, outPath));
    return outPath.value.cast<Utf8>().toDartString();
  } finally {
    arena.releaseAll();
  }
}
```

Pattern follows `currentVersion()` from `database_metadata.dart`: `_ensureNotClosed()` guard, Arena allocation, `check()` wrapper, value extraction. The `path()` method uses `cast<Utf8>().toDartString()` to immediately copy the native string (the `package:ffi/ffi.dart` import already exists at line 3).

**In `bindings/dart/test/database_lifecycle_test.dart`**, add two `group` blocks before the closing `}` of `main()` (before line 158):

```dart
group('Database isHealthy', () {
  test('returns true for open database', () {
    final db = Database.fromSchema(':memory:', schemaPath);
    try {
      expect(db.isHealthy(), isTrue);
    } finally {
      db.close();
    }
  });
});

group('Database path', () {
  test('returns path for file-based database', () {
    final tempDir = Directory.systemTemp.createTempSync('quiver_test_');
    final dbPath = path.join(tempDir.path, 'test.db');
    try {
      final db = Database.fromSchema(dbPath, schemaPath);
      try {
        final result = db.path();
        expect(result, contains('test.db'));
      } finally {
        db.close();
      }
    } finally {
      tempDir.deleteSync(recursive: true);
    }
  });
});
```

The `isHealthy` test uses in-memory DB. The `path` test uses a file-based temp DB with nested try/finally for cleanup, matching the existing pattern from the `creates database file on disk` test (lines 34-44). Path is read before close to avoid the dangling pointer.
  </action>
  <verify>
    <automated>bindings/dart/test/test.bat</automated>
  </verify>
  <done>Dart `isHealthy()` and `path()` methods exist in database.dart. Lifecycle tests verify `isHealthy()` returns true and `path()` contains the DB filename. Dart test suite passes.</done>
</task>

</tasks>

<verification>
1. Julia tests pass: `bindings/julia/test/test.bat`
2. Dart tests pass: `bindings/dart/test/test.bat`
3. Python tests pass: `bindings/python/test/test.bat` (no changes, confirms TEST-01 Python coverage and PY-03)
4. C++ tests pass: `./build/bin/quiver_tests.exe` (no changes, baseline)
5. C API tests pass: `./build/bin/quiver_c_tests.exe` (no changes, baseline)
6. Full milestone gate: `scripts/test-all.bat` â€” all five suites green
</verification>

<success_criteria>
- Julia `Quiver.is_healthy(db)` returns `true` on open database
- Julia `Quiver.path(db)` returns a String containing the database file name
- Dart `db.isHealthy()` returns `true` on open database
- Dart `db.path()` returns a String containing the database file name
- Python existing tests confirm `is_healthy()` and `path()` coverage (TEST-01 satisfied)
- Python existing tests confirm all 7 convenience helpers coverage (PY-03 satisfied)
- `scripts/test-all.bat` exits with code 0 (all five test suites pass)
</success_criteria>

<output>
After completion, create `.planning/phases/05-cross-binding-test-coverage/05-01-SUMMARY.md`
</output>
