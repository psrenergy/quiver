---
phase: 07-test-parity
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/python/src/quiverdb/_c_api.py
  - bindings/python/src/quiverdb/database.py
  - bindings/python/tests/test_database_csv.py
  - bindings/python/tests/test_database_read_scalar.py
autonomous: true
requirements: [TEST-01, TEST-02, TEST-03, TEST-04, TEST-05]
gap_closure: true
must_haves:
  truths:
    - "Running the Python test suite produces zero failures"
    - "export_csv writes a valid CSV file without crashing"
    - "update_scalar_relation sets FK values by resolving element labels to IDs"
    - "read_scalar_relation returns labels of related elements or None for unset FKs"
    - "All six test suites (C++, C API, Julia, Dart, Python, Lua) run with zero failures"
  artifacts:
    - path: "bindings/python/src/quiverdb/_c_api.py"
      provides: "Corrected CFFI cdef with quiver_csv_options_t struct matching C header layout"
      contains: "quiver_csv_options_t"
    - path: "bindings/python/src/quiverdb/database.py"
      provides: "Pure-Python relation methods composing existing C API calls, updated CSV marshaling"
      contains: "_marshal_csv_export_options"
  key_links:
    - from: "bindings/python/src/quiverdb/_c_api.py"
      to: "libquiver_c.dll"
      via: "CFFI ABI-mode symbol resolution"
      pattern: "quiver_csv_options_t"
    - from: "bindings/python/src/quiverdb/database.py"
      to: "bindings/python/src/quiverdb/_c_api.py"
      via: "ffi.new struct allocation"
      pattern: "ffi.new quiver_csv_options_t"
---

<objective>
Fix the 2 pre-existing Python test failures so all six test suites run with zero failures, satisfying Phase 7 SC4.

Purpose: Phase 7 SC4 requires "Running all five test suites (C++, C API, Julia, Dart, Python) produces zero failures." The Python suite has 2 failures: (1) CSV export crashes with access violation due to struct layout mismatch between CFFI cdef and actual C header, and (2) `test_read_scalar_relation` fails because `quiver_database_update_scalar_relation` is a phantom symbol not exported by the DLL.

Output: All Python tests pass; all six test suites produce zero failures.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-test-parity/07-VERIFICATION.md
@include/quiver/c/options.h
@include/quiver/c/database.h
@bindings/python/src/quiverdb/_c_api.py
@bindings/python/src/quiverdb/database.py
@bindings/python/tests/test_database_csv.py
@bindings/python/tests/test_database_read_scalar.py
@bindings/python/tests/conftest.py
@bindings/julia/src/c_api.jl (reference for correct struct layout, lines 60-68)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix CSV export CFFI struct layout and marshaling to match C header</name>
  <files>
    bindings/python/src/quiverdb/_c_api.py
    bindings/python/src/quiverdb/database.py
  </files>
  <action>
The Python CFFI declares `quiver_csv_export_options_t` but the actual C struct is `quiver_csv_options_t` (in `include/quiver/c/options.h`). The CFFI struct is also missing the `enum_locale_names` field and uses the wrong field name `enum_attribute_count` (should be `enum_group_count`). This struct layout mismatch causes an access violation when the DLL reads the struct.

**In `_c_api.py`**, replace the entire CSV options block (lines ~338-355):

1. Rename struct from `quiver_csv_export_options_t` to `quiver_csv_options_t`
2. Add missing `enum_locale_names` field (type: `const char**`) after `enum_attribute_names`
3. Rename `enum_attribute_count` to `enum_group_count`
4. Rename function `quiver_csv_export_options_default` to `quiver_csv_options_default`
5. Update `quiver_database_export_csv` parameter type from `const quiver_csv_export_options_t*` to `const quiver_csv_options_t*`
6. Update `quiver_database_import_csv` signature to match actual C header: `(db, collection, group, path, opts)` with 5 parameters (currently has 3)

The corrected CFFI cdef should match the C header exactly:
```c
typedef struct {
    const char* date_time_format;
    const char** enum_attribute_names;
    const char** enum_locale_names;
    const size_t* enum_entry_counts;
    const char** enum_labels;
    const int64_t* enum_values;
    size_t enum_group_count;
} quiver_csv_options_t;

quiver_csv_options_t quiver_csv_options_default(void);

quiver_error_t quiver_database_export_csv(quiver_database_t* db,
    const char* collection, const char* group, const char* path,
    const quiver_csv_options_t* opts);

quiver_error_t quiver_database_import_csv(quiver_database_t* db,
    const char* collection, const char* group, const char* path,
    const quiver_csv_options_t* opts);
```

**In `database.py`**, update `_marshal_csv_export_options`:

1. Change `ffi.new("quiver_csv_export_options_t*")` to `ffi.new("quiver_csv_options_t*")`
2. Add `c_opts.enum_locale_names = ffi.NULL` for the no-enum case
3. For the enum case, build a `c_locale_names` array. Since Python's CSVExportOptions only has `enum_labels: dict[str, dict[int, str]]` (no locale support), pass a single empty-string locale name for each attribute group:
   - Allocate `c_locale_names = ffi.new("const char*[]", attr_count)`
   - For each attribute, set `c_locale_names[attr_idx]` to a keepalive'd `ffi.new("char[]", b"")`
   - Set `c_opts.enum_locale_names = c_locale_names`
4. Rename `c_opts.enum_attribute_count` to `c_opts.enum_group_count`

Also note field ORDER matters for struct layout. The C header order is: date_time_format, enum_attribute_names, enum_locale_names, enum_entry_counts, enum_labels, enum_values, enum_group_count. The CFFI cdef must match this exact order.
  </action>
  <verify>
    <automated>bindings/python/test/test.bat 2>&1 | grep -E "(PASSED|FAILED|ERROR|test_export_csv)"</automated>
    <manual>Verify all CSV export tests pass without access violation crashes</manual>
  </verify>
  <done>export_csv works without access violation; all CSV test cases (default, enum labels, date format, combined, group, null values) pass</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite scalar relation methods as pure-Python convenience composing existing C API calls</name>
  <files>
    bindings/python/src/quiverdb/_c_api.py
    bindings/python/src/quiverdb/database.py
    bindings/python/tests/test_database_read_scalar.py
  </files>
  <action>
`quiver_database_read_scalar_relation` and `quiver_database_update_scalar_relation` are phantom symbols declared in CFFI but not exported by `libquiver_c.dll`. The Python methods that call them crash at runtime. Fix by removing phantom declarations and rewriting methods as pure-Python convenience helpers.

**In `_c_api.py`**, remove these two phantom declarations (lines ~171-179):
- Delete `quiver_database_read_scalar_relation(...)` declaration
- Delete `quiver_database_update_scalar_relation(...)` declaration

**In `database.py`**, rewrite `update_scalar_relation` (line ~541) to compose existing methods:

```python
def update_scalar_relation(
    self, collection: str, attribute: str, from_label: str, to_label: str,
) -> None:
    """Set a scalar FK relation by resolving element labels to IDs.

    Looks up the target element's ID via label query, then looks up the
    source element's ID via label query, and calls update_scalar_integer
    to set the FK column.
    """
    self._ensure_open()
    # Resolve target label to ID
    target_id = self.query_integer(
        f"SELECT id FROM (SELECT name FROM sqlite_master WHERE type='table' AND name LIKE '%') "
        ...
    )
```

Actually, the relation semantics require knowing which table the FK references. The simplest approach that matches the existing test behavior:

`update_scalar_relation(collection, attribute, from_label, to_label)` means:
- Find the source element ID: `query_integer(f"SELECT id FROM {collection} WHERE label = ?", params=[from_label])`
- The FK attribute points to another table. Use `get_scalar_metadata(collection, attribute)` to find the `references_collection` (the target table)
- Find the target element ID: `query_integer(f"SELECT id FROM {target_collection} WHERE label = ?", params=[to_label])`
- Call `update_scalar_integer(collection, attribute, source_id, target_id)`

Rewrite as:
```python
def update_scalar_relation(
    self, collection: str, attribute: str, from_label: str, to_label: str,
) -> None:
    """Set a scalar FK relation by resolving element labels to IDs."""
    self._ensure_open()
    meta = self.get_scalar_metadata(collection, attribute)
    source_id = self.query_integer(
        f"SELECT id FROM {collection} WHERE label = ?", params=[from_label])
    if source_id is None:
        raise ValueError(f"Element not found: '{from_label}' in collection '{collection}'")
    target_id = self.query_integer(
        f"SELECT id FROM {meta.references_collection} WHERE label = ?", params=[to_label])
    if target_id is None:
        raise ValueError(f"Element not found: '{to_label}' in collection '{meta.references_collection}'")
    self.update_scalar_integer(collection, attribute, source_id, target_id)
```

Rewrite `read_scalar_relation` (line ~555) to compose existing methods:

`read_scalar_relation(collection, attribute)` returns labels of related elements:
- Read the FK integer values: `read_scalar_integers(collection, attribute)` -- but this skips NULLs
- Instead, read element IDs and per-ID FK values to preserve NULL positions
- Use `read_element_ids(collection)` to get all IDs, then for each ID read the FK value with `read_scalar_integer_by_id(collection, attribute, id)`, then resolve non-None values to labels via query

Simpler approach using `get_scalar_metadata` to find the referenced collection:
```python
def read_scalar_relation(
    self, collection: str, attribute: str,
) -> list[str | None]:
    """Read scalar FK relation labels. Returns label for each element, None for unset FKs."""
    self._ensure_open()
    meta = self.get_scalar_metadata(collection, attribute)
    ids = self.read_element_ids(collection)
    result: list[str | None] = []
    for eid in ids:
        fk_val = self.read_scalar_integer_by_id(collection, attribute, eid)
        if fk_val is None:
            result.append(None)
        else:
            label = self.query_string(
                f"SELECT label FROM {meta.references_collection} WHERE id = ?",
                params=[fk_val])
            result.append(label)
    return result
```

Check the `ScalarMetadata` dataclass to confirm it has a `references_collection` field. If it uses a different field name (e.g., `references_table` or `foreign_key_table`), use that instead. Read `bindings/python/src/quiverdb/metadata.py` to find the exact field name.

**In `test_database_read_scalar.py`**, the existing tests should pass without modification since the method signatures and behavior are preserved. No test changes needed unless the method semantics differ (which they should not -- verify by running tests).
  </action>
  <verify>
    <automated>bindings/python/test/test.bat 2>&1 | grep -E "(PASSED|FAILED|ERROR|test_read_scalar_relation|test_update_scalar)"</automated>
    <manual>Verify all relation tests pass: test_read_scalar_relation, test_read_scalar_relation_empty, test_read_scalar_relation_self_reference</manual>
  </verify>
  <done>update_scalar_relation and read_scalar_relation work as pure-Python convenience methods composing existing C API calls; all 3 relation tests pass; no phantom CFFI declarations remain</done>
</task>

</tasks>

<verification>
After both tasks are complete:

1. Run the full Python test suite: `bindings/python/test/test.bat` -- all tests must pass with 0 failures
2. Run C++ tests: `./build/bin/quiver_tests.exe` -- all pass (regression check)
3. Run C API tests: `./build/bin/quiver_c_tests.exe` -- all pass (regression check)
4. Verify no phantom CFFI declarations remain: grep `_c_api.py` for `scalar_relation` and `csv_export_options` -- no matches
5. Verify CFFI struct layout matches C header field order and names
</verification>

<success_criteria>
- Python test suite: 0 failures (all ~174 tests pass)
- No access violation on export_csv calls
- No phantom C API symbol references in CFFI cdef
- CSV export struct layout matches `include/quiver/c/options.h` exactly
- Relation methods compose existing working C API calls (no new C symbols)
- All six test suites (C++, C API, Julia, Dart, Python, Lua) produce zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/07-test-parity/07-04-SUMMARY.md`
</output>
