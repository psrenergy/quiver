---
phase: 07-test-parity
plan: 02
type: execute
wave: 2
depends_on:
  - "07-01"
files_modified:
  - bindings/julia/test/test_database_read.jl
  - bindings/julia/test/test_database_update.jl
  - bindings/julia/test/test_database_lifecycle.jl
  - bindings/julia/test/test_database_metadata.jl
  - bindings/dart/test/database_read_test.dart
  - bindings/dart/test/database_update_test.dart
  - bindings/dart/test/database_lifecycle_test.dart
  - bindings/dart/test/metadata_test.dart
autonomous: true
requirements:
  - TEST-04
  - TEST-05

must_haves:
  truths:
    - "Julia has happy-path tests for string vector reads, integer/float set reads, string vector updates, integer/float set updates, describe, and read_set_group_by_id"
    - "Dart has happy-path tests for the same set of operations as Julia"
    - "Julia test suite passes with zero failures"
    - "Dart test suite passes with zero failures"
  artifacts:
    - path: "bindings/julia/test/test_database_read.jl"
      provides: "Gap-fill tests for read_vector_strings, read_set_integers, read_set_floats, and by-id variants"
    - path: "bindings/julia/test/test_database_update.jl"
      provides: "Gap-fill tests for update_vector_strings, update_set_integers, update_set_floats"
    - path: "bindings/julia/test/test_database_metadata.jl"
      provides: "Gap-fill test for read_set_group_by_id convenience method"
    - path: "bindings/dart/test/database_read_test.dart"
      provides: "Gap-fill tests for readVectorStrings, readSetIntegers, readSetFloats, and by-id variants"
    - path: "bindings/dart/test/database_update_test.dart"
      provides: "Gap-fill tests for updateVectorStrings, updateSetIntegers, updateSetFloats"
    - path: "bindings/dart/test/metadata_test.dart"
      provides: "Gap-fill test for readSetGroupById convenience method"
  key_links:
    - from: "bindings/julia/test/test_database_read.jl"
      to: "tests/schemas/valid/all_types.sql"
      via: "schema_path helper"
      pattern: 'schema_path.*all_types'
    - from: "bindings/dart/test/database_read_test.dart"
      to: "tests/schemas/valid/all_types.sql"
      via: "schemaPath helper"
      pattern: 'schemaPath.*all_types'
---

<objective>
Fill all identified test gaps in Julia and Dart bindings, using the new all_types.sql schema for typed operations not available in existing schemas.

Purpose: After C++ is the established reference (Plan 01), Julia and Dart must achieve parity. Both languages share nearly identical gap lists: string vector operations, integer/float set operations, describe, and read_set_group_by_id.

Output: Gap-fill tests added to existing Julia and Dart test files. Both test suites pass.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-test-parity/07-RESEARCH.md
@.planning/phases/07-test-parity/07-01-SUMMARY.md
@tests/schemas/valid/all_types.sql
@bindings/julia/test/test_database_read.jl
@bindings/julia/test/test_database_update.jl
@bindings/julia/test/test_database_lifecycle.jl
@bindings/julia/test/test_database_metadata.jl
@bindings/julia/test/fixture.jl
@bindings/dart/test/database_read_test.dart
@bindings/dart/test/database_update_test.dart
@bindings/dart/test/database_lifecycle_test.dart
@bindings/dart/test/metadata_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fill Julia test gaps</name>
  <files>
    bindings/julia/test/test_database_read.jl
    bindings/julia/test/test_database_update.jl
    bindings/julia/test/test_database_lifecycle.jl
    bindings/julia/test/test_database_metadata.jl
  </files>
  <action>
All gap-fill tests should use `all_types.sql` schema (via `schema_path("all_types.sql")`). Follow existing test patterns in each file: `@testset` blocks, `from_schema(":memory:", ...)`, create elements, call operations, `@test` assertions, `close(db)`.

**Step 1: Add to `bindings/julia/test/test_database_read.jl`:**

Add these `@testset` blocks (9 tests):

- `"Read Vector Strings Bulk"`: Open all_types.sql, create 2 elements with labels, update_vector_strings! for each, call `read_vector_strings("AllTypes", "labels")`, assert returns correct list of string vectors
- `"Read Vector Strings By ID"`: Create element, set string vector, call `read_vector_strings_by_id("AllTypes", "labels", 1)`, assert values match
- `"Read Set Integers Bulk"`: Create 2 elements, set integer sets via update_set_integers!, call `read_set_integers("AllTypes", "codes")`, assert correct results
- `"Read Set Integers By ID"`: Create element, set integer set, call `read_set_integers_by_id("AllTypes", "codes", 1)`, assert values
- `"Read Set Floats Bulk"`: Create 2 elements, set float sets via update_set_floats!, call `read_set_floats("AllTypes", "weights")`, assert
- `"Read Set Floats By ID"`: Create element, set float set, call `read_set_floats_by_id("AllTypes", "weights", 1)`, assert
- `"Read Vector Strings By ID Empty"`: Create element without vectors, call read_vector_strings_by_id, assert returns empty
- `"Read Set Integers By ID Empty"`: Create element without sets, call read_set_integers_by_id, assert returns empty
- `"Read Set Floats By ID Empty"`: Create element without sets, call read_set_floats_by_id, assert returns empty

**Step 2: Add to `bindings/julia/test/test_database_update.jl`:**

Add these `@testset` blocks (3 tests):

- `"Update Vector Strings"`: Create element, call `update_vector_strings!("AllTypes", 1, "labels", ["alpha", "beta"])`, read back, verify
- `"Update Set Integers"`: Create element, call `update_set_integers!("AllTypes", 1, "codes", [10, 20, 30])`, read back, verify (sets are unordered, use sort)
- `"Update Set Floats"`: Create element, call `update_set_floats!("AllTypes", 1, "weights", [1.1, 2.2])`, read back, verify

**Step 3: Add to `bindings/julia/test/test_database_lifecycle.jl`:**

- `"Describe"`: Open DB from basic.sql, call `describe(db)`, assert no exception (just verify it runs without error)

**Step 4: Add to `bindings/julia/test/test_database_metadata.jl`:**

- `"Read Set Group By ID"`: Open all_types.sql, create element, set integer codes and float weights, call `read_set_group_by_id("AllTypes", "codes", 1)`, verify it returns a list/vector of values. Check the convenience method works end-to-end.

**Step 5: Run Julia tests.**

```bash
bindings/julia/test/test.bat
```

Verify all tests pass.
  </action>
  <verify>
Run `bindings/julia/test/test.bat` -- all tests pass with zero failures. New testset names visible in output.
  </verify>
  <done>
Julia test_database_read.jl has 9 new tests. test_database_update.jl has 3 new tests. test_database_lifecycle.jl has 1 describe test. test_database_metadata.jl has 1 read_set_group_by_id test. All Julia tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fill Dart test gaps</name>
  <files>
    bindings/dart/test/database_read_test.dart
    bindings/dart/test/database_update_test.dart
    bindings/dart/test/database_lifecycle_test.dart
    bindings/dart/test/metadata_test.dart
  </files>
  <action>
All gap-fill tests use `all_types.sql` schema (via `schemaPath('all_types.sql')`). Follow existing patterns: `test()` function, `Database.fromSchema(':memory:', ...)`, create elements, call operations, `expect()` assertions, `db.close()`.

**Step 1: Add to `bindings/dart/test/database_read_test.dart`:**

Add these tests (9 tests):

- `'reads vector strings bulk'`: Open all_types.sql, create 2 elements, set string vectors via updateVectorStrings, call `readVectorStrings('AllTypes', 'labels')`, expect correct Map results
- `'reads vector strings by id'`: Create element, set string vector, call `readVectorStringsById('AllTypes', 'labels', 1)`, expect values match
- `'reads set integers bulk'`: Create 2 elements, set integer sets, call `readSetIntegers('AllTypes', 'codes')`, expect correct results
- `'reads set integers by id'`: Create element, set integer set, call `readSetIntegersById('AllTypes', 'codes', 1)`, expect values
- `'reads set floats bulk'`: Create 2 elements, set float sets, call `readSetFloats('AllTypes', 'weights')`, expect correct results
- `'reads set floats by id'`: Create element, set float set, call `readSetFloatsById('AllTypes', 'weights', 1)`, expect values
- `'reads vector strings by id empty'`: Create element without vectors, expect empty list
- `'reads set integers by id empty'`: Create element without sets, expect empty list
- `'reads set floats by id empty'`: Create element without sets, expect empty list

**Step 2: Add to `bindings/dart/test/database_update_test.dart`:**

Add these tests (3 tests):

- `'updates vector strings'`: Create element, call `updateVectorStrings('AllTypes', 1, 'labels', ['alpha', 'beta'])`, read back, verify
- `'updates set integers'`: Create element, call `updateSetIntegers('AllTypes', 1, 'codes', [10, 20, 30])`, read back, verify (sort for comparison)
- `'updates set floats'`: Create element, call `updateSetFloats('AllTypes', 1, 'weights', [1.1, 2.2])`, read back, verify

**Step 3: Add to `bindings/dart/test/database_lifecycle_test.dart`:**

- `'describe does not throw'`: Open DB from basic.sql, call `db.describe()`, expect no exception

**Step 4: Add to `bindings/dart/test/metadata_test.dart`:**

- `'reads set group by id'`: Open all_types.sql, create element, set integer codes, call `readSetGroupById('AllTypes', 'codes', 1)`, verify returns list of row maps

**Step 5: Run Dart tests.**

```bash
bindings/dart/test/test.bat
```

Verify all tests pass.
  </action>
  <verify>
Run `bindings/dart/test/test.bat` -- all tests pass with zero failures.
  </verify>
  <done>
Dart database_read_test.dart has 9 new tests. database_update_test.dart has 3 new tests. database_lifecycle_test.dart has 1 describe test. metadata_test.dart has 1 readSetGroupById test. All Dart tests pass.
  </done>
</task>

</tasks>

<verification>
1. `bindings/julia/test/test.bat` passes all tests including 14 new gap-fill tests
2. `bindings/dart/test/test.bat` passes all tests including 14 new gap-fill tests
3. New tests use all_types.sql schema from Plan 01 for string vectors, integer sets, float sets
4. Both layers test describe() and set group convenience methods
</verification>

<success_criteria>
- Julia has happy-path tests for all operations in the C++ reference layer
- Dart has happy-path tests for all operations in the C++ reference layer
- Both layers test their convenience methods (read_set_group_by_id)
- Both test suites produce zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/07-test-parity/07-02-SUMMARY.md`
</output>
