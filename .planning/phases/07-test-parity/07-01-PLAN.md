---
phase: 07-test-parity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/schemas/valid/all_types.sql
  - tests/test_database_read.cpp
  - tests/test_database_update.cpp
  - tests/test_database_lifecycle.cpp
  - tests/test_c_api_database_read.cpp
  - tests/test_c_api_database_update.cpp
  - tests/test_c_api_database_metadata.cpp
  - tests/test_c_api_database_lifecycle.cpp
  - tests/CMakeLists.txt
autonomous: true
requirements:
  - TEST-02
  - TEST-03

must_haves:
  truths:
    - "C++ has happy-path tests for every public read/update operation including string vectors, integer sets, and float sets"
    - "C API has a dedicated metadata test file and happy-path tests for every read/update/metadata operation"
    - "A new all_types.sql schema provides string vectors, integer sets, and float sets for gap-fill tests"
    - "C++ and C API test suites pass with zero failures"
  artifacts:
    - path: "tests/schemas/valid/all_types.sql"
      provides: "Schema with string vectors, integer sets, float sets for type coverage"
      contains: "all_types_vector_labels"
    - path: "tests/test_database_read.cpp"
      provides: "Gap-fill tests for read_vector_strings, read_set_integers, read_set_floats, read_set_integers_by_id, read_set_floats_by_id, read_vector_strings_by_id"
    - path: "tests/test_database_update.cpp"
      provides: "Gap-fill tests for update_vector_strings, update_set_integers, update_set_floats"
    - path: "tests/test_c_api_database_metadata.cpp"
      provides: "Dedicated C API metadata test file with get_vector_metadata, get_set_metadata, list_vector_groups, list_set_groups"
    - path: "tests/test_c_api_database_read.cpp"
      provides: "Gap-fill happy-path tests for read_vector_strings, read_set_integers, read_set_floats, read_set_integers_by_id, read_set_floats_by_id, read_vector_strings_by_id"
    - path: "tests/test_c_api_database_update.cpp"
      provides: "Gap-fill happy-path tests for update_vector_strings, update_set_integers, update_set_floats"
  key_links:
    - from: "tests/schemas/valid/all_types.sql"
      to: "tests/test_database_read.cpp"
      via: "SCHEMA_PATH macro"
      pattern: 'SCHEMA_PATH\("all_types.sql"\)'
    - from: "tests/test_c_api_database_metadata.cpp"
      to: "tests/CMakeLists.txt"
      via: "CMake test target registration"
      pattern: "test_c_api_database_metadata"
---

<objective>
Create a new all_types.sql schema for type coverage, then fill all identified gaps in C++ and C API test layers.

Purpose: C++ is the reference layer. It must have complete happy-path coverage before other layers can be audited against it. The C API must mirror C++ test structure with a dedicated metadata test file.

Output: New schema file, gap-fill tests in C++ read/update files, new C API metadata test file, gap-fill tests in C API read/update/lifecycle files. Both C++ and C API suites pass.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-test-parity/07-RESEARCH.md
@tests/schemas/valid/collections.sql
@tests/schemas/valid/relations.sql
@tests/test_database_read.cpp
@tests/test_database_update.cpp
@tests/test_database_lifecycle.cpp
@tests/test_c_api_database_read.cpp
@tests/test_c_api_database_update.cpp
@tests/test_c_api_database_lifecycle.cpp
@tests/test_c_api_database_csv.cpp
@tests/CMakeLists.txt
@include/quiver/database.h
@include/quiver/c/database.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create all_types.sql schema and fill C++ test gaps</name>
  <files>
    tests/schemas/valid/all_types.sql
    tests/test_database_read.cpp
    tests/test_database_update.cpp
    tests/test_database_lifecycle.cpp
  </files>
  <action>
**Step 1: Create `tests/schemas/valid/all_types.sql`** with a schema that covers all type combinations missing from existing schemas:

```sql
PRAGMA foreign_keys = ON;

CREATE TABLE Configuration (
    id INTEGER PRIMARY KEY,
    label TEXT UNIQUE NOT NULL
) STRICT;

CREATE TABLE AllTypes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    label TEXT UNIQUE NOT NULL,
    some_integer INTEGER,
    some_float REAL,
    some_text TEXT
) STRICT;

-- String vector (missing from all existing schemas)
CREATE TABLE AllTypes_vector_labels (
    id INTEGER NOT NULL REFERENCES AllTypes(id) ON DELETE CASCADE ON UPDATE CASCADE,
    vector_index INTEGER NOT NULL,
    value TEXT NOT NULL,
    PRIMARY KEY (id, vector_index)
) STRICT;

-- Integer vector (for completeness)
CREATE TABLE AllTypes_vector_counts (
    id INTEGER NOT NULL REFERENCES AllTypes(id) ON DELETE CASCADE ON UPDATE CASCADE,
    vector_index INTEGER NOT NULL,
    value INTEGER NOT NULL,
    PRIMARY KEY (id, vector_index)
) STRICT;

-- Integer set (missing from non-FK schemas)
CREATE TABLE AllTypes_set_codes (
    id INTEGER NOT NULL REFERENCES AllTypes(id) ON DELETE CASCADE ON UPDATE CASCADE,
    value INTEGER NOT NULL,
    UNIQUE (id, value)
) STRICT;

-- Float set (missing from all existing schemas)
CREATE TABLE AllTypes_set_weights (
    id INTEGER NOT NULL REFERENCES AllTypes(id) ON DELETE CASCADE ON UPDATE CASCADE,
    value REAL NOT NULL,
    UNIQUE (id, value)
) STRICT;

-- String set (for completeness)
CREATE TABLE AllTypes_set_tags (
    id INTEGER NOT NULL REFERENCES AllTypes(id) ON DELETE CASCADE ON UPDATE CASCADE,
    value TEXT NOT NULL,
    UNIQUE (id, value)
) STRICT;
```

**Step 2: Add gap-fill tests to `tests/test_database_read.cpp`.**

Add the following test cases using `all_types.sql` schema. Follow the existing test pattern in the file (use `SCHEMA_PATH("all_types.sql")`, create elements with `Element().set(...)`, then read and assert). Each test should be a single happy-path test:

- `ReadVectorStringsBulk`: Create 2 elements with string vectors via `update_vector_strings`, call `read_vector_strings("AllTypes", "labels")`, assert correct results
- `ReadVectorStringsByIdBasic`: Create element, set string vector, call `read_vector_strings_by_id("AllTypes", "labels", 1)`, assert values
- `ReadSetIntegersBulk`: Create 2 elements with integer sets via `update_set_integers`, call `read_set_integers("AllTypes", "codes")`, assert results
- `ReadSetIntegersByIdBasic`: Create element, set integer set, call `read_set_integers_by_id("AllTypes", "codes", 1)`, assert values
- `ReadSetFloatsBulk`: Create 2 elements with float sets via `update_set_floats`, call `read_set_floats("AllTypes", "weights")`, assert results
- `ReadSetFloatsByIdBasic`: Create element, set float set, call `read_set_floats_by_id("AllTypes", "weights", 1)`, assert values

**Step 3: Add gap-fill tests to `tests/test_database_update.cpp`.**

Add using `all_types.sql`:

- `UpdateVectorStringsBasic`: Create element, call `update_vector_strings("AllTypes", 1, "labels", {"alpha", "beta"})`, read back and verify
- `UpdateSetIntegersBasic`: Create element, call `update_set_integers("AllTypes", 1, "codes", {10, 20, 30})`, read back and verify
- `UpdateSetFloatsBasic`: Create element, call `update_set_floats("AllTypes", 1, "weights", {1.1, 2.2})`, read back and verify

**Step 4: Add describe test to `tests/test_database_lifecycle.cpp`.**

- `DescribeDoesNotThrow`: Open DB from `basic.sql`, call `db.describe()`, assert no exception thrown (describe outputs to stdout, just verify it doesn't crash)

**Step 5: Build and run C++ tests.**

```bash
cmake --build build --config Debug && ./build/bin/quiver_tests.exe
```

Verify all tests pass including the new ones.
  </action>
  <verify>
Run `cmake --build build --config Debug && ./build/bin/quiver_tests.exe` -- all tests pass with zero failures. New test names visible in output.
  </verify>
  <done>
all_types.sql exists with string vector, integer set, and float set tables. C++ test_database_read.cpp has 6 new gap-fill tests. test_database_update.cpp has 3 new tests. test_database_lifecycle.cpp has 1 describe test. All C++ tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fill C API test gaps including new metadata test file</name>
  <files>
    tests/test_c_api_database_metadata.cpp
    tests/test_c_api_database_read.cpp
    tests/test_c_api_database_update.cpp
    tests/test_c_api_database_lifecycle.cpp
    tests/CMakeLists.txt
  </files>
  <action>
**Step 1: Create `tests/test_c_api_database_metadata.cpp`** -- a new dedicated C API metadata test file.

Follow the pattern from `test_c_api_database_csv.cpp` for includes and test structure (use `#include "quiver/c/database.h"`, `#include &lt;gtest/gtest.h&gt;`, open DB via `quiver_database_from_schema`). Add these happy-path tests:

- `GetVectorMetadata`: Open `collections.sql`, call `quiver_database_get_vector_metadata(db, "Collection", "values", &metadata)`, assert `QUIVER_OK`, check `metadata.group_name` equals "values", free metadata, close db
- `GetSetMetadata`: Open `collections.sql`, call `quiver_database_get_set_metadata(db, "Collection", "tags", &metadata)`, assert `QUIVER_OK`, check `metadata.group_name` equals "tags", free metadata, close db
- `GetTimeSeriesMetadata`: Open `collections.sql`, call `quiver_database_get_time_series_metadata(db, "Collection", "data", &metadata)`, assert `QUIVER_OK`, check dimension_column is not NULL, free, close
- `ListVectorGroups`: Open `collections.sql`, call `quiver_database_list_vector_groups(db, "Collection", &groups, &count)`, assert `QUIVER_OK`, check count >= 1, free group metadata array, close
- `ListSetGroups`: Open `collections.sql`, call `quiver_database_list_set_groups(db, "Collection", &groups, &count)`, assert `QUIVER_OK`, check count >= 1, free, close
- `ListTimeSeriesGroups`: Open `collections.sql`, call `quiver_database_list_time_series_groups(db, "Collection", &groups, &count)`, assert `QUIVER_OK`, check count >= 1, free, close
- `ListScalarAttributes`: Open `collections.sql`, call `quiver_database_list_scalar_attributes(db, "Collection", &attrs, &count)`, assert `QUIVER_OK`, check count >= 1, free, close

**Step 2: Register `test_c_api_database_metadata.cpp` in `tests/CMakeLists.txt`.**

Add `test_c_api_database_metadata.cpp` to the `quiver_c_tests` target's source list, following the pattern of other `test_c_api_database_*.cpp` files.

**Step 3: Add gap-fill happy-path tests to `tests/test_c_api_database_read.cpp`.**

Using `all_types.sql` (create elements and populate data first via C API `quiver_database_create_element` + update calls):

- `ReadVectorStringsHappyPath`: Create element in AllTypes, set string vector, call `quiver_database_read_vector_strings`, assert success and correct values, free string array
- `ReadVectorStringsByIdHappyPath`: Create element, set string vector, call `quiver_database_read_vector_strings_by_id`, assert values, free
- `ReadSetIntegersHappyPath`: Create element, set integer set, call `quiver_database_read_set_integers`, assert, free
- `ReadSetIntegersByIdHappyPath`: Same pattern for by_id variant
- `ReadSetFloatsHappyPath`: Create element, set float set, call `quiver_database_read_set_floats`, assert, free
- `ReadSetFloatsByIdHappyPath`: Same for by_id

**Step 4: Add gap-fill happy-path tests to `tests/test_c_api_database_update.cpp`.**

- `UpdateVectorStringsHappyPath`: Create element, call `quiver_database_update_vector_strings`, read back via C API, verify
- `UpdateSetIntegersHappyPath`: Create element, call `quiver_database_update_set_integers`, read back, verify
- `UpdateSetFloatsHappyPath`: Create element, call `quiver_database_update_set_floats`, read back, verify

**Step 5: Add describe test to `tests/test_c_api_database_lifecycle.cpp`.**

- `DescribeDoesNotFail`: Open DB from `basic.sql`, call `quiver_database_describe(db)`, assert `QUIVER_OK`, close

**Step 6: Build and run C API tests.**

```bash
cmake --build build --config Debug && ./build/bin/quiver_c_tests.exe
```

Verify all tests pass.
  </action>
  <verify>
Run `cmake --build build --config Debug && ./build/bin/quiver_c_tests.exe` -- all tests pass with zero failures. New metadata test file appears in build output.
  </verify>
  <done>
test_c_api_database_metadata.cpp exists with 7 metadata tests. test_c_api_database_read.cpp has 6 new happy-path tests. test_c_api_database_update.cpp has 3 new tests. test_c_api_database_lifecycle.cpp has 1 describe test. CMakeLists.txt updated. All C API tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` completes without errors
2. `./build/bin/quiver_tests.exe` passes all tests (including 10 new C++ tests)
3. `./build/bin/quiver_c_tests.exe` passes all tests (including 17 new C API tests)
4. `tests/schemas/valid/all_types.sql` exists and is syntactically valid
5. `tests/test_c_api_database_metadata.cpp` exists as a new test file
</verification>

<success_criteria>
- C++ has complete happy-path coverage for all public read/update operations across all type combinations
- C API mirrors C++ test file structure with dedicated metadata test file
- New all_types.sql schema fills the type coverage gap (string vectors, integer sets, float sets)
- Both C++ and C API test suites produce zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/07-test-parity/07-01-SUMMARY.md`
</output>
