---
phase: 03-writes-and-transactions
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - bindings/python/src/quiver/_c_api.py
  - bindings/python/src/quiver/database.py
  - bindings/python/tests/test_database_transaction.py
autonomous: true
requirements: [TXN-01, TXN-02]

must_haves:
  truths:
    - "begin_transaction starts an explicit transaction"
    - "commit persists changes made within a transaction"
    - "rollback discards changes made within a transaction"
    - "in_transaction returns True when a transaction is active, False otherwise"
    - "with db.transaction() as db: auto-commits on successful block exit"
    - "with db.transaction() as db: auto-rolls-back on exception and re-raises"
  artifacts:
    - path: "bindings/python/src/quiver/_c_api.py"
      provides: "CFFI declarations for transaction functions"
      contains: "quiver_database_begin_transaction"
    - path: "bindings/python/src/quiver/database.py"
      provides: "Transaction methods and context manager"
      contains: "def transaction"
    - path: "bindings/python/tests/test_database_transaction.py"
      provides: "Tests for explicit transactions and context manager"
      min_lines: 60
  key_links:
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "CFFI lib calls for transaction control"
      pattern: "lib\\.quiver_database_(begin_transaction|commit|rollback|in_transaction)"
    - from: "bindings/python/src/quiver/database.py"
      to: "contextlib"
      via: "@contextmanager decorator for transaction()"
      pattern: "from contextlib import contextmanager"
---

<objective>
Add explicit transaction control and a transaction context manager to the Python bindings.

Purpose: Enables Python code to batch multiple writes in a single transaction for atomicity and performance, with Pythonic `with` statement support for automatic commit/rollback.
Output: 4 CFFI declarations, 5 Database methods (begin_transaction, commit, rollback, in_transaction, transaction context manager), 1 test file.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-writes-and-transactions/03-RESEARCH.md
@.planning/phases/03-writes-and-transactions/03-01-SUMMARY.md

@bindings/python/src/quiver/_c_api.py
@bindings/python/src/quiver/database.py
@bindings/python/tests/conftest.py
@bindings/julia/test/test_database_transaction.jl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Transaction CFFI declarations and Database methods</name>
  <files>
    bindings/python/src/quiver/_c_api.py
    bindings/python/src/quiver/database.py
  </files>
  <action>
Add CFFI declarations to _c_api.py ffi.cdef() block for the 4 transaction functions. Append after the write operation declarations added in Plan 03-01:

```
// Transaction control
quiver_error_t quiver_database_begin_transaction(quiver_database_t* db);
quiver_error_t quiver_database_commit(quiver_database_t* db);
quiver_error_t quiver_database_rollback(quiver_database_t* db);
quiver_error_t quiver_database_in_transaction(quiver_database_t* db, _Bool* out_active);
```

IMPORTANT: Use `_Bool*` (not `int*`) for `in_transaction` output parameter. This matches the C API header exactly. Using `int*` would cause memory corruption due to type size mismatch (bool=1 byte, int=4 bytes).

Add 5 methods to database.py. Place them after the write methods (update_set_* etc.) and before the scalar reads section:

1. `begin_transaction(self) -> None` -- `self._ensure_open()` then `check(lib.quiver_database_begin_transaction(self._ptr))`.

2. `commit(self) -> None` -- `self._ensure_open()` then `check(lib.quiver_database_commit(self._ptr))`.

3. `rollback(self) -> None` -- `self._ensure_open()` then `check(lib.quiver_database_rollback(self._ptr))`.

4. `in_transaction(self) -> bool` -- `self._ensure_open()`, allocate `ffi.new("_Bool*")`, call `check(lib.quiver_database_in_transaction(self._ptr, out))`, return `bool(out[0])`.

5. `transaction(self)` -- decorated with `@contextmanager` from `contextlib`. Implementation per user decision:
   ```python
   @contextmanager
   def transaction(self):
       """Execute operations within a transaction. Auto-commits on success, rolls back on exception."""
       self._ensure_open()
       self.begin_transaction()
       try:
           yield self
           self.commit()
       except BaseException:
           try:
               self.rollback()
           except Exception:
               pass  # Best-effort rollback; swallow rollback errors
           raise
   ```

   IMPORTANT: Use `except BaseException` (not `except Exception`) to catch KeyboardInterrupt/SystemExit and ensure rollback. The `raise` re-raises the original exception after rollback. Import `contextmanager` at the top of database.py: `from contextlib import contextmanager`.
  </action>
  <verify>
Run `bindings/python/test/test.bat` -- all existing tests pass (no regressions from adding the methods/declarations). Verify by reading database.py that all 5 methods exist.
  </verify>
  <done>
_c_api.py has 4 transaction CFFI declarations including _Bool* for in_transaction. database.py has begin_transaction, commit, rollback, in_transaction, and transaction context manager. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Transaction test file</name>
  <files>
    bindings/python/tests/test_database_transaction.py
  </files>
  <action>
Create test_database_transaction.py following established test patterns. Reference Julia test structure: `bindings/julia/test/test_database_transaction.jl`. Use `collections_db` fixture (needs the Collection table for element operations within transactions).

Import at top: `import pytest`, `from quiver import Database, Element`.

**Class TestExplicitTransaction:**
- `test_begin_and_commit_persists`: Create Config element first. Begin transaction, create Collection element, commit. Read back labels to verify data persisted.
- `test_begin_and_rollback_discards`: Create Config element. Begin transaction, create Collection element, rollback. Read element_ids to verify element NOT present.
- `test_in_transaction_false_by_default`: Assert `collections_db.in_transaction()` is False.
- `test_in_transaction_true_after_begin`: Begin transaction, assert `in_transaction()` is True, then rollback to clean up.
- `test_in_transaction_false_after_commit`: Begin transaction, commit, assert `in_transaction()` is False.

**Class TestTransactionContextManager:**
- `test_auto_commits_on_success`: Create Config element. Use `with collections_db.transaction() as db:`, create Collection element inside. After with block, read labels to verify persisted.
- `test_auto_rollback_on_exception`: Create Config element. Use try/except around `with collections_db.transaction() as db:`, raise ValueError inside. After except, verify element NOT present via read_element_ids.
- `test_yields_same_db`: Use `with collections_db.transaction() as db:`, assert `db is collections_db`.
- `test_re_raises_original_exception`: Use pytest.raises(ValueError) around `with collections_db.transaction() as db:`, raise ValueError("test error") inside. Verify the ValueError propagates.
- `test_multiple_operations_in_transaction`: Use context manager, create element + update_scalar_integer inside single transaction. Verify both changes persisted after block.

NOTE: The `collections_db` fixture uses `collections.sql` schema which requires a Configuration element before creating Collection elements (FK constraint). Each test that creates Collection elements must first `db.create_element("Configuration", Element().set("label", "Config"))`.
  </action>
  <verify>
Run `bindings/python/test/test.bat` -- all tests pass including the 10 new transaction tests. Expected total: ~115+ tests.
  </verify>
  <done>
test_database_transaction.py has 10 tests covering explicit begin/commit/rollback, in_transaction state, context manager auto-commit, auto-rollback, exception re-raise, and multi-operation transactions. All tests pass with zero failures.
  </done>
</task>

</tasks>

<verification>
1. All existing tests pass (no regressions)
2. All 10 new transaction tests pass
3. `bindings/python/test/test.bat` exits with code 0
4. database.py has begin_transaction, commit, rollback, in_transaction, transaction methods
5. _c_api.py has 4 transaction CFFI declarations with correct _Bool* type
6. Transaction context manager auto-commits on success and rolls back on exception
</verification>

<success_criteria>
- begin_transaction/commit/rollback control explicit transaction state
- in_transaction returns correct boolean reflecting current state
- `with db.transaction() as db:` commits on clean exit
- `with db.transaction() as db:` rolls back on exception and re-raises
- Multiple write operations within a single transaction are atomic
- All tests pass with zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/03-writes-and-transactions/03-02-SUMMARY.md`
</output>
