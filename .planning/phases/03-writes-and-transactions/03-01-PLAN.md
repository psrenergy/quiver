---
phase: 03-writes-and-transactions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/python/src/quiver/_c_api.py
  - bindings/python/src/quiver/database.py
  - bindings/python/tests/test_database_create.py
  - bindings/python/tests/test_database_update.py
  - bindings/python/tests/test_database_delete.py
autonomous: true
requirements: [WRITE-01, WRITE-02, WRITE-03, WRITE-04, WRITE-05, WRITE-06, WRITE-07]

must_haves:
  truths:
    - "create_element returns a positive integer ID for the new element"
    - "update_element changes scalar attributes of an existing element"
    - "delete_element removes an element so read_element_ids no longer includes it"
    - "update_scalar_integer/float/string persist new values readable by read_scalar_*_by_id"
    - "update_scalar_string with None sets the value to NULL"
    - "update_vector_integers/floats/strings replace existing vector data"
    - "update_set_integers/floats/strings replace existing set data"
    - "empty list clears vector/set data"
  artifacts:
    - path: "bindings/python/src/quiver/_c_api.py"
      provides: "CFFI declarations for all write operations"
      contains: "quiver_database_update_element"
    - path: "bindings/python/src/quiver/database.py"
      provides: "update_element, delete_element, 9 update methods"
      contains: "def update_element"
    - path: "bindings/python/tests/test_database_create.py"
      provides: "Tests for create_element"
      min_lines: 20
    - path: "bindings/python/tests/test_database_update.py"
      provides: "Tests for update_element, scalar/vector/set updates"
      min_lines: 80
    - path: "bindings/python/tests/test_database_delete.py"
      provides: "Tests for delete_element"
      min_lines: 15
  key_links:
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "CFFI lib calls for write operations"
      pattern: "lib\\.quiver_database_update_"
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/element.py"
      via: "Element._ptr for update_element and update_scalar_string(None)"
      pattern: "element\\._ptr"
    - from: "bindings/python/tests/test_database_update.py"
      to: "bindings/python/src/quiver/database.py"
      via: "read_*_by_id to verify updates persisted"
      pattern: "read_scalar_integer_by_id|read_vector_integers_by_id"
---

<objective>
Add all write operations (CRUD + scalar/vector/set updates) to the Python bindings with comprehensive tests.

Purpose: Enables Python code to create, update, and delete database elements and modify scalar, vector, and set attributes -- completing the write half of the data access surface.
Output: CFFI declarations for all write C API functions, 11 new Database methods, 3 new test files.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-writes-and-transactions/03-RESEARCH.md

@bindings/python/src/quiver/_c_api.py
@bindings/python/src/quiver/database.py
@bindings/python/src/quiver/element.py
@bindings/python/tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: CFFI declarations and Database write methods</name>
  <files>
    bindings/python/src/quiver/_c_api.py
    bindings/python/src/quiver/database.py
  </files>
  <action>
Add CFFI declarations to _c_api.py ffi.cdef() block for all write operations. Append these declarations AFTER the existing metadata free declarations, before the closing `"""`):

```
// Update element
quiver_error_t quiver_database_update_element(quiver_database_t* db,
    const char* collection, int64_t id, const quiver_element_t* element);
quiver_error_t quiver_database_delete_element(quiver_database_t* db,
    const char* collection, int64_t id);

// Update scalar attributes
quiver_error_t quiver_database_update_scalar_integer(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id, int64_t value);
quiver_error_t quiver_database_update_scalar_float(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id, double value);
quiver_error_t quiver_database_update_scalar_string(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id, const char* value);

// Update vector attributes
quiver_error_t quiver_database_update_vector_integers(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const int64_t* values, size_t count);
quiver_error_t quiver_database_update_vector_floats(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const double* values, size_t count);
quiver_error_t quiver_database_update_vector_strings(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const char* const* values, size_t count);

// Update set attributes
quiver_error_t quiver_database_update_set_integers(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const int64_t* values, size_t count);
quiver_error_t quiver_database_update_set_floats(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const double* values, size_t count);
quiver_error_t quiver_database_update_set_strings(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const char* const* values, size_t count);
```

Add Database methods to database.py. Insert after the existing `create_element` method and before the scalar reads section. Follow C API parameter order: `(collection, attribute, id, value)` for scalar updates, `(collection, attribute, id, values)` for vector/set updates, `(collection, id, element)` for update_element.

Methods to add:

1. `update_element(self, collection: str, id: int, element) -> None` -- calls `quiver_database_update_element(self._ptr, collection.encode("utf-8"), id, element._ptr)` via check().

2. `delete_element(self, collection: str, id: int) -> None` -- calls `quiver_database_delete_element(self._ptr, collection.encode("utf-8"), id)` via check().

3. `update_scalar_integer(self, collection: str, attribute: str, id: int, value: int) -> None` -- simple check() call with encoded strings.

4. `update_scalar_float(self, collection: str, attribute: str, id: int, value: float) -> None` -- same pattern.

5. `update_scalar_string(self, collection: str, attribute: str, id: int, value: str | None) -> None` -- per user decision, if value is None: create a temporary Element, call `e.set(attribute, None)`, then call `quiver_database_update_element` with that Element, destroying it in a try/finally. If value is not None: call `quiver_database_update_scalar_string` directly. Import Element from `quiver.element` inside the None branch to avoid circular imports.

6-8. `update_vector_integers/floats/strings(self, collection: str, attribute: str, id: int, values: list) -> None` -- for empty list: pass `ffi.NULL` with count 0. For non-empty int/float: `ffi.new("int64_t[]", values)` or `ffi.new("double[]", values)`. For strings: encode all values, create `ffi.new("char[]", e)` for each, build `ffi.new("const char*[]", c_strings)`, then call. Keep all references alive until after the C call completes.

9-11. `update_set_integers/floats/strings` -- identical pattern to vector updates, just calling `quiver_database_update_set_*` instead.

Note: `update_scalar_relation` already exists from Phase 2 (WRITE-07). No additional work needed for that requirement.
  </action>
  <verify>
Run `bindings/python/test/test.bat` -- existing 85 tests must still pass (no regressions). Also verify by reading the file that all 11 new methods are present in database.py and all 11 CFFI declarations are in _c_api.py.
  </verify>
  <done>
_c_api.py has 11 new CFFI write declarations. database.py has update_element, delete_element, 3 update_scalar_*, 3 update_vector_*, 3 update_set_* methods. All 85 existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create, update, and delete test files</name>
  <files>
    bindings/python/tests/test_database_create.py
    bindings/python/tests/test_database_update.py
    bindings/python/tests/test_database_delete.py
  </files>
  <action>
Create three new test files following established test patterns (pytest classes, existing fixtures from conftest.py). Reference Julia test files for test case inspiration: `bindings/julia/test/test_database_create.jl`, `bindings/julia/test/test_database_update.jl`, `bindings/julia/test/test_database_delete.jl`.

**test_database_create.py:**
Use `collections_db` fixture. Tests:
- `test_create_element_returns_id`: Create element with label + integer attribute, assert returned ID is positive int.
- `test_create_multiple_elements`: Create two elements, assert IDs are distinct.
- `test_create_with_float_and_string`: Create with float_attribute, string_attribute, verify via reads.
- `test_create_with_arrays`: Create element with `set("tags", ["a", "b"])`, verify vector data via read_vector_strings_by_id.

**test_database_update.py:**
Use `collections_db` fixture. Tests for each update type with create-then-read verification:

Class `TestUpdateElement`:
- `test_update_single_scalar`: Create element, update integer attribute via update_element, verify read.
- `test_update_preserves_other_attributes`: Update one attribute, verify other attributes unchanged.

Class `TestUpdateScalar`:
- `test_update_scalar_integer`: Create, update_scalar_integer, read_scalar_integer_by_id to verify.
- `test_update_scalar_float`: Same pattern for float.
- `test_update_scalar_string`: Same pattern for string.
- `test_update_scalar_string_to_none`: Update string to None, verify read returns None.

Class `TestUpdateVector`:
- `test_update_vector_integers`: Create element, update_vector_integers with [10, 20, 30], read back.
- `test_update_vector_floats`: Same for [1.1, 2.2, 3.3].
- `test_update_vector_strings`: Same for ["a", "b", "c"].
- `test_update_vector_empty_clears`: Set vector, then update with empty list [], read back to verify empty.

Class `TestUpdateSet`:
- `test_update_set_integers`: Create element, update_set_integers with [1, 2, 3], read back.
- `test_update_set_floats`: Same for [1.1, 2.2].
- `test_update_set_strings`: Same for ["tag1", "tag2"].
- `test_update_set_empty_clears`: Set values, then update with [], verify empty.

**test_database_delete.py:**
Use `collections_db` fixture. Tests:
- `test_delete_element`: Create element, delete it, verify read_element_ids returns empty.
- `test_delete_one_of_many`: Create two elements, delete one, verify only one remains.
- `test_delete_cascades_vectors`: Create element with vector data, delete element, verify element gone (cascade handles vector cleanup).

All tests must import from `quiver` (Database, Element). Use the established create-then-operate-then-read pattern. The `collections_db` fixture uses `tests/schemas/valid/collections.sql` schema which has the Collection table with scalar/vector/set attributes.

For tests that need initial data with vectors/sets, first create the element via create_element, then use update_vector_*/update_set_* to add the group data (since create_element only sets scalars and array attributes via Element builder).
  </action>
  <verify>
Run `bindings/python/test/test.bat` -- all tests pass including the new create/update/delete tests. Expected total: ~105+ tests (85 existing + ~20 new).
  </verify>
  <done>
test_database_create.py has 4+ create tests passing. test_database_update.py has 14+ update tests covering update_element, scalar, vector, set operations including None and empty list edge cases. test_database_delete.py has 3+ delete tests passing. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. All 85 existing tests pass (no regressions)
2. All new create/update/delete tests pass
3. `bindings/python/test/test.bat` exits with code 0
4. database.py contains all 11 new write methods
5. _c_api.py contains all 11 new CFFI declarations
</verification>

<success_criteria>
- create_element returns integer IDs (already existed, now has dedicated tests)
- update_element modifies attributes of existing elements
- delete_element removes elements from the database
- update_scalar_integer/float/string persist values readable via by-id reads
- update_scalar_string(None) sets NULL
- update_vector_*/update_set_* replace group data; empty list clears
- update_scalar_relation works (already existed from Phase 2)
- All tests pass with zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/03-writes-and-transactions/03-01-SUMMARY.md`
</output>
