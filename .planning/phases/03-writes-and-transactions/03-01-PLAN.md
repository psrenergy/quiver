---
phase: 03-writes-and-transactions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/c/database_update.cpp
  - bindings/python/src/quiver/_c_api.py
  - bindings/python/src/quiver/database.py
  - bindings/python/tests/test_database_create.py
  - bindings/python/tests/test_database_update.py
  - bindings/python/tests/test_database_delete.py
autonomous: true
requirements: [WRITE-01, WRITE-02, WRITE-03, WRITE-04, WRITE-05, WRITE-06, WRITE-07]

must_haves:
  truths:
    - "create_element returns a positive integer ID for the new element"
    - "update_element changes scalar attributes of an existing element"
    - "delete_element removes an element so read_element_ids no longer includes it"
    - "update_scalar_integer/float/string persist new values readable by read_scalar_*_by_id"
    - "update_scalar_string with None sets the value to NULL in the database"
    - "update_vector_integers/floats/strings replace existing vector data"
    - "update_set_integers/floats/strings replace existing set data"
    - "empty list clears vector/set data"
  artifacts:
    - path: "bindings/python/src/quiver/_c_api.py"
      provides: "CFFI declarations for all write operations"
      contains: "quiver_database_update_element"
    - path: "bindings/python/src/quiver/database.py"
      provides: "update_element, delete_element, 9 update methods"
      contains: "def update_element"
    - path: "bindings/python/tests/test_database_create.py"
      provides: "Tests for create_element"
      min_lines: 20
    - path: "bindings/python/tests/test_database_update.py"
      provides: "Tests for update_element, scalar/vector/set updates"
      min_lines: 80
    - path: "bindings/python/tests/test_database_delete.py"
      provides: "Tests for delete_element"
      min_lines: 15
  key_links:
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/_c_api.py"
      via: "CFFI lib calls for write operations"
      pattern: "lib\\.quiver_database_update_"
    - from: "bindings/python/src/quiver/database.py"
      to: "bindings/python/src/quiver/element.py"
      via: "Element._ptr for update_element"
      pattern: "element\\._ptr"
    - from: "bindings/python/tests/test_database_update.py"
      to: "bindings/python/src/quiver/database.py"
      via: "read_*_by_id to verify updates persisted"
      pattern: "read_scalar_integer_by_id|read_vector_integers_by_id"
---

<objective>
Add all write operations (CRUD + scalar/vector/set updates) to the Python bindings with comprehensive tests.

Purpose: Enables Python code to create, update, and delete database elements and modify scalar, vector, and set attributes -- completing the write half of the data access surface.
Output: C API fix for NULL string support, CFFI declarations for all write C API functions, 11 new Database methods, 3 new test files.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-writes-and-transactions/03-RESEARCH.md

@bindings/python/src/quiver/_c_api.py
@bindings/python/src/quiver/database.py
@bindings/python/src/quiver/element.py
@bindings/python/tests/conftest.py
@tests/schemas/valid/collections.sql
@src/c/database_update.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: C API NULL string fix, CFFI declarations, and Database write methods</name>
  <files>
    src/c/database_update.cpp
    bindings/python/src/quiver/_c_api.py
    bindings/python/src/quiver/database.py
  </files>
  <action>
**Step 1: Fix C API to accept NULL for update_scalar_string.**

In `src/c/database_update.cpp`, find `quiver_database_update_scalar_string` (around line 43-57). Change line 48 from:
```cpp
QUIVER_REQUIRE(db, collection, attribute, value);
```
to:
```cpp
QUIVER_REQUIRE(db, collection, attribute);
```

Then update the try block body to handle NULL value by executing `UPDATE ... SET attribute = NULL WHERE id = ?` when value is nullptr:
```cpp
try {
    if (value) {
        db->db.update_scalar_string(collection, attribute, id, value);
    } else {
        // NULL value -- execute raw UPDATE SET attr = NULL
        auto sql = std::string("UPDATE ") + collection + " SET " + attribute + " = NULL WHERE id = ?";
        db->db.query_string(sql, {id});
    }
    return QUIVER_OK;
} catch (const std::exception& e) {
    quiver_set_last_error(e.what());
    return QUIVER_ERROR;
}
```

This allows Python (and all other FFI bindings) to pass NULL to set a string scalar to NULL without workarounds. After this change, rebuild: `cmake --build build --config Debug` and verify C++ tests still pass: `./build/bin/quiver_c_tests.exe`.

**Step 2: Add CFFI declarations to _c_api.py.**

Append these declarations to the ffi.cdef() block AFTER the existing metadata free declarations, before the closing `"""`:

```
// Update element
quiver_error_t quiver_database_update_element(quiver_database_t* db,
    const char* collection, int64_t id, const quiver_element_t* element);
quiver_error_t quiver_database_delete_element(quiver_database_t* db,
    const char* collection, int64_t id);

// Update scalar attributes
quiver_error_t quiver_database_update_scalar_integer(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id, int64_t value);
quiver_error_t quiver_database_update_scalar_float(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id, double value);
quiver_error_t quiver_database_update_scalar_string(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id, const char* value);

// Update vector attributes
quiver_error_t quiver_database_update_vector_integers(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const int64_t* values, size_t count);
quiver_error_t quiver_database_update_vector_floats(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const double* values, size_t count);
quiver_error_t quiver_database_update_vector_strings(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const char* const* values, size_t count);

// Update set attributes
quiver_error_t quiver_database_update_set_integers(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const int64_t* values, size_t count);
quiver_error_t quiver_database_update_set_floats(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const double* values, size_t count);
quiver_error_t quiver_database_update_set_strings(quiver_database_t* db,
    const char* collection, const char* attribute, int64_t id,
    const char* const* values, size_t count);
```

**Step 3: Add Database methods to database.py.**

Insert after the existing `create_element` method and before the scalar reads section. Follow C API parameter order: `(collection, attribute, id, value)` for scalar updates, `(collection, attribute, id, values)` for vector/set updates, `(collection, id, element)` for update_element. Every method MUST start with `lib = get_lib()` as its first statement (matching the established pattern in all existing methods).

Methods to add:

1. `update_element(self, collection: str, id: int, element) -> None`:
   ```python
   def update_element(self, collection: str, id: int, element) -> None:
       self._ensure_open()
       lib = get_lib()
       check(lib.quiver_database_update_element(
           self._ptr, collection.encode("utf-8"), id, element._ptr))
   ```

2. `delete_element(self, collection: str, id: int) -> None`:
   ```python
   def delete_element(self, collection: str, id: int) -> None:
       self._ensure_open()
       lib = get_lib()
       check(lib.quiver_database_delete_element(
           self._ptr, collection.encode("utf-8"), id))
   ```

3. `update_scalar_integer(self, collection: str, attribute: str, id: int, value: int) -> None`:
   ```python
   def update_scalar_integer(self, collection, attribute, id, value):
       self._ensure_open()
       lib = get_lib()
       check(lib.quiver_database_update_scalar_integer(
           self._ptr, collection.encode("utf-8"), attribute.encode("utf-8"), id, value))
   ```

4. `update_scalar_float(self, collection: str, attribute: str, id: int, value: float) -> None` -- same pattern as integer.

5. `update_scalar_string(self, collection: str, attribute: str, id: int, value: str | None) -> None`:
   ```python
   def update_scalar_string(self, collection, attribute, id, value):
       self._ensure_open()
       lib = get_lib()
       c_value = value.encode("utf-8") if value is not None else ffi.NULL
       check(lib.quiver_database_update_scalar_string(
           self._ptr, collection.encode("utf-8"), attribute.encode("utf-8"), id, c_value))
   ```
   This works because the C API now accepts NULL for the value parameter (Step 1 fix). No Element workaround needed.

6-8. `update_vector_integers/floats/strings(self, collection: str, attribute: str, id: int, values: list) -> None`:
   ```python
   def update_vector_integers(self, collection, attribute, id, values):
       self._ensure_open()
       lib = get_lib()
       if not values:
           check(lib.quiver_database_update_vector_integers(
               self._ptr, collection.encode("utf-8"), attribute.encode("utf-8"),
               id, ffi.NULL, 0))
       else:
           c_arr = ffi.new("int64_t[]", values)
           check(lib.quiver_database_update_vector_integers(
               self._ptr, collection.encode("utf-8"), attribute.encode("utf-8"),
               id, c_arr, len(values)))
   ```
   For floats: same pattern with `ffi.new("double[]", values)` and `quiver_database_update_vector_floats`.
   For strings: encode all values, create `ffi.new("char[]", e)` for each, build `ffi.new("const char*[]", c_strings)`, then call. Keep all references alive until after the C call completes.

9-11. `update_set_integers/floats/strings` -- identical pattern to vector updates, just calling `quiver_database_update_set_*` instead.

Note: `update_scalar_relation` already exists from Phase 2 (WRITE-07). No additional work needed for that requirement.
  </action>
  <verify>
Build the C++ library: `cmake --build build --config Debug`. Run C++ tests: `./build/bin/quiver_c_tests.exe` -- all must pass. Run `bindings/python/test/test.bat` -- existing 85 tests must still pass (no regressions). Also verify by reading the file that all 11 new methods are present in database.py and all 11 CFFI declarations are in _c_api.py.
  </verify>
  <done>
src/c/database_update.cpp accepts NULL value for update_scalar_string. _c_api.py has 11 new CFFI write declarations. database.py has update_element, delete_element, 3 update_scalar_*, 3 update_vector_*, 3 update_set_* methods (all using `lib = get_lib()`). All C++ tests and existing Python tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create, update, and delete test files</name>
  <files>
    bindings/python/tests/test_database_create.py
    bindings/python/tests/test_database_update.py
    bindings/python/tests/test_database_delete.py
  </files>
  <action>
Create three new test files following established test patterns (pytest classes, existing fixtures from conftest.py). Reference Julia test files for test case inspiration: `bindings/julia/test/test_database_create.jl`, `bindings/julia/test/test_database_update.jl`, `bindings/julia/test/test_database_delete.jl`.

IMPORTANT: The `collections_db` fixture uses `tests/schemas/valid/collections.sql` which defines:
- `Configuration` table: `id`, `label` (required first due to FK)
- `Collection` table: `id`, `label` (TEXT UNIQUE NOT NULL), `some_integer` (INTEGER), `some_float` (REAL) -- NO string scalar attribute
- `Collection_vector_values`: multi-column vector with `value_int` (INTEGER) and `value_float` (REAL) columns
- `Collection_set_tags`: set with `tag` (TEXT) column
- `Collection_time_series_data`: time series

For tests that need a string scalar attribute, use the `db` fixture (which uses `basic.sql` with `Configuration` table having `string_attribute`, `integer_attribute`, `float_attribute`).

**test_database_create.py:**
Use `collections_db` fixture for most tests. Tests:
- `test_create_element_returns_id`: Create element with `label="Item1"` + `some_integer=42`, assert returned ID is positive int.
- `test_create_multiple_elements`: Create two elements with distinct labels, assert IDs are distinct.
- `test_create_with_float`: Create with `some_float=3.14`, verify via `read_scalar_float_by_id`.
- `test_create_with_set_array`: Create element, then use `update_set_strings` to add tags `["a", "b"]`, verify via `read_set_strings_by_id` (NOT read_vector -- "tags" is a SET in collections.sql).

**test_database_update.py:**
Use `collections_db` fixture. All Collection elements require a Configuration element first (FK constraint). Tests for each update type with create-then-read verification:

Class `TestUpdateElement`:
- `test_update_single_scalar`: Create element, update `some_integer` attribute via update_element with `Element().set("some_integer", 99)`, verify read.
- `test_update_preserves_other_attributes`: Update `some_integer`, verify `some_float` unchanged.

Class `TestUpdateScalar`:
- `test_update_scalar_integer`: Create, `update_scalar_integer("Collection", "some_integer", id, 100)`, read_scalar_integer_by_id to verify.
- `test_update_scalar_float`: Same pattern for `some_float`.
- `test_update_scalar_string_to_none`: Use the `db` fixture (basic.sql schema) which has `string_attribute`. Create element with string value, update to None via `update_scalar_string("Configuration", "string_attribute", id, None)`, verify read returns None.
- `test_update_scalar_string`: Use the `db` fixture (basic.sql). Create element with `string_attribute="hello"`, update to "world", verify via read.

Class `TestUpdateVector`:
- `test_update_vector_integers`: Create element, `update_vector_integers("Collection", "value_int", id, [10, 20, 30])`, read back via `read_vector_integers_by_id`.
- `test_update_vector_floats`: Same for `value_float` with `[1.1, 2.2, 3.3]`.
- `test_update_vector_empty_clears`: Set vector, then update with empty list [], read back to verify empty.

Class `TestUpdateSet`:
- `test_update_set_strings`: Create element, `update_set_strings("Collection", "tag", id, ["tag1", "tag2"])`, read back via `read_set_strings_by_id`.
- `test_update_set_empty_clears`: Set values, then update with [], verify empty.

NOTE: The `Collection_vector_values` table has `value_int` and `value_float` columns (NOT `value`). The `Collection_set_tags` table has `tag` column (NOT `tags` or `value`). Use exact column names as vector/set attribute names.

**test_database_delete.py:**
Use `collections_db` fixture. Tests:
- `test_delete_element`: Create element, delete it, verify read_element_ids returns empty list (excluding Configuration elements).
- `test_delete_one_of_many`: Create two elements, delete one, verify only one remains.
- `test_delete_cascades_vectors`: Create element, add vector data via update_vector_integers, delete element, verify element gone (cascade handles vector cleanup).

All tests must import from `quiver` (Database, Element). Use the established create-then-operate-then-read pattern.
  </action>
  <verify>
Run `bindings/python/test/test.bat` -- all tests pass including the new create/update/delete tests. Expected total: ~100+ tests (85 existing + ~15 new).
  </verify>
  <done>
test_database_create.py has 4 create tests passing with correct schema references. test_database_update.py has 10+ update tests covering update_element, scalar, vector, set operations including None and empty list edge cases, using correct attribute names from collections.sql and basic.sql. test_database_delete.py has 3 delete tests passing. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. C++ tests pass after database_update.cpp change (`./build/bin/quiver_c_tests.exe`)
2. All 85 existing Python tests pass (no regressions)
3. All new create/update/delete tests pass
4. `bindings/python/test/test.bat` exits with code 0
5. database.py contains all 11 new write methods with `lib = get_lib()` pattern
6. _c_api.py contains all 11 new CFFI declarations
</verification>

<success_criteria>
- create_element returns integer IDs (already existed, now has dedicated tests)
- update_element modifies attributes of existing elements
- delete_element removes elements from the database
- update_scalar_integer/float/string persist values readable via by-id reads
- update_scalar_string(None) sets NULL via C API NULL passthrough (no Element workaround)
- update_vector_*/update_set_* replace group data; empty list clears
- update_scalar_relation works (already existed from Phase 2)
- All tests pass with zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/03-writes-and-transactions/03-01-SUMMARY.md`
</output>
