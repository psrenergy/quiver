---
phase: 02-create-element-fk-resolution
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - tests/test_database_relations.cpp
autonomous: true
requirements: [CRE-01, CRE-02, CRE-04]

must_haves:
  truths:
    - "Test proves scalar FK label resolves to integer ID in create_element"
    - "Test proves vector FK labels resolve to integer IDs in create_element"
    - "Test proves time series FK labels resolve to integer IDs in create_element"
    - "Test proves a single create_element call with scalar+vector+set+time series FKs resolves all labels in one pre-resolve pass"
    - "Test proves create_element with zero FK columns still works after the pre-resolve pass is added"
    - "Test proves resolution failure causes zero partial writes"
  artifacts:
    - path: "tests/test_database_relations.cpp"
      provides: "Comprehensive FK label resolution tests for all column types"
      contains: "CreateElementScalarFkLabel"
  key_links:
    - from: "tests/test_database_relations.cpp"
      to: "src/database_create.cpp"
      via: "Tests call db.create_element() with FK labels and verify resolved IDs via read methods"
      pattern: "create_element.*read_scalar_integers|read_vector_integers|read_set_integers"
---

<objective>
Add comprehensive tests for FK label resolution in `create_element` covering scalar, vector, time series, combined all-types, no-FK regression, and error cases.

Purpose: Verify that the pre-resolve pass correctly resolves FK labels for all column types and that no regressions exist for non-FK schemas.
Output: New test cases in `test_database_relations.cpp` proving CRE-01, CRE-02, CRE-04 requirements.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-create-element-fk-resolution/02-RESEARCH.md
@.planning/phases/02-create-element-fk-resolution/02-CONTEXT.md
@.planning/phases/02-create-element-fk-resolution/02-01-SUMMARY.md

@tests/test_database_relations.cpp
@tests/schemas/valid/relations.sql
@include/quiver/element.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-type FK resolution tests</name>
  <files>tests/test_database_relations.cpp</files>
  <action>
Add a new test section in `test_database_relations.cpp` after the existing "FK label resolution" section. Use this section header:

```cpp
// ============================================================================
// FK label resolution in create_element (all column types)
// ============================================================================
```

Add these 3 tests:

**Test 1: Scalar FK resolution (CRE-01)**

```cpp
TEST(Database, CreateElementScalarFkLabel) {
    auto db = quiver::Database::from_schema(
        ":memory:", VALID_SCHEMA("relations.sql"),
        {.read_only = 0, .console_level = QUIVER_LOG_OFF});

    // Create parent
    quiver::Element parent;
    parent.set("label", std::string("Parent 1"));
    db.create_element("Parent", parent);

    // Create child with scalar FK using string label
    quiver::Element child;
    child.set("label", std::string("Child 1"));
    child.set("parent_id", std::string("Parent 1"));  // string label, not int ID
    db.create_element("Child", child);

    // Verify: read back as integer, should be resolved ID
    auto parent_ids = db.read_scalar_integers("Child", "parent_id");
    ASSERT_EQ(parent_ids.size(), 1);
    EXPECT_EQ(parent_ids[0], 1);  // Parent 1's auto-increment ID
}
```

This test proves CRE-01: a scalar FK column (`parent_id` on `Child` table) resolves a string label to the target's integer ID.

**Test 2: Vector FK resolution (CRE-02)**

```cpp
TEST(Database, CreateElementVectorFkLabels) {
    auto db = quiver::Database::from_schema(
        ":memory:", VALID_SCHEMA("relations.sql"),
        {.read_only = 0, .console_level = QUIVER_LOG_OFF});

    // Create parents
    quiver::Element p1, p2;
    p1.set("label", std::string("Parent 1"));
    p2.set("label", std::string("Parent 2"));
    db.create_element("Parent", p1);
    db.create_element("Parent", p2);

    // Create child with vector FK using string labels
    // parent_ref routes to Child_vector_refs (and Child_set_parents, but
    // the vector path will use the pre-resolved integer values)
    quiver::Element child;
    child.set("label", std::string("Child 1"));
    child.set("parent_ref", std::vector<std::string>{"Parent 1", "Parent 2"});
    db.create_element("Child", child);

    // Verify: read back vector integers
    auto refs = db.read_vector_integers_by_id("Child", "parent_ref", 1);
    ASSERT_TRUE(refs.has_value());
    ASSERT_EQ(refs->size(), 2);
    EXPECT_EQ((*refs)[0], 1);
    EXPECT_EQ((*refs)[1], 2);
}
```

This test proves CRE-02: vector FK columns resolve string labels to target integer IDs. Note: `parent_ref` routes to both `Child_vector_refs` and `Child_set_parents` via `find_all_tables_for_column`. The pre-resolve pass resolves the labels once, and both insert paths receive the resolved integer values. This also validates that set FK resolution still works through the unified pre-resolve pass (since the same resolved values flow to the set path too).

**Test 3: Time series FK resolution (CRE-04)**

```cpp
TEST(Database, CreateElementTimeSeriesFkLabels) {
    auto db = quiver::Database::from_schema(
        ":memory:", VALID_SCHEMA("relations.sql"),
        {.read_only = 0, .console_level = QUIVER_LOG_OFF});

    // Create parents
    quiver::Element p1, p2;
    p1.set("label", std::string("Parent 1"));
    p2.set("label", std::string("Parent 2"));
    db.create_element("Parent", p1);
    db.create_element("Parent", p2);

    // Create child with time series FK using string labels
    // sponsor_id is unique to Child_time_series_events
    quiver::Element child;
    child.set("label", std::string("Child 1"));
    child.set("date_time", std::vector<std::string>{"2024-01-01", "2024-01-02"});
    child.set("sponsor_id", std::vector<std::string>{"Parent 1", "Parent 2"});
    db.create_element("Child", child);

    // Verify: read time series group and check sponsor_id values
    auto ts_data = db.read_time_series_group("Child", "events", 1);
    ASSERT_EQ(ts_data.size(), 2);

    // Each row is a map with "date_time" and "sponsor_id" keys
    // sponsor_id should be resolved to integer IDs
    auto get_sponsor = [](const auto& row) -> int64_t {
        auto it = row.find("sponsor_id");
        return std::get<int64_t>(it->second);
    };

    EXPECT_EQ(get_sponsor(ts_data[0]), 1);
    EXPECT_EQ(get_sponsor(ts_data[1]), 2);
}
```

This test proves CRE-04: time series FK columns resolve string labels to target integer IDs.

**Important:** Check the actual return type and API of `read_time_series_group` before writing the assertions. Read `include/quiver/database.h` to confirm the signature. If the API returns `vector<map<string, Value>>`, use `std::get<int64_t>(row.at("sponsor_id"))`. Adjust the test accordingly based on the actual API.
  </action>
  <verify>
Build and run: `cmake --build build --config Debug && ./build/bin/quiver_tests.exe --gtest_filter="*CreateElementScalarFkLabel*:*CreateElementVectorFkLabels*:*CreateElementTimeSeriesFkLabels*"` -- all 3 new tests pass.
  </verify>
  <done>
3 new tests exist and pass: `CreateElementScalarFkLabel` (CRE-01), `CreateElementVectorFkLabels` (CRE-02), `CreateElementTimeSeriesFkLabels` (CRE-04).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add combined all-types, no-FK regression, and error tests</name>
  <files>tests/test_database_relations.cpp</files>
  <action>
Add 3 more tests in the same section:

**Test 4: Combined all-types FK resolution in a single create_element call**

Per CONTEXT.md: "Include combined all-types test -- one test exercising scalar FK + vector FK + time series FK in a single create_element call to validate the full pre-resolve pass end-to-end."

```cpp
TEST(Database, CreateElementAllFkTypesInOneCall) {
    auto db = quiver::Database::from_schema(
        ":memory:", VALID_SCHEMA("relations.sql"),
        {.read_only = 0, .console_level = QUIVER_LOG_OFF});

    // Create parents
    quiver::Element p1, p2;
    p1.set("label", std::string("Parent 1"));
    p2.set("label", std::string("Parent 2"));
    db.create_element("Parent", p1);
    db.create_element("Parent", p2);

    // Create child with ALL FK types in one call:
    // - scalar FK: parent_id -> Parent 1
    // - set FK: mentor_id -> Parent 2 (unique to Child_set_mentors)
    // - vector+set FK: parent_ref -> Parent 1 (routes to vector AND set tables)
    // - time series FK: sponsor_id -> Parent 2 (unique to Child_time_series_events)
    quiver::Element child;
    child.set("label", std::string("Child 1"));
    child.set("parent_id", std::string("Parent 1"));                      // scalar FK
    child.set("mentor_id", std::vector<std::string>{"Parent 2"});         // set FK
    child.set("parent_ref", std::vector<std::string>{"Parent 1"});        // vector+set FK
    child.set("date_time", std::vector<std::string>{"2024-01-01"});       // time series dimension
    child.set("sponsor_id", std::vector<std::string>{"Parent 2"});        // time series FK
    db.create_element("Child", child);

    // Verify scalar FK
    auto parent_ids = db.read_scalar_integers("Child", "parent_id");
    ASSERT_EQ(parent_ids.size(), 1);
    EXPECT_EQ(parent_ids[0], 1);

    // Verify set FK (mentor_id)
    auto mentors = db.read_set_integers("Child", "mentor_id");
    ASSERT_EQ(mentors.size(), 1);
    ASSERT_EQ(mentors[0].size(), 1);
    EXPECT_EQ(mentors[0][0], 2);

    // Verify vector FK (parent_ref in Child_vector_refs)
    auto vrefs = db.read_vector_integers_by_id("Child", "parent_ref", 1);
    ASSERT_TRUE(vrefs.has_value());
    ASSERT_EQ(vrefs->size(), 1);
    EXPECT_EQ((*vrefs)[0], 1);

    // Verify time series FK (sponsor_id in Child_time_series_events)
    auto ts_data = db.read_time_series_group("Child", "events", 1);
    ASSERT_EQ(ts_data.size(), 1);
    EXPECT_EQ(std::get<int64_t>(ts_data[0].at("sponsor_id")), 2);
}
```

Adjust the assertions for `read_vector_integers_by_id` and `read_time_series_group` based on the actual API. Check `include/quiver/database.h` if needed.

**Test 5: No-FK regression test**

Per CONTEXT.md: "Include no-FK regression test -- explicit test that create_element with zero FK columns still works after the pre-resolve pass is added."

```cpp
TEST(Database, CreateElementNoFkColumnsUnchanged) {
    auto db = quiver::Database::from_schema(
        ":memory:", VALID_SCHEMA("basic.sql"),
        {.read_only = 0, .console_level = QUIVER_LOG_OFF});

    // basic.sql has no FK columns -- this tests that the pre-resolve pass
    // passes all values through unchanged for schemas with no FKs
    quiver::Element element;
    element.set("label", std::string("Config 1"));
    element.set("integer_attribute", int64_t{42});
    element.set("float_attribute", 3.14);

    int64_t id = db.create_element("Configuration", element);
    EXPECT_EQ(id, 1);

    auto labels = db.read_scalar_strings("Configuration", "label");
    EXPECT_EQ(labels[0], "Config 1");
    auto integers = db.read_scalar_integers("Configuration", "integer_attribute");
    EXPECT_EQ(integers[0], 42);
    auto floats = db.read_scalar_floats("Configuration", "float_attribute");
    EXPECT_DOUBLE_EQ(floats[0], 3.14);
}
```

Check that `basic.sql` exists in `tests/schemas/valid/` and has these columns. If not, use whatever schema has no FK columns and adjust column names.

**Test 6: Scalar FK resolution failure causes zero partial writes**

```cpp
TEST(Database, ScalarFkResolutionFailureCausesNoPartialWrites) {
    auto db = quiver::Database::from_schema(
        ":memory:", VALID_SCHEMA("relations.sql"),
        {.read_only = 0, .console_level = QUIVER_LOG_OFF});

    // Create child with scalar FK referencing nonexistent parent
    quiver::Element child;
    child.set("label", std::string("Orphan Child"));
    child.set("parent_id", std::string("Nonexistent Parent"));

    EXPECT_THROW(db.create_element("Child", child), std::runtime_error);

    // Verify: no child was created (zero partial writes)
    auto labels = db.read_scalar_strings("Child", "label");
    EXPECT_EQ(labels.size(), 0);
}
```

This test proves that the pre-resolve pass runs before the transaction: if resolution fails, no INSERT happens.
  </action>
  <verify>
Build and run: `cmake --build build --config Debug && ./build/bin/quiver_tests.exe --gtest_filter="*CreateElementAllFkTypes*:*CreateElementNoFk*:*ScalarFkResolutionFailure*"` -- all 3 new tests pass. Then run the full test suite: `./build/bin/quiver_tests.exe` -- ALL tests pass (existing + 6 new).
  </verify>
  <done>
6 total new tests exist and pass. Combined all-types test validates the full pre-resolve pass end-to-end. No-FK regression test confirms schemas without FKs are unaffected. Scalar FK failure test confirms zero partial writes on resolution failure. Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` compiles cleanly
2. `./build/bin/quiver_tests.exe` -- all tests pass (existing + 6 new)
3. Each new test name maps to a requirement: `CreateElementScalarFkLabel` (CRE-01), `CreateElementVectorFkLabels` (CRE-02), `CreateElementTimeSeriesFkLabels` (CRE-04)
4. Combined test exercises all 4 FK types in a single `create_element` call
5. No-FK regression test proves the pre-resolve pass is safe for non-FK schemas
6. Scalar FK failure test proves zero partial writes on resolution failure
</verification>

<success_criteria>
- 6 new tests added to `test_database_relations.cpp`
- Per-type tests: scalar FK, vector FK, time series FK
- Combined all-types test in a single `create_element` call
- No-FK regression test with a non-FK schema
- Scalar FK failure test confirming zero partial writes
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-create-element-fk-resolution/02-02-SUMMARY.md`
</output>
