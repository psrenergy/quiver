---
phase: 02-create-element-fk-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/schemas/valid/relations.sql
  - src/database_impl.h
  - src/database_create.cpp
autonomous: true
requirements: [CRE-01, CRE-02, CRE-04]

must_haves:
  truths:
    - "A dedicated pre-resolve pass resolves all FK labels before any SQL writes in create_element"
    - "Scalar FK columns on the collection table resolve string labels to integer IDs"
    - "Vector FK columns on group tables resolve string labels to integer IDs"
    - "Time series FK columns on group tables resolve string labels to integer IDs"
    - "Set FK resolution is unified into the same pre-resolve pass (no more inline resolution)"
    - "Element input is never mutated -- resolved values live in a separate data structure"
    - "A resolution failure on any column type causes zero partial writes"
  artifacts:
    - path: "src/database_impl.h"
      provides: "ResolvedElement struct and resolve_element_fk_labels method on Database::Impl"
      contains: "ResolvedElement"
    - path: "src/database_create.cpp"
      provides: "Refactored create_element using pre-resolve pass before transaction"
    - path: "tests/schemas/valid/relations.sql"
      provides: "Time series FK table for testing"
      contains: "Child_time_series_events"
  key_links:
    - from: "src/database_create.cpp"
      to: "src/database_impl.h"
      via: "create_element calls impl_->resolve_element_fk_labels()"
      pattern: "resolve_element_fk_labels"
    - from: "src/database_impl.h resolve_element_fk_labels"
      to: "src/database_impl.h resolve_fk_label"
      via: "pre-resolve method calls per-value resolve_fk_label for each scalar and array value"
      pattern: "resolve_fk_label"
---

<objective>
Implement the unified pre-resolve pass for FK label resolution in `create_element`, covering scalar, vector, set, and time series FK columns. Extend the test schema with a time series FK table.

Purpose: Enable users to pass string labels for any FK column type in `create_element` and have them automatically resolved to target integer IDs before any SQL writes.
Output: Working pre-resolve infrastructure in `database_impl.h` and refactored `create_element` in `database_create.cpp`.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-create-element-fk-resolution/02-RESEARCH.md
@.planning/phases/02-create-element-fk-resolution/02-CONTEXT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

@src/database_impl.h
@src/database_create.cpp
@include/quiver/element.h
@include/quiver/value.h
@include/quiver/schema.h
@tests/schemas/valid/relations.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend test schema and add ResolvedElement with pre-resolve method</name>
  <files>
    tests/schemas/valid/relations.sql
    src/database_impl.h
  </files>
  <action>
**Schema extension (relations.sql):**

Add a time series FK table to `relations.sql` with a uniquely-named FK column (following the Phase 1 pattern of using unique column names to avoid `find_all_tables_for_column` routing conflicts). The column name must NOT be `parent_ref` (shared with `Child_vector_refs` and `Child_set_parents`).

Add this table after the existing tables:

```sql
CREATE TABLE Child_time_series_events (
    id INTEGER NOT NULL REFERENCES Child(id) ON DELETE CASCADE ON UPDATE CASCADE,
    date_time TEXT NOT NULL,
    sponsor_id INTEGER,
    FOREIGN KEY (sponsor_id) REFERENCES Parent(id) ON DELETE SET NULL ON UPDATE CASCADE,
    PRIMARY KEY (id, date_time)
) STRICT;
```

Key: `sponsor_id` is a unique FK column name for the time series table, avoiding conflicts with `parent_ref` and `mentor_id`.

**ResolvedElement struct and resolve_element_fk_labels method (database_impl.h):**

Add inside the `quiver` namespace (but outside `Database::Impl` struct since it is a plain data type):

```cpp
struct ResolvedElement {
    std::map<std::string, Value> scalars;
    std::map<std::string, std::vector<Value>> arrays;
};
```

Add `#include <map>` and `#include <vector>` to `database_impl.h` includes if not already present.

Add `resolve_element_fk_labels` as a method on `Database::Impl`, after the existing `resolve_fk_label` method:

```cpp
ResolvedElement resolve_element_fk_labels(
    const std::string& collection,
    const Element& element,
    Database& db)
{
    ResolvedElement resolved;

    // Resolve scalars against collection table FK metadata
    const auto* collection_def = schema->get_table(collection);
    for (const auto& [name, value] : element.scalars()) {
        resolved.scalars[name] = resolve_fk_label(*collection_def, name, value, db);
    }

    // Resolve arrays against their respective group table FK metadata
    for (const auto& [array_name, values] : element.arrays()) {
        auto matches = schema->find_all_tables_for_column(collection, array_name);

        // Find the first table match for FK resolution
        // (FK columns have unique names per schema design, so first match is correct;
        //  non-FK columns pass through resolve_fk_label unchanged regardless of table)
        const TableDefinition* resolve_table = nullptr;
        for (const auto& match : matches) {
            const auto* td = schema->get_table(match.table_name);
            if (td) {
                resolve_table = td;
                break;
            }
        }

        std::vector<Value> resolved_values;
        resolved_values.reserve(values.size());
        for (const auto& val : values) {
            if (resolve_table) {
                resolved_values.push_back(resolve_fk_label(*resolve_table, array_name, val, db));
            } else {
                resolved_values.push_back(val);
            }
        }
        resolved.arrays[array_name] = std::move(resolved_values);
    }

    return resolved;
}
```

This method:
- Iterates ALL scalars, resolving each against the collection table's FK metadata (handles CRE-01)
- Iterates ALL arrays, routing each to its group table via `find_all_tables_for_column`, then resolving each value (handles CRE-02 for vectors, CRE-04 for time series, and unifies sets)
- Fails fast on first bad label (resolve_fk_label throws immediately)
- Leaves Element input unchanged (produces separate ResolvedElement)
- Passes non-FK values through unchanged (resolve_fk_label returns them as-is)
  </action>
  <verify>
Build succeeds: `cmake --build build --config Debug` compiles with no errors. The new struct and method are syntactically correct and the schema SQL is valid.
  </verify>
  <done>
`ResolvedElement` struct exists in `database_impl.h`. `resolve_element_fk_labels` method exists on `Database::Impl` and compiles. `relations.sql` contains `Child_time_series_events` table with `sponsor_id` FK column referencing `Parent(id)`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor create_element to use pre-resolve pass</name>
  <files>src/database_create.cpp</files>
  <action>
Refactor `create_element` in `src/database_create.cpp` to call `resolve_element_fk_labels` as a dedicated first pass before the transaction, then use the resolved values for all 4 insert paths.

**Changes to make:**

1. **Add pre-resolve call** after the `scalars.empty()` check and before the `TransactionGuard`:

```cpp
// Pre-resolve pass: resolve all FK labels before any writes
auto resolved = impl_->resolve_element_fk_labels(collection, element, *this);
```

2. **Update type validation** to use resolved scalars instead of original scalars:

```cpp
for (const auto& [name, value] : resolved.scalars) {
    impl_->type_validator->validate_scalar(collection, name, value);
}
```

Note: The original `scalars.empty()` check at line 12 stays as-is (checks the Element input, which is fine -- we just need to know the element has scalars). Type validation moves to after resolution because `resolve_fk_label` already handles the non-FK INTEGER guard, and the TypeValidator then validates resolved values (int64_t for FK columns always passes).

3. **Update scalar INSERT** to use `resolved.scalars` instead of `scalars`:

```cpp
for (const auto& [name, value] : resolved.scalars) {
    ...
}
```

4. **Update array routing** to use `resolved.arrays` instead of `element.arrays()`:

```cpp
const auto& arrays = resolved.arrays;
```

This means the empty-array check, `find_all_tables_for_column` routing, and all insert loops use the resolved array values.

5. **Remove inline set FK resolution** -- the set insert loop (currently at lines 145-150) should no longer call `resolve_fk_label`. Change:

```cpp
// BEFORE (remove this):
auto val = impl_->resolve_fk_label(*table_def, col_name, (*values_ptr)[row_idx], *this);
set_params.push_back(val);

// AFTER (use pre-resolved value directly):
set_params.push_back((*values_ptr)[row_idx]);
```

This makes the set path structurally identical to the vector and time series paths -- all four insert loops just read pre-resolved values.

6. **Ensure the `arrays` variable** in the routing section reads from `resolved.arrays`. The pointers into the resolved arrays map must remain valid throughout the function. Since `resolved` is a local variable on the stack, its maps' addresses are stable for the function's lifetime.

**Important pointer safety note:** The current code stores `const std::vector<Value>*` pointers into `element.arrays()`. After this refactor, pointers must point into `resolved.arrays` instead. Since `resolved` lives on the stack for the entire function, this is safe. The variable `arrays` (line 46) changes from `element.arrays()` to `resolved.arrays`, and all `&values` references in the routing loop (line 55) now point into the resolved map.

**What stays the same:**
- The `scalars.empty()` guard at line 12 (checks original Element)
- The empty-array check at line 56-58 (now on resolved arrays, same semantics)
- All vector/set/time_series INSERT SQL generation
- Transaction guard scope (wraps only INSERT operations)
- All logging
  </action>
  <verify>
Build succeeds: `cmake --build build --config Debug`. Then run existing tests: `./build/bin/quiver_tests.exe` -- ALL existing tests must pass with no regressions. The 3 Phase 1 FK resolution tests (`ResolveFkLabelInSetCreate`, `ResolveFkLabelMissingTarget`, `RejectStringForNonFkIntegerColumn`) must continue to pass, confirming the set path migration to the pre-resolve pass is behavioral-equivalent.
  </verify>
  <done>
`create_element` calls `resolve_element_fk_labels` before the transaction. All 4 insert paths (scalar, vector, set, time series) use pre-resolved values. No inline `resolve_fk_label` call remains in the insert loops. All existing tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` compiles cleanly
2. `./build/bin/quiver_tests.exe` -- all existing tests pass (445 tests)
3. The 3 Phase 1 FK resolution tests pass (set FK, missing label error, non-FK INTEGER guard)
4. No inline `resolve_fk_label` calls remain in the set insert loop of `database_create.cpp`
5. `resolve_element_fk_labels` exists on `Database::Impl` and is called from `create_element`
</verification>

<success_criteria>
- Pre-resolve pass exists as a dedicated method on `Database::Impl`
- `create_element` calls it before the transaction
- All 4 insert paths use pre-resolved values
- Inline set FK resolution is removed
- All existing tests pass with zero regressions
- Schema contains `Child_time_series_events` with `sponsor_id` FK
</success_criteria>

<output>
After completion, create `.planning/phases/02-create-element-fk-resolution/02-01-SUMMARY.md`
</output>
