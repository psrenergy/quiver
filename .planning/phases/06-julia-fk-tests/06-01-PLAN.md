---
phase: 06-julia-fk-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [bindings/julia/test/test_database_create.jl]
autonomous: true
requirements: [JUL-01]
must_haves:
  truths:
    - "Julia create_element! resolves set FK string labels to integer IDs"
    - "Julia create_element! resolves scalar FK string labels to integer IDs"
    - "Julia create_element! resolves vector FK string labels to integer IDs"
    - "Julia create_element! resolves time series FK string labels to integer IDs"
    - "Julia create_element! resolves all FK types in a single call"
    - "Julia create_element! throws DatabaseException for missing FK target labels"
    - "Julia create_element! throws DatabaseException for strings in non-FK integer columns"
    - "Julia create_element! writes zero rows when FK resolution fails (no partial writes)"
    - "Julia create_element! passes non-FK integer values through unchanged"
  artifacts:
    - path: "bindings/julia/test/test_database_create.jl"
      provides: "9 Julia FK create tests appended at end inside module"
      contains: "FK label resolution"
  key_links:
    - from: "bindings/julia/test/test_database_create.jl"
      to: "Quiver.create_element!"
      via: "Julia kwargs API with string labels for FK columns triggering C API FK resolution"
      pattern: "create_element!.*Child.*parent_id"
---

<objective>
Add 9 FK resolution tests to the Julia create test file, mirroring all C++ create-path FK tests.

Purpose: Verify that FK label-to-ID resolution works correctly through Julia's create_element! for all column types (scalar, vector, set, time series), error cases (missing target, non-FK integer), combined operations, no-FK regression, and transactional safety (no partial writes).

Output: 9 new @testset blocks appended inside the existing "Create" @testset in test_database_create.jl
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bindings/julia/test/test_database_create.jl
@bindings/julia/test/fixture.jl
@bindings/julia/src/element.jl
@bindings/julia/src/database_create.jl
@bindings/julia/src/database_read.jl
@tests/schemas/valid/relations.sql
@tests/schemas/valid/basic.sql
@tests/test_database_create.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 9 FK resolution create tests to Julia test file</name>
  <files>bindings/julia/test/test_database_create.jl</files>
  <action>
Append 9 new @testset blocks inside the existing `@testset "Create" begin ... end` block (before the final `end` that closes the "Create" testset), after the existing "Special Characters" testset. Add a section comment:

```julia
    # ============================================================================
    # FK label resolution in create_element!
    # ============================================================================
```

Each test is self-contained: creates its own db from `relations.sql` (or `basic.sql` for the no-FK test) using `Quiver.from_schema(":memory:", path_schema)`. Uses `joinpath(tests_path(), "schemas", "valid", "relations.sql")` for the schema path. Mirror the C++ test names adapted to Julia @testset conventions.

**The 9 tests to add (mirroring C++ test names 1:1):**

1. **`@testset "Resolve FK Label In Set Create"`** -- Create Configuration, 2 Parents ("Parent 1", "Parent 2"). Create child with `mentor_id = ["Parent 1", "Parent 2"]` (string array for set FK). Verify via `Quiver.read_set_integers_by_id(db, "Child", "mentor_id", Int64(1))` that values are `[1, 2]` (sort before comparing). Close db.

2. **`@testset "Resolve FK Label Missing Target"`** -- Create Configuration. Create child with `mentor_id = ["Nonexistent Parent"]`. Verify `@test_throws Quiver.DatabaseException Quiver.create_element!(db, "Child"; label = "Child 1", mentor_id = ["Nonexistent Parent"])`. Do NOT check error message -- just verify exception is thrown per CONTEXT.md decisions. Close db.

3. **`@testset "Reject String For Non-FK Integer Column"`** -- Create Configuration. Create child attempt with `score` column (non-FK INTEGER in `Child_set_scores`) set to string labels `["not_a_label"]`. The schema column is `Child_set_scores.score` which is a non-FK integer. Pass via kwargs: create a parent first, then `Quiver.create_element!(db, "Child"; label = "Child 1", parent_id = 1, score = ["not_a_label"])`. Verify `@test_throws Quiver.DatabaseException`. Close db.

    NOTE: The `score` column is in `Child_set_scores` table. In Julia kwargs, the set attribute name is just `"score"` (the table naming convention `{Collection}_set_{name}` means the attribute is `score`). Passing string values `["not_a_label"]` for a non-FK integer set column should trigger FK resolution which will fail because there's no FK constraint on `score`.

4. **`@testset "Create Element Scalar FK Label"`** -- Create Configuration, create "Parent 1". Create child with `parent_id = "Parent 1"` (string label, not integer). Verify via `Quiver.read_scalar_integers(db, "Child", "parent_id")` that value is `[1]`. Close db.

5. **`@testset "Create Element Vector FK Labels"`** -- Create Configuration, create "Parent 1", "Parent 2". Create child with `parent_ref = ["Parent 1", "Parent 2"]` (string array for vector FK). Verify via `Quiver.read_vector_integers_by_id(db, "Child", "parent_ref", Int64(1))` that values are `[1, 2]`. Close db.

6. **`@testset "Create Element Time Series FK Labels"`** -- Create Configuration, create "Parent 1", "Parent 2". Create child with `date_time = ["2024-01-01", "2024-01-02"]` and `sponsor_id = ["Parent 1", "Parent 2"]` (string arrays for time series). Verify via `Quiver.read_time_series_group(db, "Child", "events", Int64(1))`. The result is a Dict with keys "date_time" and "sponsor_id". Check `result["sponsor_id"] == [1, 2]` (integers after FK resolution). Close db.

    NOTE: The time series group name is `"events"` (from `Child_time_series_events`). The `read_time_series_group` Julia function returns a `Dict{String, Vector}` with column names as keys. The `sponsor_id` column should contain resolved integer IDs.

7. **`@testset "Create Element All FK Types In One Call"`** -- Create Configuration, create "Parent 1", "Parent 2". Create child with ALL FK types in one create_element! call:
   - `parent_id = "Parent 1"` (scalar FK)
   - `mentor_id = ["Parent 2"]` (set FK)
   - `parent_ref = ["Parent 1"]` (vector FK)
   - `date_time = ["2024-01-01"]` (time series dimension)
   - `sponsor_id = ["Parent 2"]` (time series FK)

   Verify each:
   - Scalar: `Quiver.read_scalar_integers(db, "Child", "parent_id")` -> `[1]`
   - Set: `sort(Quiver.read_set_integers_by_id(db, "Child", "mentor_id", Int64(1)))` -> `[2]`
   - Vector: `Quiver.read_vector_integers_by_id(db, "Child", "parent_ref", Int64(1))` -> `[1]`
   - Time series: `Quiver.read_time_series_group(db, "Child", "events", Int64(1))["sponsor_id"]` -> `[2]`

   Close db.

8. **`@testset "Create Element No FK Columns Unchanged"`** -- Use `basic.sql` schema (no FK columns). Create element with `label = "Config 1"`, `integer_attribute = 42`, `float_attribute = 3.14`. Verify all values read back correctly:
   - `Quiver.read_scalar_strings(db, "Configuration", "label")` -> `["Config 1"]`
   - `Quiver.read_scalar_integers(db, "Configuration", "integer_attribute")` -> `[42]`
   - `Quiver.read_scalar_floats(db, "Configuration", "float_attribute")` -> `[3.14]`

   This proves the FK pre-resolve pass is a no-op for non-FK schemas. Close db.

9. **`@testset "Scalar FK Resolution Failure Causes No Partial Writes"`** -- Create Configuration (required by schema). Attempt to create child with `parent_id = "Nonexistent Parent"` (string label). Verify `@test_throws Quiver.DatabaseException`. Then verify no child was created by reading `Quiver.read_scalar_strings(db, "Child", "label")` and asserting the result is empty (`length(...) == 0`). Close db.

**Pattern notes:**
- All tests follow the Julia convention: `Quiver.from_schema(":memory:", path_schema)` for db creation, `Quiver.close!(db)` for cleanup.
- FK labels are passed as string kwargs (e.g., `parent_id = "Parent 1"`) or string arrays (e.g., `mentor_id = ["Parent 1"]`). This triggers `quiver_element_set_string` or `quiver_element_set_array_string` in the C API layer, which performs FK label resolution.
- The relations.sql schema requires a Configuration element before creating Parent/Child.
- Use `@test_throws Quiver.DatabaseException` for error cases -- do not inspect error messages.
  </action>
  <verify>
Run Julia tests:
```bash
bindings/julia/test/test.bat
```
All Julia tests pass including the 9 new FK create tests.
  </verify>
  <done>
9 FK create @testset blocks appended to test_database_create.jl inside the "Create" testset, all passing. Test names mirror C++ counterparts: Resolve FK Label In Set Create, Resolve FK Label Missing Target, Reject String For Non-FK Integer Column, Create Element Scalar FK Label, Create Element Vector FK Labels, Create Element Time Series FK Labels, Create Element All FK Types In One Call, Create Element No FK Columns Unchanged, Scalar FK Resolution Failure Causes No Partial Writes.
  </done>
</task>

</tasks>

<verification>
1. `bindings/julia/test/test.bat` -- all Julia tests pass (existing + 9 new FK create tests)
2. Verify the 9 new @testset blocks exist in test_database_create.jl with correct names
</verification>

<success_criteria>
- 9 new @testset blocks in test_database_create.jl inside the "Create" testset
- Test names mirror C++ counterparts adapted to Julia @testset conventions
- All tests pass when run via Julia test runner
- No regressions in existing Julia tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-julia-fk-tests/06-01-SUMMARY.md`
</output>
