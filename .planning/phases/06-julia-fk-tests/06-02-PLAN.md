---
phase: 06-julia-fk-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [bindings/julia/test/test_database_update.jl]
autonomous: true
requirements: [JUL-02]
must_haves:
  truths:
    - "Julia update_element! resolves scalar FK string labels to integer IDs"
    - "Julia update_element! resolves vector FK string labels to integer IDs"
    - "Julia update_element! resolves set FK string labels to integer IDs"
    - "Julia update_element! resolves time series FK string labels to integer IDs"
    - "Julia update_element! resolves all FK types in a single call"
    - "Julia update_element! passes non-FK integer values through unchanged"
    - "Julia update_element! failure preserves the element's existing data"
  artifacts:
    - path: "bindings/julia/test/test_database_update.jl"
      provides: "7 Julia FK update tests appended at end inside module"
      contains: "FK label resolution"
  key_links:
    - from: "bindings/julia/test/test_database_update.jl"
      to: "Quiver.update_element!"
      via: "Julia kwargs API with string labels for FK columns triggering C API FK resolution"
      pattern: "update_element!.*Child.*Int64.*parent_id"
---

<objective>
Add 7 FK resolution tests to the Julia update test file, mirroring all C++ update-path FK tests.

Purpose: Verify that FK label-to-ID resolution works correctly through Julia's update_element! for all column types (scalar, vector, set, time series), combined operations, no-FK regression, and transactional safety (failure preserves existing data).

Output: 7 new @testset blocks appended inside the existing "Update" @testset in test_database_update.jl
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bindings/julia/test/test_database_update.jl
@bindings/julia/test/fixture.jl
@bindings/julia/src/element.jl
@bindings/julia/src/database_update.jl
@bindings/julia/src/database_read.jl
@tests/schemas/valid/relations.sql
@tests/schemas/valid/basic.sql
@tests/test_database_update.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 7 FK resolution update tests to Julia test file</name>
  <files>bindings/julia/test/test_database_update.jl</files>
  <action>
Append 7 new @testset blocks inside the existing `@testset "Update" begin ... end` block (before the final `end` that closes the "Update" testset), after the existing "Set Strings Invalid Collection" testset. Add a section comment:

```julia
    # ============================================================================
    # Update element FK label resolution tests
    # ============================================================================
```

Each test is self-contained: creates its own db from `relations.sql` (or `basic.sql` for the no-FK test), creates parent/child elements inline, then performs an update with FK string labels and verifies resolution. Uses `joinpath(tests_path(), "schemas", "valid", "relations.sql")` for the schema path. Mirror the C++ test names adapted to Julia @testset conventions.

**Setup pattern for FK update tests (tests 1-4, 5, 7):**
Each test needs: (a) create Configuration (required by schema), (b) create 2 Parents, (c) create child with initial FK pointing to Parent 1 via string label, (d) update child to point to Parent 2 via string label using `Quiver.update_element!(db, "Child", Int64(1); ...)`, (e) read back and verify resolved IDs.

**The 7 tests to add (mirroring C++ test names 1:1):**

1. **`@testset "Update Element Scalar FK Label"`** -- Create Configuration, Parents "Parent 1", "Parent 2". Create child with `parent_id = "Parent 1"`. Update child: `Quiver.update_element!(db, "Child", Int64(1); parent_id = "Parent 2")`. Verify via `Quiver.read_scalar_integers(db, "Child", "parent_id")` that value is `[2]`. Close db.

2. **`@testset "Update Element Vector FK Labels"`** -- Create Configuration, Parents. Create child with `parent_ref = ["Parent 1"]`. Update child: `Quiver.update_element!(db, "Child", Int64(1); parent_ref = ["Parent 2", "Parent 1"])`. Verify via `Quiver.read_vector_integers_by_id(db, "Child", "parent_ref", Int64(1))` that values are `[2, 1]` (order preserved). Close db.

3. **`@testset "Update Element Set FK Labels"`** -- Create Configuration, Parents. Create child with `mentor_id = ["Parent 1"]`. Update child: `Quiver.update_element!(db, "Child", Int64(1); mentor_id = ["Parent 2"])`. Verify via `Quiver.read_set_integers_by_id(db, "Child", "mentor_id", Int64(1))` that value is `[2]`. Close db.

4. **`@testset "Update Element Time Series FK Labels"`** -- Create Configuration, Parents. Create child with `date_time = ["2024-01-01"]`, `sponsor_id = ["Parent 1"]`. Update child: `Quiver.update_element!(db, "Child", Int64(1); date_time = ["2024-06-01", "2024-06-02"], sponsor_id = ["Parent 2", "Parent 1"])`. Verify via `Quiver.read_time_series_group(db, "Child", "events", Int64(1))` that `result["sponsor_id"] == [2, 1]` and `length(result["date_time"]) == 2`. Close db.

    NOTE: The time series group name is `"events"` (from `Child_time_series_events`). The update_element! kwargs set time series columns directly, and the Julia binding routes them through the Element builder which calls `quiver_element_set_array_string`.

5. **`@testset "Update Element All FK Types In One Call"`** -- Create Configuration, Parents. Create child with ALL FK types pointing to Parent 1:
   - `parent_id = "Parent 1"` (scalar FK)
   - `mentor_id = ["Parent 1"]` (set FK)
   - `parent_ref = ["Parent 1"]` (vector FK)
   - `date_time = ["2024-01-01"]`, `sponsor_id = ["Parent 1"]` (time series)

   Update child to change ALL FK types to Parent 2:
   `Quiver.update_element!(db, "Child", Int64(1); parent_id = "Parent 2", mentor_id = ["Parent 2"], parent_ref = ["Parent 2"], date_time = ["2025-01-01"], sponsor_id = ["Parent 2"])`

   Verify each:
   - Scalar: `Quiver.read_scalar_integers(db, "Child", "parent_id")` -> `[2]`
   - Set: `Quiver.read_set_integers_by_id(db, "Child", "mentor_id", Int64(1))` -> `[2]`
   - Vector: `Quiver.read_vector_integers_by_id(db, "Child", "parent_ref", Int64(1))` -> `[2]`
   - Time series: `Quiver.read_time_series_group(db, "Child", "events", Int64(1))["sponsor_id"]` -> `[2]`

   Close db.

6. **`@testset "Update Element No FK Columns Unchanged"`** -- Use `basic.sql` schema (no FK columns). Create element with `label = "Config 1"`, `integer_attribute = 42`, `float_attribute = 3.14`, `string_attribute = "hello"`. Update: `Quiver.update_element!(db, "Configuration", Int64(1); integer_attribute = 100, float_attribute = 2.71, string_attribute = "world")`. Verify:
   - `Quiver.read_scalar_integer_by_id(db, "Configuration", "integer_attribute", Int64(1))` -> `100`
   - `Quiver.read_scalar_float_by_id(db, "Configuration", "float_attribute", Int64(1))` -> `2.71`
   - `Quiver.read_scalar_string_by_id(db, "Configuration", "string_attribute", Int64(1))` -> `"world"`

   This proves the FK pre-resolve pass is a no-op for non-FK schemas during update. Close db.

7. **`@testset "Update Element FK Resolution Failure Preserves Existing"`** -- Create Configuration, create "Parent 1". Create child with `parent_id = "Parent 1"`. Attempt update with `parent_id = "Nonexistent Parent"`: `@test_throws Quiver.DatabaseException Quiver.update_element!(db, "Child", Int64(1); parent_id = "Nonexistent Parent")`. Then verify original value preserved: `Quiver.read_scalar_integers(db, "Child", "parent_id")` returns `[1]`. Close db.

**Pattern notes:**
- All tests follow Julia convention: `Quiver.from_schema(":memory:", path_schema)` for db creation, `Quiver.close!(db)` for cleanup.
- FK labels are passed as string kwargs. The Julia Element builder routes strings through `quiver_element_set_string` / `quiver_element_set_array_string` in the C API, triggering FK resolution.
- The relations.sql schema requires a Configuration element before creating Parent/Child.
- Use `@test_throws Quiver.DatabaseException` for error cases -- do not inspect error messages.
  </action>
  <verify>
Run Julia tests:
```bash
bindings/julia/test/test.bat
```
All Julia tests pass including the 7 new FK update tests.
  </verify>
  <done>
7 FK update @testset blocks appended to test_database_update.jl inside the "Update" testset, all passing. Test names mirror C++ counterparts: Update Element Scalar FK Label, Update Element Vector FK Labels, Update Element Set FK Labels, Update Element Time Series FK Labels, Update Element All FK Types In One Call, Update Element No FK Columns Unchanged, Update Element FK Resolution Failure Preserves Existing.
  </done>
</task>

</tasks>

<verification>
1. `bindings/julia/test/test.bat` -- all Julia tests pass (existing + 7 new FK update tests)
2. Verify the 7 new @testset blocks exist in test_database_update.jl with correct names
</verification>

<success_criteria>
- 7 new @testset blocks in test_database_update.jl inside the "Update" testset
- Test names mirror C++ counterparts adapted to Julia @testset conventions
- All tests pass when run via Julia test runner
- No regressions in existing Julia tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-julia-fk-tests/06-02-SUMMARY.md`
</output>
