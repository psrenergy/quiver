# Plan: RAII Statement Wrapper and Scalar Read Templates

```yaml
wave: 1
depends_on: []
files_modified:
  - src/database_impl.h
  - src/database.cpp
  - src/database_internal.h
  - src/database_read.cpp
requirements:
  - QUAL-01
  - QUAL-02
autonomous: true
```

## Goal

Eliminate manual `sqlite3_finalize` calls in `current_version()` and replace hand-written row-iteration loops in all 6 scalar read methods with template delegation, making C++ internals consistently use RAII and template patterns already established elsewhere in the codebase.

## must_haves

Working backward from the phase success criteria:

1. **No manual `sqlite3_finalize` in `current_version()`** -- the function uses `StmtPtr` (a `unique_ptr` with custom deleter) for automatic cleanup on all exit paths
2. **All 3 bulk scalar reads delegate to `read_column_values<T>`** -- `read_scalar_integers`, `read_scalar_floats`, `read_scalar_strings` contain no manual row-iteration loops
3. **All 3 scalar by-id reads delegate to `read_single_value<T>`** -- `read_scalar_integer_by_id`, `read_scalar_float_by_id`, `read_scalar_string_by_id` contain no manual if/return patterns
4. **Template rename complete** -- `read_grouped_values_by_id` renamed to `read_column_values` in definition and all 7 existing call sites
5. **All existing tests pass unchanged** -- zero behavioral differences, confirmed by full test suite

## Tasks

<task id="1" title="Add StmtPtr typedef and refactor current_version()" requirements="QUAL-01">

### Objective

Add a reusable `StmtPtr` typedef to `database_impl.h` and refactor `current_version()` in `database.cpp` to use it instead of manual `sqlite3_finalize` calls. Optionally update `execute()` to use the same typedef.

### Context

- `execute()` at `database.cpp:137` already uses `unique_ptr<sqlite3_stmt, decltype(&sqlite3_finalize)>` inline -- the typedef extracts this pattern for reuse
- `current_version()` at `database.cpp:214-233` has two manual `sqlite3_finalize` calls (error path line 227, success path line 231)
- `<memory>` and `<sqlite3.h>` are already included in `database_impl.h` -- no new includes needed

### Steps

1. **Add StmtPtr typedef to `src/database_impl.h`**
   - Add `using StmtPtr = std::unique_ptr<sqlite3_stmt, decltype(&sqlite3_finalize)>;` in the `quiver` namespace, before the `ResolvedElement` struct (after the includes, around line 16)
   - This is a namespace-level typedef, not inside any struct

2. **Refactor `current_version()` in `src/database.cpp`** (lines 214-233)
   - Replace the raw `sqlite3_stmt* stmt` with `sqlite3_stmt* raw_stmt`
   - After the `sqlite3_prepare_v2` success check, wrap in `StmtPtr stmt(raw_stmt, sqlite3_finalize);`
   - Replace `sqlite3_step(stmt)` with `sqlite3_step(stmt.get())`
   - Replace `sqlite3_column_int(stmt, 0)` with `sqlite3_column_int(stmt.get(), 0)`
   - Remove both `sqlite3_finalize(stmt)` calls (lines 227 and 231)
   - The error path throw no longer needs manual finalize -- `StmtPtr` destructor handles it
   - Simplify: remove the intermediate `user_version` variable; directly `return sqlite3_column_int(stmt.get(), 0)` after the `SQLITE_ROW` check

   **After:**
   ```cpp
   int64_t Database::current_version() const {
       sqlite3_stmt* raw_stmt = nullptr;
       const char* sql = "PRAGMA user_version;";
       auto rc = sqlite3_prepare_v2(impl_->db, sql, -1, &raw_stmt, nullptr);
       if (rc != SQLITE_OK) {
           throw std::runtime_error("Failed to prepare statement: " + std::string(sqlite3_errmsg(impl_->db)));
       }
       StmtPtr stmt(raw_stmt, sqlite3_finalize);

       rc = sqlite3_step(stmt.get());
       if (rc != SQLITE_ROW) {
           throw std::runtime_error("Failed to read user_version: " + std::string(sqlite3_errmsg(impl_->db)));
       }
       return sqlite3_column_int(stmt.get(), 0);
   }
   ```

3. **Update `execute()` in `src/database.cpp`** (line 137)
   - Replace `std::unique_ptr<sqlite3_stmt, decltype(&sqlite3_finalize)> stmt(raw_stmt, sqlite3_finalize);` with `StmtPtr stmt(raw_stmt, sqlite3_finalize);`
   - This is a cosmetic consistency improvement -- same type, shorter spelling

### Verification

```bash
cmake --build build --config Debug 2>&1 | tail -5    # Must compile cleanly
./build/bin/quiver_tests.exe                          # All C++ tests pass
./build/bin/quiver_c_tests.exe                        # All C API tests pass
```

- Confirm no `sqlite3_finalize` calls remain in `current_version()`
- Confirm `StmtPtr` typedef exists in `database_impl.h`
- Confirm `execute()` uses `StmtPtr` instead of inline `unique_ptr` type

</task>

<task id="2" title="Rename template and refactor all 6 scalar reads" requirements="QUAL-02">

### Objective

Rename `read_grouped_values_by_id<T>` to `read_column_values<T>`, add a new `read_single_value<T>` template, and refactor all 6 scalar read methods to delegate to these templates instead of manual loops.

### Context

- `database_internal.h:54-65` defines `read_grouped_values_by_id<T>` -- rename to `read_column_values<T>` (body unchanged)
- 7 existing callers in `database_read.cpp` (lines 129, 138, 147, 183, 192, 201, 207) must be updated to new name
- 3 bulk scalar reads (lines 6-55) have identical loop patterns that match `read_column_values<T>` exactly
- 3 scalar by-id reads (lines 57-94) have identical if-empty-return-nullopt patterns that become `read_single_value<T>`

### Steps

1. **Rename template in `src/database_internal.h`** (line 55)
   - Change `read_grouped_values_by_id` to `read_column_values` in the function name
   - Update the comment on line 53 from "reading grouped values (vectors or sets) for a single element by ID" to "reading column 0 values from query results"
   - Body is identical -- no logic changes

2. **Add `read_single_value<T>` template to `src/database_internal.h`**
   - Place it immediately after `read_column_values<T>` (after the closing brace of `read_column_values`, before `find_dimension_column`)
   - Implementation:
   ```cpp
   // Template for reading a single optional value (column 0, row 0) from query results
   template <typename T>
   std::optional<T> read_single_value(const Result& result) {
       if (result.empty()) {
           return std::nullopt;
       }
       return get_row_value(result[0], 0, static_cast<T*>(nullptr));
   }
   ```

3. **Refactor 3 bulk scalar read methods in `src/database_read.cpp`**

   Replace `read_scalar_integers` (lines 6-21):
   ```cpp
   std::vector<int64_t> Database::read_scalar_integers(const std::string& collection, const std::string& attribute) {
       impl_->require_collection(collection, "read_scalar_integers");
       impl_->require_column(collection, attribute, "read_scalar_integers");
       auto sql = "SELECT " + attribute + " FROM " + collection;
       return internal::read_column_values<int64_t>(execute(sql));
   }
   ```

   Replace `read_scalar_floats` (lines 23-38):
   ```cpp
   std::vector<double> Database::read_scalar_floats(const std::string& collection, const std::string& attribute) {
       impl_->require_collection(collection, "read_scalar_floats");
       impl_->require_column(collection, attribute, "read_scalar_floats");
       auto sql = "SELECT " + attribute + " FROM " + collection;
       return internal::read_column_values<double>(execute(sql));
   }
   ```

   Replace `read_scalar_strings` (lines 40-55):
   ```cpp
   std::vector<std::string> Database::read_scalar_strings(const std::string& collection, const std::string& attribute) {
       impl_->require_collection(collection, "read_scalar_strings");
       impl_->require_column(collection, attribute, "read_scalar_strings");
       auto sql = "SELECT " + attribute + " FROM " + collection;
       return internal::read_column_values<std::string>(execute(sql));
   }
   ```

4. **Refactor 3 scalar by-id read methods in `src/database_read.cpp`**

   Replace `read_scalar_integer_by_id` (lines 57-68):
   ```cpp
   std::optional<int64_t>
   Database::read_scalar_integer_by_id(const std::string& collection, const std::string& attribute, int64_t id) {
       impl_->require_collection(collection, "read_scalar_integer_by_id");
       impl_->require_column(collection, attribute, "read_scalar_integer_by_id");
       auto sql = "SELECT " + attribute + " FROM " + collection + " WHERE id = ?";
       return internal::read_single_value<int64_t>(execute(sql, {id}));
   }
   ```

   Replace `read_scalar_float_by_id` (lines 70-81):
   ```cpp
   std::optional<double>
   Database::read_scalar_float_by_id(const std::string& collection, const std::string& attribute, int64_t id) {
       impl_->require_collection(collection, "read_scalar_float_by_id");
       impl_->require_column(collection, attribute, "read_scalar_float_by_id");
       auto sql = "SELECT " + attribute + " FROM " + collection + " WHERE id = ?";
       return internal::read_single_value<double>(execute(sql, {id}));
   }
   ```

   Replace `read_scalar_string_by_id` (lines 83-94):
   ```cpp
   std::optional<std::string>
   Database::read_scalar_string_by_id(const std::string& collection, const std::string& attribute, int64_t id) {
       impl_->require_collection(collection, "read_scalar_string_by_id");
       impl_->require_column(collection, attribute, "read_scalar_string_by_id");
       auto sql = "SELECT " + attribute + " FROM " + collection + " WHERE id = ?";
       return internal::read_single_value<std::string>(execute(sql, {id}));
   }
   ```

5. **Rename all 7 existing callers in `src/database_read.cpp`**
   - Line 129: `read_grouped_values_by_id<int64_t>` -> `read_column_values<int64_t>`
   - Line 138: `read_grouped_values_by_id<double>` -> `read_column_values<double>`
   - Line 147: `read_grouped_values_by_id<std::string>` -> `read_column_values<std::string>`
   - Line 183: `read_grouped_values_by_id<int64_t>` -> `read_column_values<int64_t>`
   - Line 192: `read_grouped_values_by_id<double>` -> `read_column_values<double>`
   - Line 201: `read_grouped_values_by_id<std::string>` -> `read_column_values<std::string>`
   - Line 207: `read_grouped_values_by_id<int64_t>` -> `read_column_values<int64_t>`

   This is a simple find-and-replace of `read_grouped_values_by_id` with `read_column_values` across the entire file.

### Verification

```bash
cmake --build build --config Debug 2>&1 | tail -5    # Must compile cleanly
./build/bin/quiver_tests.exe                          # All C++ tests pass
./build/bin/quiver_c_tests.exe                        # All C API tests pass
```

After both tasks, run the full cross-language test suite:
```bash
scripts/test-all.bat                                  # All tests across all bindings pass
```

- Confirm `read_grouped_values_by_id` no longer exists anywhere in the codebase (grep returns no results)
- Confirm no manual row-iteration loops remain in the 6 scalar read methods
- Confirm `read_single_value<T>` template exists in `database_internal.h`
- Confirm total callers of `read_column_values`: 10 (7 renamed + 3 new scalar bulk reads)

</task>

## Verification

After all tasks complete:

1. **Build**: `cmake --build build --config Debug` compiles with zero errors
2. **C++ tests**: `./build/bin/quiver_tests.exe` -- all pass (especially `ReadScalar*`, `ReadVector*ById`, `ReadSet*ById`, `ReadElementIds`, `DateTimeNullable` tests)
3. **C API tests**: `./build/bin/quiver_c_tests.exe` -- all pass
4. **Full suite**: `scripts/test-all.bat` -- all bindings (Julia, Dart, Python) pass
5. **No regressions**: Grep confirms:
   - No `sqlite3_finalize` in `current_version()`
   - No `read_grouped_values_by_id` anywhere in `src/`
   - No manual row-iteration loops in scalar read method bodies in `database_read.cpp`

## Checklist

- [ ] `StmtPtr` typedef added to `database_impl.h`
- [ ] `current_version()` uses `StmtPtr` -- no manual `sqlite3_finalize`
- [ ] `execute()` uses `StmtPtr` typedef (cosmetic consistency)
- [ ] `read_grouped_values_by_id` renamed to `read_column_values` in `database_internal.h`
- [ ] `read_single_value<T>` template added to `database_internal.h`
- [ ] All 6 scalar read methods refactored to use templates
- [ ] All 7 existing callers renamed from `read_grouped_values_by_id` to `read_column_values`
- [ ] All existing tests pass unchanged
