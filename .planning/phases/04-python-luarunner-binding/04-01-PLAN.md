---
phase: 04-python-luarunner-binding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/python/src/quiverdb/_c_api.py
  - bindings/python/src/quiverdb/lua_runner.py
  - bindings/python/src/quiverdb/__init__.py
  - bindings/python/tests/test_lua_runner.py
autonomous: true
requirements:
  - PY-01
must_haves:
  truths:
    - "Python user can create a LuaRunner from a Database instance"
    - "Python user can run Lua scripts that create/read/update/delete elements"
    - "Lua script errors raise QuiverError with the actual Lua error message"
    - "LuaRunner keeps Database alive (prevents GC of underlying native handle)"
    - "LuaRunner supports context manager protocol (with statement)"
    - "Multiple run() calls on the same LuaRunner work correctly"
    - "Calling run() after close() raises QuiverError"
  artifacts:
    - path: "bindings/python/src/quiverdb/lua_runner.py"
      provides: "LuaRunner class with lifecycle management"
      min_lines: 50
    - path: "bindings/python/src/quiverdb/_c_api.py"
      provides: "CFFI declarations for quiver_lua_runner_* functions"
      contains: "quiver_lua_runner_new"
    - path: "bindings/python/src/quiverdb/__init__.py"
      provides: "LuaRunner export"
      contains: "LuaRunner"
    - path: "bindings/python/tests/test_lua_runner.py"
      provides: "Test coverage for LuaRunner"
      min_lines: 40
  key_links:
    - from: "bindings/python/src/quiverdb/lua_runner.py"
      to: "bindings/python/src/quiverdb/_c_api.py"
      via: "ffi, get_lib imports for CFFI calls"
      pattern: "from quiverdb._c_api import ffi, get_lib"
    - from: "bindings/python/src/quiverdb/lua_runner.py"
      to: "libquiver_c.dll"
      via: "quiver_lua_runner_new, quiver_lua_runner_run, quiver_lua_runner_get_error, quiver_lua_runner_free"
      pattern: "lib\\.quiver_lua_runner_"
    - from: "bindings/python/src/quiverdb/__init__.py"
      to: "bindings/python/src/quiverdb/lua_runner.py"
      via: "import and __all__ export"
      pattern: "from quiverdb.lua_runner import LuaRunner"
---

<objective>
Add a Python LuaRunner binding that wraps the C API `quiver_lua_runner_new/run/get_error/free` functions, achieving feature parity with Julia and Dart LuaRunner bindings.

Purpose: Python users need to execute Lua scripts against a Quiver database (requirement PY-01). The C API already exposes 4 LuaRunner functions and an opaque type. This plan creates the Python wrapper class following the established Database lifecycle pattern.

Output: `LuaRunner` class in the quiverdb package with full lifecycle management, two-source error resolution, and test coverage.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-python-luarunner-binding/04-CONTEXT.md
@.planning/phases/04-python-luarunner-binding/04-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From bindings/python/src/quiverdb/_c_api.py (existing CFFI pattern -- add LuaRunner declarations to same ffi.cdef block):
```python
ffi = FFI()
ffi.cdef("""
    // ... existing declarations ...
    typedef struct quiver_database quiver_database_t;
    // ... etc ...
""")

def get_lib():
    global _lib
    if _lib is None:
        from quiverdb._loader import load_library
        _lib = load_library(ffi)
    return _lib
```

From bindings/python/src/quiverdb/_helpers.py:
```python
def check(err: int) -> None:
    """Raise QuiverError if err indicates a C API failure."""
    if err != 0:
        lib = get_lib()
        ptr = lib.quiver_get_last_error()
        detail = ffi.string(ptr).decode("utf-8") if ptr != ffi.NULL else ""
        raise QuiverError(detail or "Unknown error")
```

From bindings/python/src/quiverdb/exceptions.py:
```python
class QuiverError(Exception):
    """Error from the Quiver C API."""
```

From bindings/python/src/quiverdb/database.py (lifecycle pattern to follow):
```python
class Database(DatabaseCSVExport, DatabaseCSVImport):
    def __init__(self, ptr) -> None:
        self._ptr = ptr
        self._closed = False

    def close(self) -> None:
        if self._closed:
            return
        lib = get_lib()
        check(lib.quiver_database_close(self._ptr))
        self._ptr = ffi.NULL
        self._closed = True

    def _ensure_open(self) -> None:
        if self._closed:
            raise QuiverError("Database has been closed")

    def __enter__(self) -> Database:
        return self

    def __exit__(self, *args: object) -> None:
        self.close()

    def __del__(self) -> None:
        if not self._closed:
            warnings.warn("Database was not closed explicitly", ResourceWarning, stacklevel=2)
            self.close()
```

From bindings/python/src/quiverdb/__init__.py (current exports):
```python
from quiverdb.database import Database
from quiverdb.database_csv_export import DatabaseCSVExport
from quiverdb.database_csv_import import DatabaseCSVImport
from quiverdb.exceptions import QuiverError
from quiverdb.metadata import CSVOptions, DataType, GroupMetadata, ScalarMetadata

__all__ = [
    "CSVOptions", "DataType", "Database", "DatabaseCSVExport",
    "DatabaseCSVImport", "GroupMetadata", "QuiverError", "ScalarMetadata", "version",
]
```

From include/quiver/c/lua_runner.h (C API to bind):
```c
typedef struct quiver_lua_runner quiver_lua_runner_t;
quiver_error_t quiver_lua_runner_new(quiver_database_t* db, quiver_lua_runner_t** out_runner);
quiver_error_t quiver_lua_runner_free(quiver_lua_runner_t* runner);
quiver_error_t quiver_lua_runner_run(quiver_lua_runner_t* runner, const char* script);
quiver_error_t quiver_lua_runner_get_error(quiver_lua_runner_t* runner, const char** out_error);
```

From bindings/python/tests/conftest.py (test fixture pattern):
```python
@pytest.fixture
def collections_db(collections_schema_path: Path, tmp_path: Path) -> Generator[Database, None, None]:
    database = Database.from_schema(str(tmp_path / "collections.db"), str(collections_schema_path))
    yield database
    database.close()
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CFFI declarations, create LuaRunner class, export from package</name>
  <files>
    bindings/python/src/quiverdb/_c_api.py
    bindings/python/src/quiverdb/lua_runner.py
    bindings/python/src/quiverdb/__init__.py
  </files>
  <action>
**1. Add CFFI declarations to `_c_api.py`:**

Append the following 4 function declarations and opaque type to the end of the existing `ffi.cdef("""...""")` block (before the closing `"""`):

```
// lua_runner.h
typedef struct quiver_lua_runner quiver_lua_runner_t;

quiver_error_t quiver_lua_runner_new(quiver_database_t* db, quiver_lua_runner_t** out_runner);
quiver_error_t quiver_lua_runner_free(quiver_lua_runner_t* runner);
quiver_error_t quiver_lua_runner_run(quiver_lua_runner_t* runner, const char* script);
quiver_error_t quiver_lua_runner_get_error(quiver_lua_runner_t* runner, const char** out_error);
```

**2. Create `bindings/python/src/quiverdb/lua_runner.py`:**

Create a new file with `LuaRunner` class following the Database lifecycle pattern exactly. Per user decisions:

- Constructor: `def __init__(self, db: Database) -> None:` -- takes a Database instance.
  - Store `self._db = db` (prevents GC of database while runner alive).
  - Set `self._closed = False`.
  - Call `lib.quiver_lua_runner_new(db._ptr, out_runner)` and use `check()` on the result (constructor errors go through global error path).
  - Store `self._ptr = out_runner[0]`.

- `close(self) -> None:` -- Idempotent. If `self._closed`, return early. Call `lib.quiver_lua_runner_free(self._ptr)`. Set `self._ptr = ffi.NULL`. Set `self._closed = True`. Do NOT call `check()` on `quiver_lua_runner_free` since `delete` cannot fail.

- `_ensure_open(self) -> None:` -- Raises `QuiverError("LuaRunner is closed")` if `self._closed`.

- `run(self, script: str) -> None:` -- Call `self._ensure_open()`. Call `lib.quiver_lua_runner_run(self._ptr, script.encode("utf-8"))`. If return is not 0, implement TWO-SOURCE error resolution:
  1. Try `quiver_lua_runner_get_error(self._ptr, out_error)` -- if succeeds and pointer is non-NULL and string is non-empty, raise `QuiverError(msg)`.
  2. Fall back to `quiver_get_last_error()` -- if non-NULL and non-empty, raise `QuiverError(detail)`.
  3. Generic fallback: raise `QuiverError("Lua script execution failed")`.
  CRITICAL: Do NOT use `_helpers.check()` for `run()` errors -- it only reads global errors and would miss Lua-specific errors.

- `__enter__(self) -> LuaRunner:` -- Return `self`.
- `__exit__(self, *args: object) -> None:` -- Call `self.close()`.
- `__del__(self) -> None:` -- If not `self._closed`, emit `warnings.warn("LuaRunner was not closed explicitly", ResourceWarning, stacklevel=2)` then call `self.close()`.

Imports needed: `from __future__ import annotations`, `import warnings`, `from quiverdb._c_api import ffi, get_lib`, `from quiverdb._helpers import check`, `from quiverdb.exceptions import QuiverError`. Import `Database` via `TYPE_CHECKING` to avoid circular imports: `from typing import TYPE_CHECKING` and `if TYPE_CHECKING: from quiverdb.database import Database`.

**3. Update `bindings/python/src/quiverdb/__init__.py`:**

Add `from quiverdb.lua_runner import LuaRunner` to the imports. Add `"LuaRunner"` to the `__all__` list (keep alphabetical order -- insert between `"GroupMetadata"` and `"QuiverError"`).
  </action>
  <verify>
    <automated>cd C:/Development/DatabaseTmp/quiver4 && python -c "from quiverdb import LuaRunner; print('LuaRunner imported successfully')"</automated>
  </verify>
  <done>
    - `LuaRunner` class exists in `bindings/python/src/quiverdb/lua_runner.py` with constructor, close, run, _ensure_open, context manager, and __del__
    - CFFI declarations for all 4 `quiver_lua_runner_*` functions exist in `_c_api.py`
    - `from quiverdb import LuaRunner` works
    - `LuaRunner` is in `__all__`
  </done>
</task>

<task type="auto">
  <name>Task 2: Create LuaRunner test suite</name>
  <files>
    bindings/python/tests/test_lua_runner.py
  </files>
  <action>
Create `bindings/python/tests/test_lua_runner.py` with pytest tests covering all LuaRunner functionality. Use the existing `collections_db` fixture from `conftest.py` for tests that need a database with the collections schema.

Test cases to implement (modeled after the Dart `lua_runner_test.dart` patterns):

**1. `test_create_element_from_lua`** -- Create a LuaRunner from `collections_db`, run a Lua script that creates Configuration + Collection elements, verify via Python `read_scalar_strings`/`read_scalar_integers` that the elements exist. Demonstrates Lua scripts operating on the database through the runner.

**2. `test_read_scalars_from_lua`** -- Seed database with Python `create_element` calls first, then run a Lua script that reads and asserts values using `db:read_scalar_strings`. If the script succeeds (no Lua assert failure), the test passes. Tests the Lua-side read capability.

**3. `test_syntax_error_raises_quiver_error`** -- Run `'invalid syntax !!!'` via LuaRunner. Assert that `QuiverError` is raised. Assert the error message contains meaningful Lua error text (not empty, not generic). Verifies two-source error resolution surfaces Lua errors.

**4. `test_runtime_error_raises_quiver_error`** -- Run `'print(undefined_variable.field)'` via LuaRunner. Assert `QuiverError` is raised. Tests runtime (not syntax) Lua errors.

**5. `test_invalid_collection_raises_quiver_error`** -- Create Configuration first, then run Lua script creating element in `"NonexistentCollection"`. Assert `QuiverError` is raised.

**6. `test_multiple_run_calls`** -- Use a single LuaRunner instance, call `run()` three times (create Config, create Item 1, create Item 2). Verify both items exist. Tests runner reuse.

**7. `test_empty_script`** -- Run `''` (empty string). Should succeed without error.

**8. `test_comment_only_script`** -- Run `'-- just a comment'`. Should succeed without error.

**9. `test_context_manager`** -- Use `with LuaRunner(db) as lua:` pattern. Run a script inside the block. Verify it works. After the block exits, calling `lua.run(...)` should raise `QuiverError("LuaRunner is closed")`.

**10. `test_run_after_close_raises`** -- Create LuaRunner, call `close()`, then call `run("...")`. Assert `QuiverError` with message `"LuaRunner is closed"`.

**11. `test_close_idempotent`** -- Create LuaRunner, call `close()` twice. Should not raise.

**12. `test_database_reference_kept`** -- Create LuaRunner, verify `lua._db is db` (reference identity). This tests the GC prevention mechanism.

All tests use `QuiverError` (not RuntimeError or LuaError) per locked decision. Use `pytest.raises(QuiverError)` for error assertions.
  </action>
  <verify>
    <automated>cd C:/Development/DatabaseTmp/quiver4/bindings/python && set "PATH=%cd%\..\..\build\bin;%PATH%" && uv run pytest tests/test_lua_runner.py -v</automated>
  </verify>
  <done>
    - `test_lua_runner.py` exists with 12 test cases
    - All tests pass against the built C library
    - Tests cover: create via Lua, read via Lua, syntax errors, runtime errors, invalid collection errors, runner reuse, empty/comment scripts, context manager, post-close errors, idempotent close, database reference retention
  </done>
</task>

</tasks>

<verification>
1. `from quiverdb import LuaRunner` succeeds (CFFI declarations loaded, class exported)
2. All 12 LuaRunner tests pass: `cd bindings/python && set "PATH=%cd%\..\..\build\bin;%PATH%" && uv run pytest tests/test_lua_runner.py -v`
3. Existing Python tests still pass: `cd bindings/python && set "PATH=%cd%\..\..\build\bin;%PATH%" && uv run pytest tests/ -v`
4. `LuaRunner` appears in `__all__` list in `__init__.py`
</verification>

<success_criteria>
- LuaRunner class wraps all 4 C API functions (quiver_lua_runner_new/run/get_error/free)
- Database reference stored to prevent GC (self._db = db)
- Two-source error resolution implemented (runner-specific -> global -> generic fallback)
- Lifecycle pattern matches Database class exactly (close, _ensure_open, __enter__/__exit__, __del__ with ResourceWarning)
- Context manager protocol works (with statement)
- All Python tests pass (existing + new LuaRunner tests)
</success_criteria>

<output>
After completion, create `.planning/phases/04-python-luarunner-binding/04-01-SUMMARY.md`
</output>
