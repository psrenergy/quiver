---
phase: 03-update-element-fk-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/database_update.cpp
  - tests/test_database_update.cpp
autonomous: true
requirements: [UPD-01, UPD-02, UPD-03, UPD-04]
must_haves:
  truths:
    - "update_element resolves scalar FK labels to target IDs"
    - "update_element resolves vector FK labels to target IDs"
    - "update_element resolves set FK labels to target IDs"
    - "update_element resolves time series FK labels to target IDs"
    - "Failed FK resolution in update_element preserves existing element state"
    - "update_element with no FK columns works unchanged"
  artifacts:
    - path: "src/database_update.cpp"
      provides: "update_element with pre-resolve FK pass"
      contains: "resolve_element_fk_labels"
    - path: "tests/test_database_update.cpp"
      provides: "FK resolution tests for update_element"
      contains: "UpdateElementScalarFkLabel"
  key_links:
    - from: "src/database_update.cpp"
      to: "src/database_impl.h"
      via: "resolve_element_fk_labels call"
      pattern: "impl_->resolve_element_fk_labels"
    - from: "src/database_update.cpp"
      to: "resolved.scalars and resolved.arrays"
      via: "all downstream code uses resolved values instead of raw element"
      pattern: "resolved\\.scalars|resolved\\.arrays"
---

<objective>
Wire the existing FK label pre-resolve pass into update_element and add comprehensive tests proving all 4 column types resolve correctly.

Purpose: Users can update FK columns by passing target labels (strings) instead of raw integer IDs, matching the create_element experience from Phase 2.
Output: Modified update_element with FK resolution, 7 new tests in test_database_update.cpp.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-create-element-fk-resolution/02-01-SUMMARY.md

@src/database_update.cpp
@src/database_create.cpp
@src/database_impl.h
@tests/test_database_update.cpp
@tests/test_database_relations.cpp
@tests/schemas/valid/relations.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire pre-resolve pass into update_element</name>
  <files>src/database_update.cpp</files>
  <action>
Add a single call to `impl_->resolve_element_fk_labels(collection, element, *this)` in `update_element`, placed after the emptiness check but before the TransactionGuard. Then switch ALL downstream code to use `resolved.scalars` and `resolved.arrays` instead of the raw `scalars` and `arrays` local variables.

Specific changes to the `update_element` method (lines 7-164):

1. After line 16 (the emptiness check), add:
   ```cpp
   // Pre-resolve pass: resolve all FK labels before any writes
   auto resolved = impl_->resolve_element_fk_labels(collection, element, *this);
   ```

2. Keep the `scalars`/`arrays` local references (lines 11-12) for the emptiness check only. All downstream code switches to `resolved.*`:

3. Scalar section (lines 21-44): Change `scalars` to `resolved.scalars` in:
   - The `if (!scalars.empty())` guard -> `if (!resolved.scalars.empty())`
   - Both `for` loops iterating scalars -> iterate `resolved.scalars`

4. Array routing section (line 51): Change `arrays` to `resolved.arrays`:
   - `for (const auto& [attr_name, values] : arrays)` -> `for (const auto& [attr_name, values] : resolved.arrays)`

5. Everything else (vector/set/time_series INSERT loops at lines 75-160) stays unchanged -- they consume from the routing maps which now point into `resolved.arrays` values.

Mirror exactly how `create_element` in `src/database_create.cpp` was refactored in Phase 2 (line 17 has the resolve call, line 20-22 validates resolved scalars).

IMPORTANT: The `resolved` variable must be declared in the same scope as the routing maps (lines 47-49) so the `const std::vector<Value>*` pointers stored during routing remain valid through the INSERT loops. Since `resolved` is declared at function scope (before the TransactionGuard), this is automatically satisfied.

Do NOT modify the emptiness check (line 14-16) -- it must still check raw `scalars.empty() && arrays.empty()` per locked decision.
Do NOT create any new functions -- locked decision says "same function, both paths."
Do NOT touch any other methods in the file (update_scalar_integer, update_vector_strings, etc.).
  </action>
  <verify>
Run `cmake --build build --config Debug 2>&1` -- must compile with zero errors. Then run `./build/bin/quiver_tests.exe` -- all existing tests must pass (zero regressions). The update_element method is already exercised by existing tests in test_database_update.cpp that use non-FK schemas, confirming the pre-resolve passthrough works for non-FK values.
  </verify>
  <done>
update_element calls resolve_element_fk_labels before the transaction, all downstream code reads from resolved.scalars and resolved.arrays, all existing tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add FK resolution tests for update_element</name>
  <files>tests/test_database_update.cpp</files>
  <action>
Add 7 tests to `tests/test_database_update.cpp` in a new section at the bottom of the file, mirroring Phase 2's test structure from `tests/test_database_relations.cpp` (lines 255-420). Each test follows the update pattern: create initial entities, then update using FK labels, then verify resolved IDs.

Add section header:
```cpp
// ============================================================================
// Update element FK label resolution tests
// ============================================================================
```

**Test 1: UpdateElementScalarFkLabel** (UPD-01)
- Create Parent 1 and Parent 2
- Create Child with `parent_id` = "Parent 1" (using create_element FK resolution)
- Update Child: `element.set("parent_id", std::string("Parent 2"))`
- Call `db.update_element("Child", 1, update)`
- Verify: `read_scalar_integers("Child", "parent_id")[0] == 2`

**Test 2: UpdateElementVectorFkLabels** (UPD-02)
- Create Parent 1 and Parent 2
- Create Child with `parent_ref` = {"Parent 1"} (vector FK)
- Update Child: `element.set("parent_ref", std::vector<std::string>{"Parent 2", "Parent 1"})`
- Call `db.update_element("Child", 1, update)`
- Verify: `read_vector_integers_by_id("Child", "parent_ref", 1)` returns {2, 1}

**Test 3: UpdateElementSetFkLabels** (UPD-03)
- Create Parent 1 and Parent 2
- Create Child with `mentor_id` = {"Parent 1"} (set FK, unique to Child_set_mentors)
- Update Child: `element.set("mentor_id", std::vector<std::string>{"Parent 2"})`
- Call `db.update_element("Child", 1, update)`
- Verify: `read_set_integers("Child", "mentor_id")` returns [[2]] (single child, one mentor pointing to Parent 2)

**Test 4: UpdateElementTimeSeriesFkLabels** (UPD-04)
- Create Parent 1 and Parent 2
- Create Child with time series: `date_time` = {"2024-01-01"}, `sponsor_id` = {"Parent 1"}
- Update Child time series: `date_time` = {"2024-06-01", "2024-06-02"}, `sponsor_id` = {"Parent 2", "Parent 1"}
- Call `db.update_element("Child", 1, update)`
- Verify: `read_time_series_group("Child", "events", 1)` returns 2 rows with sponsor_id resolved to {2, 1}
- Use `std::get<int64_t>(ts_data[N].at("sponsor_id"))` for verification (same pattern as Phase 2)

**Test 5: UpdateElementAllFkTypesInOneCall** (UPD-01, UPD-02, UPD-03, UPD-04)
- Create Parent 1 and Parent 2
- Create Child with all FK types pointing to Parent 1
- Update Child in a single update_element call changing all FK types to point to Parent 2:
  - `parent_id` = "Parent 2" (scalar FK)
  - `mentor_id` = {"Parent 2"} (set FK)
  - `parent_ref` = {"Parent 2"} (vector+set FK)
  - `date_time` = {"2025-01-01"}, `sponsor_id` = {"Parent 2"} (time series FK)
- Verify all 4 types read back resolved integer IDs pointing to Parent 2

**Test 6: UpdateElementNoFkColumnsUnchanged**
- Use `basic.sql` schema (no FK columns)
- Create element, then update scalar attributes via update_element
- Verify values updated correctly (proves pre-resolve passthrough is safe for non-FK schemas)

**Test 7: UpdateElementFkResolutionFailurePreservesExisting**
- Create Parent 1 and Child with `parent_id` = "Parent 1"
- Attempt `update_element` with `parent_id` = "Nonexistent Parent"
- `EXPECT_THROW(..., std::runtime_error)`
- Verify: `read_scalar_integers("Child", "parent_id")[0] == 1` (original value preserved)

All tests use `VALID_SCHEMA("relations.sql")` except Test 6 which uses `VALID_SCHEMA("basic.sql")`. All use `{.read_only = 0, .console_level = QUIVER_LOG_OFF}` options. Read-back verification is preferred over no-throw (per Claude's discretion, matching Phase 2 pattern).
  </action>
  <verify>
Run `cmake --build build --config Debug 2>&1 && ./build/bin/quiver_tests.exe --gtest_filter="*UpdateElement*Fk*:*UpdateElementNoFk*"` -- all 7 new tests pass. Then run `./build/bin/quiver_tests.exe` -- full suite passes with zero regressions.
  </verify>
  <done>
7 tests added to test_database_update.cpp covering scalar FK (UPD-01), vector FK (UPD-02), set FK (UPD-03), time series FK (UPD-04), combined all-types, no-FK regression, and error preservation. All tests pass and verify resolved integer IDs via read-back.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` compiles with zero errors
2. `./build/bin/quiver_tests.exe` -- full test suite passes (existing + 7 new tests)
3. `./build/bin/quiver_c_tests.exe` -- C API tests pass (no C API changes, but confirms no regressions)
4. Grep `src/database_update.cpp` for `resolve_element_fk_labels` -- exactly one call site
5. Grep `src/database_update.cpp` for `element.scalars()` or `element.arrays()` after the resolve call -- should only appear in the emptiness check, not in downstream code
</verification>

<success_criteria>
- update_element resolves FK labels for all 4 column types (scalar, vector, set, time series)
- Failed FK resolution preserves existing element state
- Non-FK schemas work unchanged through pre-resolve passthrough
- All existing tests pass with zero regressions
- 7 new tests prove UPD-01 through UPD-04
</success_criteria>

<output>
After completion, create `.planning/phases/03-update-element-fk-resolution/03-01-SUMMARY.md`
</output>
