---
phase: 08-relations-cleanup
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - bindings/python/tests/test_database_create.py
  - bindings/python/tests/test_database_update.py
autonomous: true
requirements: [REL-02]
must_haves:
  truths:
    - "FK label resolution works for scalar FK columns via create_element"
    - "FK integer passthrough works for scalar FK columns via create_element"
    - "FK label resolution works for vector FK columns via create_element"
    - "FK label resolution works for set FK columns via create_element"
    - "FK label resolution works for time series FK columns via create_element"
    - "All FK types can be resolved in a single create_element call"
    - "Missing FK target label raises QuiverError with no partial writes"
    - "Non-FK string rejection raises QuiverError"
    - "Empty collection with no FK data returns empty list"
    - "update_element resolves FK labels for all column types"
    - "Failed FK resolution in update preserves existing values"
    - "FK metadata reports is_foreign_key and references_collection correctly"
  artifacts:
    - path: "bindings/python/tests/test_database_create.py"
      provides: "TestFKResolutionCreate class with 12 test methods"
      contains: "class TestFKResolutionCreate"
    - path: "bindings/python/tests/test_database_update.py"
      provides: "TestFKResolutionUpdate class with 8 test methods"
      contains: "class TestFKResolutionUpdate"
  key_links:
    - from: "bindings/python/tests/test_database_create.py"
      to: "bindings/python/src/quiverdb/database.py"
      via: "create_element with FK labels"
      pattern: "create_element.*parent_id.*Parent"
    - from: "bindings/python/tests/test_database_update.py"
      to: "bindings/python/src/quiverdb/database.py"
      via: "update_element with FK labels"
      pattern: "update_element.*parent_id.*Parent"
    - from: "bindings/python/tests/test_database_create.py"
      to: "tests/schemas/valid/relations.sql"
      via: "relations_db fixture"
      pattern: "relations_db"
---

<objective>
Port the complete FK resolution test suite from Julia/Dart to Python, covering create, update, and metadata verification.

Purpose: Achieve full FK test parity with Julia/Dart bindings. The 3 old relation tests are replaced with 12 create tests + 8 update tests, covering all FK column types (scalar, vector, set, time series), error cases, empty collection, and self-reference. FK metadata tests already exist in test_database_metadata.py and need no changes.
Output: Comprehensive FK resolution test classes in test_database_create.py and test_database_update.py.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-relations-cleanup/08-CONTEXT.md
@.planning/phases/08-relations-cleanup/08-RESEARCH.md
@.planning/phases/08-relations-cleanup/08-01-SUMMARY.md
@bindings/python/tests/test_database_create.py
@bindings/python/tests/test_database_update.py
@bindings/python/tests/conftest.py
@bindings/julia/test/test_database_create.jl
@bindings/julia/test/test_database_update.jl
@tests/schemas/valid/relations.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TestFKResolutionCreate class with 12 FK create tests</name>
  <files>bindings/python/tests/test_database_create.py</files>
  <action>
Add a new `TestFKResolutionCreate` class at the end of `test_database_create.py`. This class ports the FK resolution create tests from Julia's `test_database_create.jl` (lines 370-566). All tests use the existing `relations_db` fixture (from conftest.py) which creates a database with `relations.sql` schema. The `db` fixture (basic.sql) is used for the no-FK-columns test.

Import `QuiverError` from quiverdb at the top of the file (add to existing import line: `from quiverdb import Database, Element, QuiverError`). Also import `pytest` if not already imported.

Every test method must first create a Configuration element (schema requires it). Assertions verify resolved integer IDs only (per locked decision -- no label round-trip queries).

**IMPORTANT -- Column name vs group name convention:** The vector/set/time_series read-by-id functions (`read_vector_integers_by_id`, `read_set_integers_by_id`) take the **column name** (attribute) as the second argument, NOT the group name. For example, `Child_vector_refs` has group name `"refs"` but the FK column inside it is `"parent_ref"`. The read call uses the column name: `read_vector_integers_by_id("Child", "parent_ref", id)`. Similarly, `Element.set()` keys are column names. This matches the Julia test patterns exactly (confirmed: Julia test lines 465-469 use `parent_ref`, lines 383-387 use `mentor_id`, line 416 uses `score`).

**12 test methods to implement:**

1. `test_scalar_fk_label(self, relations_db)` -- Create Parent, then Child with `parent_id="Parent 1"`. Read back `parent_id` via `read_scalar_integer_by_id`, assert equals 1.

2. `test_scalar_fk_integer(self, relations_db)` -- Create Parent, then Child with `parent_id=1` (integer). Read back, assert equals 1.

3. `test_vector_fk_labels(self, relations_db)` -- Create Parent 1 and Parent 2, then Child with `parent_ref=["Parent 1", "Parent 2"]`. Read back via `read_vector_integers_by_id("Child", "parent_ref", child_id)`, assert equals `[1, 2]`. Note: `"parent_ref"` is the column name inside `Child_vector_refs`, not the group name `"refs"`.

4. `test_set_fk_labels(self, relations_db)` -- Create Parent 1 and Parent 2, then Child with `mentor_id=["Parent 1", "Parent 2"]`. Read back via `read_set_integers_by_id("Child", "mentor_id", child_id)`, assert `sorted(result) == [1, 2]`. Note: `"mentor_id"` is the column name inside `Child_set_mentors`, not the group name `"mentors"`.

5. `test_time_series_fk_labels(self, relations_db)` -- Create Parent 1 and Parent 2, then Child with `date_time=["2024-01-01", "2024-01-02"]` and `sponsor_id=["Parent 1", "Parent 2"]`. Read back via `read_time_series_group("Child", "events", child_id)`, assert sponsor_id column equals `[1, 2]`.

6. `test_all_fk_types_in_one_call(self, relations_db)` -- Create Parent 1 and Parent 2, then Child with ALL FK types in one call: `parent_id="Parent 1"`, `mentor_id=["Parent 2"]`, `parent_ref=["Parent 1"]`, `date_time=["2024-01-01"]`, `sponsor_id=["Parent 2"]`. Verify each FK type resolved correctly using the appropriate typed read.

7. `test_no_fk_columns_unchanged(self, db)` -- Uses basic.sql (no FK columns). Create Configuration element with `label="Config 1"`, `integer_attribute=42`, `float_attribute=3.14`. Verify all values readable correctly (confirms FK resolve pass is a no-op for non-FK schemas).

8. `test_missing_target_label_error(self, relations_db)` -- Create Configuration but no Parent. Attempt to create Child with `mentor_id=["Nonexistent Parent"]`. Assert raises `QuiverError`.

9. `test_non_fk_string_rejection_error(self, relations_db)` -- Create Configuration and Parent. Attempt to create Child with `parent_id=1` and `score=["not_a_label"]`. Assert raises `QuiverError`. Note: `"score"` is the column name inside `Child_set_scores` (non-FK integer column), not the group name `"scores"`. Matches Julia test line 416.

10. `test_resolution_failure_no_partial_writes(self, relations_db)` -- Create Configuration but no Parent. Attempt to create Child with `parent_id="Nonexistent Parent"`. Assert raises `QuiverError`. Then verify no Child was created: `read_scalar_strings("Child", "label")` returns empty list.

11. `test_self_reference_fk(self, relations_db)` -- Create Configuration, then Child 1, then Child 2 with `sibling_id="Child 1"`. Read back `sibling_id` via `read_scalar_integer_by_id("Child", "sibling_id", child_2_id)`, assert equals child_1_id. (Per locked decision: keep self-reference scenario.)

12. `test_empty_collection_no_fk_data(self, relations_db)` -- Create Configuration only (no Parent, no Child). Verify `read_scalar_integers("Child", "parent_id")` returns empty list `[]`. (Per locked decision: keep empty collection scenario.)

Note on time series test: The `relations.sql` schema's `Child_time_series_events` table has columns `date_time` (TEXT, dimension) and `sponsor_id` (INTEGER, FK to Parent). When creating a Child with time series data, set both `date_time` and `sponsor_id` as parallel arrays via Element.set().
  </action>
  <verify>
    <automated>cd C:/Development/DatabaseTmp/quiver && bindings/python/test/test.bat</automated>
    <manual>Verify TestFKResolutionCreate class has 12 test methods, all passing</manual>
  </verify>
  <done>
    - TestFKResolutionCreate class exists in test_database_create.py with 12 test methods
    - All FK resolution create scenarios pass: scalar label, scalar integer, vector, set, time series, all-in-one, no-FK passthrough, missing target error, non-FK rejection error, atomicity (no partial writes), self-reference, empty collection
    - Tests mirror Julia/Dart FK test suite categories plus all 3 original scenarios (basic FK, empty collection, self-reference)
    - All existing tests continue to pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TestFKResolutionUpdate class with 8 FK update tests</name>
  <files>bindings/python/tests/test_database_update.py</files>
  <action>
**Update tests (test_database_update.py)**

Add a new `TestFKResolutionUpdate` class at the end of `test_database_update.py`. This class ports the FK resolution update tests from Julia's `test_database_update.jl` (lines 765-964). All tests use the `relations_db` fixture. The `db` fixture (basic.sql) is used for the no-FK-columns test.

Import `QuiverError` from quiverdb at the top of the file (add to existing import line: `from quiverdb import Database, Element, QuiverError`).

Every test creates initial data via `create_element`, then modifies FK values via `update_element`, then reads back to verify.

**IMPORTANT -- Column name vs group name convention:** Same as Task 1. Use column names (`"parent_ref"`, `"mentor_id"`, `"score"`) in Element.set() and read calls, not group names (`"refs"`, `"mentors"`, `"scores"`). This matches Julia test patterns exactly.

**8 test methods to implement:**

1. `test_scalar_fk_label(self, relations_db)` -- Create Parent 1, Parent 2, Child with `parent_id="Parent 1"`. Update Child: `update_element("Child", 1, Element().set("parent_id", "Parent 2"))`. Verify `read_scalar_integer_by_id("Child", "parent_id", 1)` equals 2.

2. `test_scalar_fk_integer(self, relations_db)` -- Create Parent 1, Parent 2, Child with `parent_id=1`. Update Child: `update_element("Child", 1, Element().set("parent_id", 2))`. Verify parent_id equals 2.

3. `test_vector_fk_labels(self, relations_db)` -- Create Parent 1, Parent 2, Child with `parent_ref=["Parent 1"]`. Update Child: `update_element("Child", 1, Element().set("parent_ref", ["Parent 2", "Parent 1"]))`. Verify `read_vector_integers_by_id("Child", "parent_ref", 1)` equals `[2, 1]`.

4. `test_set_fk_labels(self, relations_db)` -- Create Parent 1, Parent 2, Child with `mentor_id=["Parent 1"]`. Update Child: `update_element("Child", 1, Element().set("mentor_id", ["Parent 2"]))`. Verify `read_set_integers_by_id("Child", "mentor_id", 1)` equals `[2]`.

5. `test_time_series_fk_labels(self, relations_db)` -- Create Parent 1, Parent 2, Child with `date_time=["2024-01-01"]`, `sponsor_id=["Parent 1"]`. Update Child: `update_element("Child", 1, Element().set("date_time", ["2024-06-01", "2024-06-02"]).set("sponsor_id", ["Parent 2", "Parent 1"]))`. Verify time series `sponsor_id` column equals `[2, 1]`.

6. `test_all_fk_types_in_one_call(self, relations_db)` -- Create initial data with all FK types pointing to Parent 1. Update all FKs to Parent 2 in a single `update_element` call. Verify each FK type resolved correctly.

7. `test_no_fk_columns_unchanged(self, db)` -- Uses basic.sql (no FK columns). Create Configuration with initial values. Update via `update_element` with new scalar values. Verify all updated correctly (FK resolve pass is a no-op).

8. `test_resolution_failure_preserves_existing(self, relations_db)` -- Create Parent 1, Child with `parent_id="Parent 1"`. Attempt `update_element("Child", 1, Element().set("parent_id", "Nonexistent Parent"))`. Assert raises `QuiverError`. Verify original `parent_id` value (1) is preserved.

**FK metadata verification (test_database_metadata.py) -- NO CHANGES NEEDED:**

The existing `test_database_metadata.py` already has FK metadata tests at lines 54-65 in `TestGetScalarMetadata`:
- `test_get_scalar_metadata_foreign_key` (line 54) -- verifies `parent_id` has `is_foreign_key=True`, `references_collection="Parent"`, `references_column="id"`
- `test_get_scalar_metadata_self_reference_fk` (line 61) -- verifies `sibling_id` has `is_foreign_key=True`, `references_collection="Child"`, `references_column="id"`

These tests are confirmed to exist and satisfy the CONTEXT.md FK metadata requirement. Do not modify test_database_metadata.py.
  </action>
  <verify>
    <automated>cd C:/Development/DatabaseTmp/quiver && bindings/python/test/test.bat</automated>
    <manual>Verify TestFKResolutionUpdate class has 8 test methods, all passing. Verify FK metadata tests exist and pass in test_database_metadata.py (no modifications to that file).</manual>
  </verify>
  <done>
    - TestFKResolutionUpdate class exists in test_database_update.py with 8 test methods
    - All FK resolution update scenarios pass: scalar label, scalar integer, vector, set, time series, all-in-one, no-FK passthrough, resolution failure preserves existing
    - FK metadata tests confirmed to exist and pass in test_database_metadata.py (not modified)
    - Tests mirror Julia/Dart FK test suite categories
    - Full Python test suite passes (all test files, zero regressions)
  </done>
</task>

</tasks>

<verification>
1. `bindings/python/test/test.bat` passes with all tests green
2. `TestFKResolutionCreate` in test_database_create.py has 12 test methods
3. `TestFKResolutionUpdate` in test_database_update.py has 8 test methods
4. FK metadata tests pass in test_database_metadata.py (pre-existing, not modified)
5. Total Python test count increased by ~20 tests compared to pre-phase baseline
</verification>

<success_criteria>
- Python FK test coverage matches Julia/Dart categories: scalar label, scalar integer, vector, set, time series, all-in-one, no-FK passthrough, error cases
- All 3 original scenarios preserved per locked decision: basic FK, empty collection, self-reference
- All 20 new FK tests pass
- All pre-existing tests pass (zero regressions)
- Test organization follows locked decision: create tests in test_database_create.py, update tests in test_database_update.py
- test_database_metadata.py is NOT modified (FK metadata tests already exist)
</success_criteria>

<output>
After completion, create `.planning/phases/08-relations-cleanup/08-02-SUMMARY.md`
</output>
