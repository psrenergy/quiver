---
phase: 03-c-api-string-consistency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/string.h
  - src/CMakeLists.txt
  - src/c/database_helpers.h
  - src/c/database_read.cpp
  - src/c/element.cpp
  - CLAUDE.md
autonomous: true
requirements:
  - QUAL-04
must_haves:
  truths:
    - "No inline `new char[]` + memcpy/std::copy string patterns exist in src/c/ files"
    - "All C API string copies use strdup_safe from utils/string.h"
    - "All existing C API tests pass unchanged"
  artifacts:
    - path: "src/utils/string.h"
      provides: "strdup_safe utility function in namespace quiver::string"
      contains: "strdup_safe"
    - path: "src/c/database_helpers.h"
      provides: "copy_strings_to_c using strdup_safe internally"
      contains: "strdup_safe"
    - path: "src/c/database_read.cpp"
      provides: "String read functions using strdup_safe"
      contains: "strdup_safe"
    - path: "src/c/element.cpp"
      provides: "element_to_string using strdup_safe"
      contains: "strdup_safe"
  key_links:
    - from: "src/c/database_helpers.h"
      to: "src/utils/string.h"
      via: "#include and using-declaration"
      pattern: 'include.*utils/string\.h'
    - from: "src/c/element.cpp"
      to: "src/utils/string.h"
      via: "#include"
      pattern: 'include.*utils/string\.h'
---

<objective>
Extract strdup_safe to src/utils/string.h, add PRIVATE include path to quiver_c, replace all 5 inline string allocation sites with strdup_safe calls, and update documentation.

Purpose: Eliminate duplicated inline string allocation patterns in favor of the single strdup_safe helper, improving consistency and auditability of C API string handling.
Output: All C API string copies use strdup_safe; no inline new char[] + memcpy/std::copy patterns remain in src/c/.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-c-api-string-consistency/03-RESEARCH.md

<interfaces>
<!-- Current src/utils/string.h (add strdup_safe here): -->
From src/utils/string.h:
```cpp
#ifndef QUIVER_STRING_H
#define QUIVER_STRING_H
#include <string>
namespace quiver::string {
inline std::string trim(const std::string& str) { /* ... */ }
}  // namespace quiver::string
#endif  // QUIVER_STRING_H
```

<!-- Current strdup_safe in database_helpers.h (lines 95-100, to be removed after extraction): -->
From src/c/database_helpers.h:
```cpp
inline char* strdup_safe(const std::string& str) {
    auto result = new char[str.size() + 1];
    std::copy(str.begin(), str.end(), result);
    result[str.size()] = '\0';
    return result;
}
```

<!-- copy_strings_to_c stays in database_helpers.h but uses strdup_safe internally (lines 64-77): -->
From src/c/database_helpers.h:
```cpp
inline quiver_error_t copy_strings_to_c(const std::vector<std::string>& values,
                                         char*** out_values, size_t* out_count) {
    *out_count = values.size();
    if (values.empty()) { *out_values = nullptr; return QUIVER_OK; }
    *out_values = new char*[values.size()];
    for (size_t i = 0; i < values.size(); ++i) {
        (*out_values)[i] = new char[values[i].size() + 1];        // <-- replace
        std::copy(values[i].begin(), values[i].end(), (*out_values)[i]); // <-- replace
        (*out_values)[i][values[i].size()] = '\0';                 // <-- replace
    }
    return QUIVER_OK;
}
```

<!-- quiver_c target include directories (lines 121-124 of src/CMakeLists.txt): -->
From src/CMakeLists.txt:
```cmake
target_include_directories(quiver_c PUBLIC
    $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract strdup_safe to utils, update CMake, replace all 5 inline allocation sites</name>
  <files>src/utils/string.h, src/CMakeLists.txt, src/c/database_helpers.h, src/c/database_read.cpp, src/c/element.cpp</files>
  <action>
**Step 1 — Add strdup_safe to src/utils/string.h:**
Add `#include <algorithm>` to the includes. Add inline `char* strdup_safe(const std::string& str)` function inside `namespace quiver::string`, after the existing `trim()` function. Implementation: `auto result = new char[str.size() + 1]; std::copy(str.begin(), str.end(), result); result[str.size()] = '\0'; return result;`

**Step 2 — Add PRIVATE include path to quiver_c target in src/CMakeLists.txt:**
Change quiver_c's `target_include_directories` (lines 121-124) to add a PRIVATE section with `${CMAKE_CURRENT_SOURCE_DIR}`. Result:
```cmake
target_include_directories(quiver_c
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}
)
```

**Step 3 — Update src/c/database_helpers.h:**
- Add `#include "utils/string.h"` after the existing includes (before the first template)
- REMOVE the `strdup_safe` function definition (lines 95-100) entirely
- Add `using quiver::string::strdup_safe;` immediately after the new include (this keeps all existing bare `strdup_safe()` calls working in database_helpers.h and all files that include it)
- In `copy_strings_to_c` (lines 71-74), replace the 3-line inline allocation:
  ```cpp
  (*out_values)[i] = new char[values[i].size() + 1];
  std::copy(values[i].begin(), values[i].end(), (*out_values)[i]);
  (*out_values)[i][values[i].size()] = '\0';
  ```
  with: `(*out_values)[i] = strdup_safe(values[i]);`

**Step 4 — Update src/c/database_read.cpp (3 sites):**

Site 1 — string vector read inner loop (lines 144-146): Replace:
```cpp
(*out_vectors)[i][j] = new char[vectors[i][j].size() + 1];
std::copy(vectors[i][j].begin(), vectors[i][j].end(), (*out_vectors)[i][j]);
(*out_vectors)[i][j][vectors[i][j].size()] = '\0';
```
with: `(*out_vectors)[i][j] = strdup_safe(vectors[i][j]);`

Site 2 — string set read inner loop (lines 246-248): Replace:
```cpp
(*out_sets)[i][j] = new char[sets[i][j].size() + 1];
std::copy(sets[i][j].begin(), sets[i][j].end(), (*out_sets)[i][j]);
(*out_sets)[i][j][sets[i][j].size()] = '\0';
```
with: `(*out_sets)[i][j] = strdup_safe(sets[i][j]);`

Site 3 — read_scalar_string_by_id (lines 318-320): Replace:
```cpp
*out_value = new char[result->size() + 1];
std::copy(result->begin(), result->end(), *out_value);
(*out_value)[result->size()] = '\0';
```
with: `*out_value = strdup_safe(*result);`

Note: database_read.cpp already includes database_helpers.h, so `strdup_safe` is available via the using-declaration. No new include needed.

**Step 5 — Update src/c/element.cpp:**
- Add `#include "utils/string.h"` after existing includes
- Add `using quiver::string::strdup_safe;` after the include
- In `quiver_element_to_string` (lines 146-154), replace the entire try-catch:
  ```cpp
  try {
      auto str = element->element.to_string();
      auto result = new char[str.size() + 1];
      std::memcpy(result, str.c_str(), str.size() + 1);
      *out_string = result;
      return QUIVER_OK;
  } catch (const std::bad_alloc&) {
      quiver_set_last_error("Memory allocation failed");
      return QUIVER_ERROR;
  }
  ```
  with:
  ```cpp
  try {
      auto str = element->element.to_string();
      *out_string = strdup_safe(str);
      return QUIVER_OK;
  } catch (const std::exception& e) {
      quiver_set_last_error(e.what());
      return QUIVER_ERROR;
  }
  ```
  This removes the dead `std::bad_alloc` catch and uses the standard `std::exception` pattern consistent with all other C API functions.

**Design decisions:**
- Only `strdup_safe` moves to `src/utils/string.h`. `copy_strings_to_c` stays in `database_helpers.h` because it returns `quiver_error_t` (C API type) — moving it would create a dependency from utility layer to C API headers. This is the cleanest resolution per RESEARCH.md recommendation.
- `using quiver::string::strdup_safe;` in `database_helpers.h` keeps the diff minimal — all 13+ existing bare `strdup_safe()` call sites (metadata converters, query, time series) continue to compile without qualification changes.
- The `std::bad_alloc` catch in `element_to_string` is removed for consistency with every other C API function that calls `strdup_safe`.
  </action>
  <verify>
    <automated>cmake --build build --config Debug 2>&1 | tail -5</automated>
  </verify>
  <done>
    - strdup_safe exists in src/utils/string.h under namespace quiver::string
    - strdup_safe definition removed from database_helpers.h, replaced by include + using-declaration
    - All 5 inline allocation sites replaced with strdup_safe calls
    - quiver_c has PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} in its include directories
    - Project compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Run tests and update documentation</name>
  <files>CLAUDE.md</files>
  <action>
**Step 1 — Run all tests to verify behavior preservation:**
Run `./build/bin/quiver_c_tests.exe` (C API tests) and `./build/bin/quiver_tests.exe` (C++ tests). Both must pass with zero failures.

**Step 2 — Verify no inline string allocation patterns remain:**
Run: `grep -rn "new char\[" src/c/` and confirm the only hits are numeric array allocations (e.g., `new T[vectors.size()]` for `int64_t*`/`double*`/`char**`/`size_t*` arrays), NOT string copy patterns (no `new char[...size() + 1]`).

**Step 3 — Update CLAUDE.md:**

3a. Update Architecture tree to show `src/utils/`:
In the `src/` section of the Architecture tree, add `utils/string.h` entry showing it contains `strdup_safe` and `trim` utilities. Place it after the existing `src/c/` entries. Example:
```
src/                      # C++ implementation
  ...existing entries...
  utils/string.h          # String utilities: strdup_safe, trim
```

3b. Update String Handling section:
Change the String Handling section to reference `src/utils/string.h` instead of `database_helpers.h` as the home of `strdup_safe`. The `strdup_safe` function signature and behavior are unchanged — only the location reference updates.
  </action>
  <verify>
    <automated>./build/bin/quiver_c_tests.exe 2>&1 | tail -3 && ./build/bin/quiver_tests.exe 2>&1 | tail -3</automated>
  </verify>
  <done>
    - All C API tests pass (zero failures)
    - All C++ tests pass (zero failures)
    - grep confirms no inline new char[...size() + 1] patterns in src/c/
    - CLAUDE.md Architecture tree shows src/utils/string.h
    - CLAUDE.md String Handling section references src/utils/string.h
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build --config Debug` completes without errors
2. C API tests: `./build/bin/quiver_c_tests.exe` — all pass
3. C++ tests: `./build/bin/quiver_tests.exe` — all pass
4. Grep check: `grep -rn "new char\[" src/c/` shows zero string copy patterns (no `new char[...size() + 1]` followed by memcpy/std::copy)
5. strdup_safe location: `grep -rn "strdup_safe" src/utils/string.h` confirms the function definition exists there
</verification>

<success_criteria>
- QUAL-04 satisfied: Every C API function that copies a C++ string to a returned char* uses strdup_safe — no inline new char[] + memcpy or std::copy string patterns exist in src/c/
- All existing tests pass unchanged (behavior identical, only implementation differs)
- strdup_safe lives in src/utils/string.h under namespace quiver::string
- CLAUDE.md updated to reflect new utility location
</success_criteria>

<output>
After completion, create `.planning/phases/03-c-api-string-consistency/03-01-SUMMARY.md`
</output>
