---
phase: 10-cross-layer-docs-final-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CLAUDE.md
autonomous: true
must_haves:
  truths:
    - "CLAUDE.md contains a Cross-Layer Naming Conventions section with transformation rules from C++ to each binding layer"
    - "The documentation includes a representative mapping table showing C++ method -> C API function -> Julia method -> Dart method -> Lua method for each operation category"
    - "Binding-only convenience methods (DateTime wrappers, read_all composites) are documented separately"
    - "Dart factory method naming difference (named constructors) is documented"
    - "Julia mutating convention (! suffix) is explicitly documented"
    - "scripts/build-all.bat succeeds end-to-end with all 5 test stages green"
  artifacts:
    - path: "CLAUDE.md"
      provides: "Cross-layer naming conventions documentation"
      contains: "Cross-Layer Naming Conventions"
  key_links:
    - from: "CLAUDE.md Cross-Layer Naming Conventions"
      to: "CLAUDE.md C++ Patterns Naming Convention"
      via: "Cross-references existing C++ naming pattern documentation"
      pattern: "verb_\\[category_\\]type"
    - from: "CLAUDE.md Cross-Layer Naming Conventions"
      to: "CLAUDE.md C API Patterns"
      via: "Cross-references existing C API naming pattern documentation"
      pattern: "quiver_database_"
---

<objective>
Document the cross-layer naming conventions in CLAUDE.md and run the full-stack build and test suite as the final gate for the entire refactoring project.

Purpose: Phase 10 is the capstone of the Quiver refactoring. The documentation ensures any developer can predict method names in any layer given the C++ name, and the full verification confirms all 10 phases of work produce a passing codebase. Satisfies requirements NAME-06, TEST-01, TEST-02, TEST-03, TEST-04, TEST-05.

Output: Updated CLAUDE.md with naming conventions section; green build-all.bat run confirming all layers pass.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-cross-layer-docs-final-verification/10-RESEARCH.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Cross-Layer Naming Conventions section to CLAUDE.md</name>
  <files>CLAUDE.md</files>
  <action>
Read the full CLAUDE.md. Insert a new top-level section `## Cross-Layer Naming Conventions` **after** the `## Core API` section (which ends before `## Bindings`) and **before** the `## Bindings` section.

The section must contain exactly these subsections:

**1. `### Transformation Rules`**

A compact table showing how to convert any C++ method name to each layer:

| From C++ | To C API | To Julia | To Dart | To Lua |
|----------|----------|----------|---------|--------|
| `method_name` | `quiver_database_method_name` | `method_name` (+ `!` if mutating) | `methodName` | `method_name` |
| `Database::from_schema()` | `quiver_database_from_schema()` | `from_schema()` | `Database.fromSchema()` | N/A |

Then document the 4 rules as bullet points:
- **C++ to C API:** Prefix `quiver_database_` to the C++ method name. Example: `create_element` -> `quiver_database_create_element`
- **C++ to Julia:** Same name. Add `!` suffix for mutating operations (create, update, delete). Example: `create_element` -> `create_element!`, `read_scalar_integers` -> `read_scalar_integers`
- **C++ to Dart:** Convert `snake_case` to `camelCase`. Example: `read_scalar_integers` -> `readScalarIntegers`. Factory methods use Dart named constructors: `from_schema` -> `Database.fromSchema()`
- **C++ to Lua:** Same name exactly (1:1 match). Example: `read_scalar_integers` -> `read_scalar_integers`. Lua has no lifecycle methods (open/close) -- database is provided as `db` userdata by LuaRunner.

**2. `### Representative Cross-Layer Examples`**

One table per operation category showing ONE representative example. Use the exact method names from the research document. Categories and representative methods:

| Category | C++ | C API | Julia | Dart | Lua |
|----------|-----|-------|-------|------|-----|
| Factory | `Database::from_schema()` | `quiver_database_from_schema()` | `from_schema()` | `Database.fromSchema()` | N/A |
| Create | `create_element()` | `quiver_database_create_element()` | `create_element!()` | `createElement()` | `create_element()` |
| Read scalar | `read_scalar_integers()` | `quiver_database_read_scalar_integers()` | `read_scalar_integers()` | `readScalarIntegers()` | `read_scalar_integers()` |
| Read by ID | `read_scalar_integer_by_id()` | `quiver_database_read_scalar_integer_by_id()` | `read_scalar_integer_by_id()` | `readScalarIntegerById()` | `read_scalar_integer_by_id()` |
| Update scalar | `update_scalar_integer()` | `quiver_database_update_scalar_integer()` | `update_scalar_integer!()` | `updateScalarInteger()` | `update_scalar_integer()` |
| Update vector | `update_vector_strings()` | `quiver_database_update_vector_strings()` | `update_vector_strings!()` | `updateVectorStrings()` | `update_vector_strings()` |
| Delete | `delete_element()` | `quiver_database_delete_element()` | `delete_element!()` | `deleteElement()` | `delete_element()` |
| Metadata | `get_scalar_metadata()` | `quiver_database_get_scalar_metadata()` | `get_scalar_metadata()` | `getScalarMetadata()` | `get_scalar_metadata()` |
| List groups | `list_vector_groups()` | `quiver_database_list_vector_groups()` | `list_vector_groups()` | `listVectorGroups()` | `list_vector_groups()` |
| Time series | `read_time_series_group()` | `quiver_database_read_time_series_group()` | `read_time_series_group()` | `readTimeSeriesGroup()` | `read_time_series_group()` |
| Query | `query_string()` | `quiver_database_query_string()` | `query_string()` | `queryString()` | `query_string()` |
| Relations | `update_scalar_relation()` | `quiver_database_update_scalar_relation()` | `update_scalar_relation!()` | `updateScalarRelation()` | `update_scalar_relation()` |
| CSV | `export_csv()` | `quiver_database_export_csv()` | `export_csv()` | `exportCSV()` | N/A |
| Describe | `describe()` | `quiver_database_describe()` | `describe()` | `describe()` | `describe()` |

Add a note below the table: "The transformation rules are mechanical. Given any C++ method name, you can derive the equivalent in any layer without consulting a lookup table."

**3. `### Binding-Only Convenience Methods`**

Document that Julia, Dart, and Lua provide additional convenience methods that compose core operations. These have no direct C++ or C API counterpart.

**DateTime wrappers (Julia and Dart only):**
- `read_scalar_date_time_by_id` / `readScalarDateTimeById` -- wraps string read + date parsing
- `read_vector_date_time_by_id` / `readVectorDateTimesById` -- wraps string vector read + date parsing
- `read_set_date_time_by_id` / `readSetDateTimesById` -- wraps string set read + date parsing
- `query_date_time` / `queryDateTime` -- wraps string query + date parsing

**Composite read helpers (Julia, Dart, and Lua):**
- `read_all_scalars_by_id` / `readAllScalarsById` -- iterates `list_scalar_attributes` + typed reads
- `read_all_vectors_by_id` / `readAllVectorsById` -- iterates `list_vector_groups` + typed reads
- `read_all_sets_by_id` / `readAllSetsById` -- iterates `list_set_groups` + typed reads

**Multi-column group readers (Julia and Dart only):**
- `read_vector_group_by_id` / `readVectorGroupById` -- multi-column vector read via metadata + per-column reads
- `read_set_group_by_id` / `readSetGroupById` -- multi-column set read via metadata + per-column reads

Keep this section concise. Use a brief table or compact list, not verbose paragraphs.

**Important:** Do NOT modify any other section of CLAUDE.md. Only insert the new section between Core API and Bindings.
  </action>
  <verify>
1. Confirm the new section exists between Core API and Bindings:
```bash
grep -n "## Cross-Layer Naming Conventions\|## Core API\|## Bindings" CLAUDE.md
```
Should show Core API, then Cross-Layer Naming Conventions, then Bindings in that order.

2. Confirm key content is present:
```bash
grep -c "Transformation Rules\|Representative Cross-Layer\|Binding-Only Convenience" CLAUDE.md
```
Should output 3.
  </verify>
  <done>
CLAUDE.md contains a new `## Cross-Layer Naming Conventions` section after `## Core API` and before `## Bindings` with: transformation rules table + 4 bullet rules, representative cross-layer examples table covering 14 operation categories, and binding-only convenience methods subsection documenting DateTime wrappers, composite readers, and multi-column group readers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run full-stack build and test verification</name>
  <files></files>
  <action>
Run the full build-all.bat script to verify all layers build and all test suites pass. This is the final gate for the entire refactoring project.

```bash
scripts/build-all.bat
```

This script runs 5 sequential stages:
1. Build C++ library and C API (cmake configure + build)
2. Run C++ tests (`quiver_tests.exe`)
3. Run C API tests (`quiver_c_tests.exe`)
4. Run Julia tests (`bindings/julia/test/test.bat`)
5. Run Dart tests (`bindings/dart/test/test.bat`)

Each stage is fail-fast -- if any stage fails, the script exits immediately with an error.

**If build-all.bat succeeds:** All 5 stages passed. Record the test counts from output for each suite in the SUMMARY.

**If build-all.bat fails:** Record which stage failed and the error output. This indicates a regression that must be investigated. Do NOT proceed to SUMMARY creation -- instead note the failure for the user to investigate.

**Important:** This task produces no file changes. It is purely a verification gate that confirms the entire 10-phase refactoring project produces a clean, passing codebase.
  </action>
  <verify>
The script itself provides verification. Confirm the final output shows:
```
All builds and tests completed successfully!
  C++ library:  OK
  C API:        OK
  C++ tests:    OK
  C API tests:  OK
  Julia tests:  OK
  Dart tests:   OK
```
  </verify>
  <done>
scripts/build-all.bat exits with code 0. All 5 test stages pass: C++ tests green, C API tests green, Julia tests green, Dart tests green. The entire refactoring project is verified as producing a clean, passing codebase.
  </done>
</task>

</tasks>

<verification>
1. CLAUDE.md has `## Cross-Layer Naming Conventions` section between `## Core API` and `## Bindings`
2. Section contains transformation rules, representative examples table, and binding-only convenience methods
3. `scripts/build-all.bat` exits with code 0
4. All 5 test stages (C++ build, C++ tests, C API tests, Julia tests, Dart tests) pass
</verification>

<success_criteria>
- CLAUDE.md naming convention section satisfies NAME-06: cross-layer mapping examples with transformation rules
- build-all.bat green satisfies TEST-05
- C++ tests green satisfies TEST-01
- C API tests green satisfies TEST-02
- Julia tests green satisfies TEST-03
- Dart tests green satisfies TEST-04
</success_criteria>

<output>
After completion, create `.planning/phases/10-cross-layer-docs-final-verification/10-01-SUMMARY.md`
</output>
