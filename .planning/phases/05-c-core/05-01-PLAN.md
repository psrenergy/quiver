---
phase: 05-c-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/quiver/csv.h
  - include/quiver/database.h
  - src/database_csv.cpp
  - src/database_describe.cpp
  - src/CMakeLists.txt
  - src/c/database.cpp
  - include/quiver/c/database.h
autonomous: true
requirements:
  - CSV-01
  - CSV-02
  - CSV-03
  - CSV-04
  - OPT-01
  - OPT-02
  - OPT-03
  - OPT-04

must_haves:
  truths:
    - "Calling export_csv(collection, \"\", path, options) writes a CSV file with header row (label + scalar attributes in schema order, no id) and one data row per element"
    - "Calling export_csv(collection, \"group_name\", path, options) writes a CSV file with label replacing id, using schema column names, for vector/set/time series groups"
    - "Passing enum_labels in options replaces integer values with labels; unmapped integers appear as raw integers"
    - "Passing date_time_format in options reformats DateTime columns using strftime; non-DateTime columns are unaffected"
    - "Empty collections produce header-only CSV; NULL values appear as empty fields; special characters are RFC 4180 escaped"
    - "Default options (empty enum_labels, empty date_time_format) pass through raw values unchanged"
  artifacts:
    - path: "include/quiver/csv.h"
      provides: "CSVExportOptions struct and default_csv_export_options() factory"
      contains: "CSVExportOptions"
    - path: "src/database_csv.cpp"
      provides: "export_csv implementation with scalar and group export logic, RFC 4180 writer, enum resolution, date formatting"
      min_lines: 100
    - path: "include/quiver/database.h"
      provides: "Updated export_csv method signature (4 params with default options)"
      contains: "export_csv"
  key_links:
    - from: "include/quiver/database.h"
      to: "include/quiver/csv.h"
      via: "#include"
      pattern: '#include "quiver/csv.h"'
    - from: "src/database_csv.cpp"
      to: "src/database_impl.h"
      via: "#include for impl_ access"
      pattern: '#include "database_impl.h"'
    - from: "src/database_csv.cpp"
      to: "include/quiver/csv.h"
      via: "CSVExportOptions parameter type"
      pattern: "CSVExportOptions"
---

<objective>
Implement CSV export in the C++ core: CSVExportOptions struct, export_csv() method on Database, RFC 4180 writer, enum resolution, and date formatting.

Purpose: Provide the foundational C++ implementation that all downstream layers (C API, Julia, Dart, Lua) will wrap.
Output: Working export_csv() method that can export any collection's scalars or groups to a correctly formatted CSV file.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-c-core/05-CONTEXT.md
@.planning/phases/05-c-core/05-RESEARCH.md
@include/quiver/database.h
@include/quiver/attribute_metadata.h
@include/quiver/data_type.h
@include/quiver/value.h
@include/quiver/result.h
@include/quiver/row.h
@src/database_impl.h
@src/database_describe.cpp
@src/CMakeLists.txt
@src/c/database.cpp
@include/quiver/c/database.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CSVExportOptions header and implement export_csv</name>
  <files>
    include/quiver/csv.h
    include/quiver/database.h
    src/database_csv.cpp
    src/database_describe.cpp
    src/CMakeLists.txt
  </files>
  <action>
**1. Create `include/quiver/csv.h`:**

Plain value type (Rule of Zero, no Pimpl -- no private dependencies to hide). Include guard `QUIVER_CSV_H`. Namespace `quiver`.

```cpp
struct QUIVER_API CSVExportOptions {
    std::unordered_map<std::string, std::unordered_map<int64_t, std::string>> enum_labels;
    std::string date_time_format;  // strftime format string; empty = no formatting
};

inline CSVExportOptions default_csv_export_options() {
    return {};
}
```

Include `"export.h"`, `<string>`, `<unordered_map>`, `<cstdint>`.

**2. Update `include/quiver/database.h`:**

- Add `#include "quiver/csv.h"` near the top includes
- Replace the old 2-param export_csv declaration:
  ```cpp
  void export_csv(const std::string& table, const std::string& path);
  ```
  with the new 4-param signature:
  ```cpp
  void export_csv(const std::string& collection,
                  const std::string& group,
                  const std::string& path,
                  const CSVExportOptions& options = default_csv_export_options());
  ```
- Keep `import_csv` as-is (it is out of scope for this phase).

**3. Create `src/database_csv.cpp`:**

This is a new file. Include `"database_impl.h"` and `"quiver/csv.h"`. Also include `<fstream>`, `<filesystem>`, `<sstream>`, `<iomanip>`, `<ctime>`, `<cstring>`.

Implement these static helper functions (file-local, not in header):

- `csv_escape(const std::string& field) -> std::string`: RFC 4180 escaping. If field contains comma, double-quote, newline, or carriage return, wrap in double quotes and double any internal quotes. Otherwise return as-is.

- `parse_iso8601(const std::string& datetime_str, std::tm& tm) -> bool`: Cross-platform ISO 8601 parser using `std::get_time` (NOT `strptime` -- unavailable on MSVC). Try `"%Y-%m-%dT%H:%M:%S"` first, then `"%Y-%m-%d %H:%M:%S"` (space separator). Return false on parse failure.

- `format_datetime(const std::string& raw_value, const std::string& format) -> std::string`: Parse with `parse_iso8601`, format with `std::strftime`. Return raw_value unchanged if parsing fails.

- `value_to_csv_string(const Value& value, const std::string& column_name, DataType data_type, const CSVExportOptions& options) -> std::string`:
  - NULL (`std::nullptr_t`) -> empty string (unquoted)
  - Integer: check `options.enum_labels[column_name]` map; if found, return escaped label; if not found, return `std::to_string(int_val)`
  - Float: use `snprintf(buf, sizeof(buf), "%g", val)` for clean output (no trailing zeros), NOT `std::to_string` which produces `3.140000`
  - String: if `data_type == DataType::DateTime` and `options.date_time_format` is non-empty, format with `format_datetime`; then always `csv_escape` the result

- `write_csv_row(std::ofstream& file, const std::vector<std::string>& fields)`: Join fields with commas, append `\n` (LF only, NOT CRLF per user decision).

Implement `Database::export_csv(collection, group, path, options)`:

1. Create parent directories: `std::filesystem::create_directories(parent_path)` (like mkdir -p per user decision)
2. Open file in binary mode (`std::ios::binary`) to prevent Windows text-mode CRLF conversion
3. Throw `"Failed to export_csv: could not open file: {path}"` if open fails
4. If `group.empty()`: call internal scalar export logic
5. Else: call internal group export logic

**Scalar export logic:**
1. Call `impl_->require_collection(collection, "export_csv")`
2. Get columns in schema definition order by executing `SELECT * FROM {collection} LIMIT 0` and reading `result.columns()`. Do NOT use `TableDefinition::columns` (it is `std::map` = alphabetical order, which is WRONG).
3. Filter out `"id"` column. The remaining columns start with `"label"` followed by other scalar attributes in schema order.
4. Get metadata for each column using `list_scalar_attributes(collection)` to determine `DataType` for each column (needed for DateTime detection and enum resolution).
5. Write header row using the column names.
6. Execute `SELECT {columns} FROM {collection} ORDER BY rowid` to get data rows.
7. For each row, convert each value using `value_to_csv_string` and write the CSV row.

**Group export logic:**
1. Determine group type by checking schema for matching table name patterns:
   - Vector: `{collection}_vector_{group}`
   - Set: `{collection}_set_{group}`
   - Time series: `{collection}_time_series_{group}`
   Throw `"Cannot export_csv: group not found: '{group}' in collection '{collection}'"` if none match.
2. Get the group table name and its columns via `SELECT * FROM {table_name} LIMIT 0` to get schema-ordered column names.
3. Determine which columns to include in CSV output:
   - Skip `id` (replaced by `label` from parent collection)
   - For vectors: skip `vector_index`
   - Include all other columns
4. Column headers: `label` first, then the remaining group columns in schema order.
5. Get column metadata from the appropriate group metadata method (`get_vector_metadata`, `get_set_metadata`, or `get_time_series_metadata`) for DataType info.
6. Execute a JOIN query to get data:
   ```sql
   SELECT C.label, G.col1, G.col2, ...
   FROM {table_name} G
   JOIN {collection} C ON C.id = G.id
   ORDER BY G.id, G.{ordering_column}
   ```
   For vectors: order by `G.id, G.vector_index`. For sets: order by `G.id`. For time series: order by `G.id, G.{dimension_column}`.
7. Convert and write each row.

**4. Update `src/database_describe.cpp`:**
Remove the empty `export_csv` stub (line `void Database::export_csv(const std::string& table, const std::string& path) {}`). Keep `import_csv` stub and `describe()` as-is.

**5. Update `src/CMakeLists.txt`:**
Add `database_csv.cpp` to the `QUIVER_SOURCES` list (after `database_describe.cpp` or at end of the database_*.cpp group).
  </action>
  <verify>
Run: `cmake --build build --config Debug 2>&1` -- the project must compile without errors. The new `database_csv.cpp` must be compiled and linked.
  </verify>
  <done>
- `include/quiver/csv.h` exists with `CSVExportOptions` struct and `default_csv_export_options()` factory
- `database.h` has updated 4-parameter `export_csv` signature with default options
- `src/database_csv.cpp` contains full implementation (~150-250 lines) with scalar export, group export, RFC 4180 escaping, enum resolution, and date formatting
- Old 2-param stub removed from `database_describe.cpp`
- `database_csv.cpp` added to CMakeLists.txt
- Project compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Update C API stub signature to match new export_csv</name>
  <files>
    include/quiver/c/database.h
    src/c/database.cpp
  </files>
  <action>
The C API stubs for export_csv must be updated to match the new C++ signature. The FULL C API implementation with CSVExportOptions struct is Phase 6 work -- this task only updates the stub to call the C++ method correctly with default options so the existing code compiles.

**1. Update `include/quiver/c/database.h`:**

Replace the old declaration:
```c
QUIVER_C_API quiver_error_t quiver_database_export_csv(quiver_database_t* db, const char* table, const char* path);
```

With a temporary 4-param version that takes collection and group separately (the full options struct is Phase 6):
```c
QUIVER_C_API quiver_error_t quiver_database_export_csv(quiver_database_t* db, const char* collection, const char* group, const char* path);
```

Keep `import_csv` declaration unchanged.

**2. Update `src/c/database.cpp`:**

Replace the old `quiver_database_export_csv` implementation to match the new signature:
```cpp
QUIVER_C_API quiver_error_t quiver_database_export_csv(quiver_database_t* db, const char* collection, const char* group, const char* path) {
    QUIVER_REQUIRE(db, collection, group, path);
    try {
        db->db.export_csv(collection, group, path);
        return QUIVER_OK;
    } catch (const std::exception& e) {
        quiver_set_last_error(e.what());
        return QUIVER_ERROR;
    }
}
```

This calls the C++ `export_csv` with default options. The full `quiver_csv_export_options_t` struct will be added in Phase 6.

Note: This WILL break existing Julia/Dart bindings (they call with 2 args). That is expected -- Phase 7 updates bindings. The C API tests do not test export_csv yet, so no test breakage.
  </action>
  <verify>
Run: `cmake --build build --config Debug 2>&1` -- the full project (including C API library) must compile without errors. Run: `./build/bin/quiver_tests.exe` and `./build/bin/quiver_c_tests.exe` -- all existing tests must pass (export_csv is not tested yet).
  </verify>
  <done>
- C API header has updated 4-param `quiver_database_export_csv` declaration (collection, group, path -- no options yet)
- C API implementation calls `db->db.export_csv(collection, group, path)` with default options
- All existing C++ and C API tests pass
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --config Debug` compiles without errors
2. `./build/bin/quiver_tests.exe` -- all existing tests pass
3. `./build/bin/quiver_c_tests.exe` -- all existing tests pass
4. `include/quiver/csv.h` exists with CSVExportOptions struct
5. `src/database_csv.cpp` exists with export_csv implementation
6. Old 2-param export_csv stub removed from database_describe.cpp
</verification>

<success_criteria>
- CSVExportOptions struct defined as plain value type in csv.h
- default_csv_export_options() factory function follows DatabaseOptions pattern
- export_csv method on Database class with 4-param signature (collection, group, path, options)
- RFC 4180 compliant CSV writer (comma delimiter, double-quote escaping)
- Scalar export: label + attributes in schema definition order, no id column
- Group export: label replaces id, schema column names, correct ordering per group type
- Enum resolution via options.enum_labels map; unmapped integers as raw integers
- DateTime formatting via strftime on metadata-identified DateTime columns
- Empty collections produce header-only CSV
- NULL values as empty fields
- LF line endings (binary mode file output)
- Parent directories created automatically
- Existing file overwritten silently
- Project compiles and all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-c-core/05-01-SUMMARY.md`
</output>
