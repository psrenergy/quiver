---
phase: 14-verification-and-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_lua_runner.cpp
autonomous: true
requirements:
  - BIND-05
must_haves:
  truths:
    - "Lua multi-column time series update writes 4-column mixed-type data (TEXT, REAL, INTEGER, TEXT) using mixed_time_series.sql schema"
    - "Lua multi-column time series read returns row-oriented data with correct types per column"
    - "Lua composite read helpers (read_all_scalars_by_id, read_all_vectors_by_id, read_all_sets_by_id) return correct typed results"
    - "Lua time series test coverage matches Julia/Dart depth: update, read, empty read, replace, clear, ordering, multi-row"
  artifacts:
    - path: "tests/test_lua_runner.cpp"
      provides: "Multi-column time series tests and composite read helper tests for Lua"
      contains: "mixed_time_series"
  key_links:
    - from: "tests/test_lua_runner.cpp"
      to: "src/lua_runner.cpp"
      via: "LuaRunner executing Lua scripts that call db:update_time_series_group and db:read_time_series_group"
      pattern: "update_time_series_group|read_time_series_group"
    - from: "tests/test_lua_runner.cpp"
      to: "tests/schemas/valid/mixed_time_series.sql"
      via: "VALID_SCHEMA macro"
      pattern: "VALID_SCHEMA.*mixed_time_series"
---

<objective>
Add Lua multi-column time series test coverage using the mixed_time_series.sql schema, matching Julia/Dart test depth. Also add tests for composite read helpers (read_all_scalars_by_id, read_all_vectors_by_id, read_all_sets_by_id).

Purpose: Satisfy BIND-05 (Lua multi-column time series test coverage) and verify the existing Lua sol2 bindings work correctly with multi-column mixed-type schemas.
Output: Extended tests/test_lua_runner.cpp with ~8 new tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-verification-and-cleanup/14-RESEARCH.md

@tests/test_lua_runner.cpp
@tests/schemas/valid/mixed_time_series.sql
@src/lua_runner.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Lua multi-column time series tests using mixed_time_series.sql</name>
  <files>tests/test_lua_runner.cpp</files>
  <action>
Add the following tests to `tests/test_lua_runner.cpp`, appended after the existing time series tests (before the closing of the file). All tests use `LuaRunnerTest` fixture and `VALID_SCHEMA("mixed_time_series.sql")` schema.

**CRITICAL:** Lua returns row-oriented data (array of tables), NOT column-oriented. Access pattern is `rows[i].field_name`, not `result["column"][i]`.

**Schema reference:** `Sensor_time_series_readings` table has columns: `date_time TEXT NOT NULL`, `temperature REAL NOT NULL`, `humidity INTEGER NOT NULL`, `status TEXT NOT NULL`. Collection name is `Sensor`.

**Tests to add (matching Julia/Dart coverage depth):**

1. **MultiColumnTimeSeriesUpdateAndReadFromLua** -- Create Config + Sensor element, call `db:update_time_series_group("Sensor", "readings", id, {...})` with 2 rows of mixed-type data (date_time TEXT, temperature REAL, humidity INTEGER, status TEXT). Read back with `db:read_time_series_group("Sensor", "readings", id)`. Assert `#rows == 2`, then verify each row's fields: `rows[1].date_time`, `rows[1].temperature`, `rows[1].humidity`, `rows[1].status`. Verify correct types for all columns.

2. **MultiColumnTimeSeriesReadEmptyFromLua** -- Create Config + Sensor element but do NOT update time series. Call `db:read_time_series_group("Sensor", "readings", id)`. Assert `#rows == 0`.

3. **MultiColumnTimeSeriesReplaceFromLua** -- Create Config + Sensor, update with 2 rows, then update again with 3 different rows. Read back and verify only the 3 new rows exist (second update replaces first).

4. **MultiColumnTimeSeriesClearFromLua** -- Create Config + Sensor, update with 2 rows, then update with empty table `{}`. Read back and verify `#rows == 0`.

5. **MultiColumnTimeSeriesOrderingFromLua** -- Create Config + Sensor, update with rows out of order (e.g., date_time "2024-01-03", "2024-01-01", "2024-01-02"). Read back and verify rows are returned sorted by dimension column (date_time): "2024-01-01", "2024-01-02", "2024-01-03".

6. **MultiColumnTimeSeriesMultiRowFromLua** -- Create Config + Sensor, update with 5 rows covering variety of values. Read back and verify all 5 rows with correct types and values.

**Pattern for each test:**
```cpp
TEST_F(LuaRunnerTest, TestName) {
    auto db = quiver::Database::from_schema(":memory:", VALID_SCHEMA("mixed_time_series.sql"),
        {.read_only = 0, .console_level = QUIVER_LOG_OFF});
    db.create_element("Configuration", quiver::Element().set("label", "Config"));
    int64_t id = db.create_element("Sensor", quiver::Element().set("label", "Sensor 1"));

    quiver::LuaRunner lua(db);
    std::string script = R"(
        -- Lua code using db:update_time_series_group and db:read_time_series_group
        -- Use assert() with descriptive messages for each check
    )";
    // If id is dynamic, concatenate: ... "readings", )" + std::to_string(id) + R"(, { ...
    lua.run(script);
}
```

All assertions must be inside Lua scripts using `assert(condition, "descriptive message")`. The test passes if `lua.run()` does not throw. Use `EXPECT_NO_THROW(lua.run(script))` wrapping where appropriate, or just let exceptions propagate (both work with GoogleTest).
  </action>
  <verify>
Build with `cmake --build build --config Debug` and run `./build/bin/quiver_tests.exe --gtest_filter="LuaRunnerTest.MultiColumn*"` -- all 6 new tests pass.
  </verify>
  <done>6 multi-column time series Lua tests pass, covering: update+read, empty read, replace, clear, ordering, multi-row. All use mixed_time_series.sql schema with 4-column mixed types.</done>
</task>

<task type="auto">
  <name>Task 2: Add Lua composite read helper tests</name>
  <files>tests/test_lua_runner.cpp</files>
  <action>
Add tests for Lua composite read helpers. These helpers are already bound in `lua_runner.cpp` but have NO existing tests. Use the `collections.sql` schema (which the existing `LuaRunnerTest` fixture already loads as `collections_schema`).

**Tests to add:**

1. **ReadAllScalarsByIdFromLua** -- Create Config + Collection element with label, some_integer, some_float. Call `db:read_all_scalars_by_id("Collection", id)`. Assert returned table has correct keys and typed values: `scalars.label` is a string, `scalars.some_integer` is an integer, `scalars.some_float` is a number.

2. **ReadAllVectorsByIdFromLua** -- Create Config + Collection element, update vector with some values. Call `db:read_all_vectors_by_id("Collection", id)`. Assert returned table has the vector group as a key, with correct values.

3. **ReadAllSetsByIdFromLua** -- Create Config + Collection element, update set with some values. Call `db:read_all_sets_by_id("Collection", id)`. Assert returned table has the set group as a key, with correct values.

Use the same test fixture pattern as existing tests. Check which vector and set groups exist in `collections.sql` schema to use the correct attribute names.

**Pattern:**
```cpp
TEST_F(LuaRunnerTest, ReadAllScalarsByIdFromLua) {
    auto db = quiver::Database::from_schema(":memory:", collections_schema,
        {.read_only = 0, .console_level = QUIVER_LOG_OFF});
    // Create elements, populate data
    quiver::LuaRunner lua(db);
    lua.run(R"(
        local scalars = db:read_all_scalars_by_id("Collection", 1)
        assert(scalars.label == "Item 1", "Expected label")
        -- more assertions
    )");
}
```
  </action>
  <verify>
Build with `cmake --build build --config Debug` and run `./build/bin/quiver_tests.exe --gtest_filter="LuaRunnerTest.ReadAll*"` -- all 3 new tests pass.
  </verify>
  <done>3 composite read helper tests pass for Lua: read_all_scalars_by_id, read_all_vectors_by_id, read_all_sets_by_id.</done>
</task>

</tasks>

<verification>
- `cmake --build build --config Debug` builds successfully
- `./build/bin/quiver_tests.exe --gtest_filter="LuaRunnerTest.*"` -- all Lua tests pass (existing + 9 new)
- All new tests use the expected schemas (mixed_time_series.sql for time series, collections.sql for composite helpers)
- No changes to source code (lua_runner.cpp) -- tests verify existing bindings
</verification>

<success_criteria>
- 6 multi-column time series tests pass with mixed_time_series.sql schema
- 3 composite read helper tests pass
- All existing Lua tests continue to pass (no regression)
- Test assertions verify correct types per column (REAL, INTEGER, TEXT)
</success_criteria>

<output>
After completion, create `.planning/phases/14-verification-and-cleanup/14-01-SUMMARY.md`
</output>
