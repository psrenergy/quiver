---
phase: 03-language-bindings
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/julia/src/c_api.jl
  - bindings/julia/src/database_transaction.jl
  - bindings/julia/src/Quiver.jl
  - bindings/julia/test/test_database_transaction.jl
  - bindings/dart/lib/src/ffi/bindings.dart
  - bindings/dart/lib/src/database_transaction.dart
  - bindings/dart/lib/src/database.dart
  - bindings/dart/lib/quiver_db.dart
  - bindings/dart/test/database_transaction_test.dart
  - src/lua_runner.cpp
  - tests/test_lua_runner.cpp
  - CLAUDE.md
autonomous: true
requirements:
  - BIND-01
  - BIND-02
  - BIND-03
  - BIND-04
  - BIND-05
  - BIND-06
must_haves:
  truths:
    - "Julia users can call begin_transaction!, commit!, rollback! and in_transaction on a Database"
    - "Julia transaction(db) do db...end block auto-commits on success and re-raises on exception after rollback"
    - "Dart users can call db.beginTransaction(), db.commit(), db.rollback() and db.inTransaction()"
    - "Dart db.transaction((db) {...}) block auto-commits on success and rethrows on exception after rollback"
    - "Lua users can call db:begin_transaction(), db:commit(), db:rollback() and db:in_transaction()"
    - "Lua db:transaction(function(db)...end) block auto-commits on success and re-raises on error after rollback"
    - "Error messages from misuse propagate unchanged from C++ through each binding"
  artifacts:
    - path: "bindings/julia/src/database_transaction.jl"
      provides: "Julia transaction functions (begin_transaction!, commit!, rollback!, in_transaction, transaction)"
    - path: "bindings/julia/test/test_database_transaction.jl"
      provides: "Julia transaction test suite"
    - path: "bindings/dart/lib/src/database_transaction.dart"
      provides: "Dart DatabaseTransaction extension (beginTransaction, commit, rollback, inTransaction, transaction)"
    - path: "bindings/dart/test/database_transaction_test.dart"
      provides: "Dart transaction test suite"
    - path: "src/lua_runner.cpp"
      provides: "Lua transaction bindings (begin_transaction, commit, rollback, in_transaction, transaction)"
      contains: "begin_transaction"
    - path: "tests/test_lua_runner.cpp"
      provides: "Lua transaction test cases"
      contains: "TransactionCommit"
  key_links:
    - from: "bindings/julia/src/database_transaction.jl"
      to: "bindings/julia/src/c_api.jl"
      via: "C.quiver_database_begin_transaction ccall"
      pattern: "C\\.quiver_database_begin_transaction"
    - from: "bindings/dart/lib/src/database_transaction.dart"
      to: "bindings/dart/lib/src/ffi/bindings.dart"
      via: "bindings.quiver_database_begin_transaction FFI call"
      pattern: "bindings\\.quiver_database_begin_transaction"
    - from: "src/lua_runner.cpp"
      to: "include/quiver/database.h"
      via: "Direct C++ method call on Database&"
      pattern: "self\\.begin_transaction"
---

<objective>
Bind the four C API transaction functions (begin_transaction, commit, rollback, in_transaction) to Julia, Dart, and Lua, plus add a convenience `transaction` block wrapper in each language with auto commit on success and rollback on exception.

Purpose: Complete the language binding layer so Julia, Dart, and Lua users can control transactions idiomatically in their language, fulfilling Phase 3 of the Explicit Transactions roadmap.
Output: Transaction wrapper functions and convenience blocks in all three bindings, with comprehensive test suites verifying begin/commit/rollback, error propagation, multi-operation batches, and transaction block semantics.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-language-bindings/03-CONTEXT.md
@.planning/phases/03-language-bindings/03-RESEARCH.md
@.planning/phases/02-c-api-transaction-surface/02-01-SUMMARY.md

# Existing binding patterns (read these for reference):
@bindings/julia/src/database.jl
@bindings/julia/src/database_delete.jl
@bindings/julia/src/exceptions.jl
@bindings/julia/src/Quiver.jl
@bindings/julia/test/test_database_delete.jl
@bindings/dart/lib/src/database.dart
@bindings/dart/lib/src/database_delete.dart
@bindings/dart/lib/src/exceptions.dart
@bindings/dart/lib/quiver_db.dart
@bindings/dart/test/database_delete_test.dart
@src/lua_runner.cpp
@tests/test_lua_runner.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Julia FFI regeneration + transaction binding + tests</name>
  <files>
    bindings/julia/src/c_api.jl
    bindings/julia/src/database_transaction.jl
    bindings/julia/src/Quiver.jl
    bindings/julia/test/test_database_transaction.jl
  </files>
  <action>
**Step 1: Regenerate Julia FFI bindings.**
Run `bindings/julia/generator/generator.bat` to regenerate `bindings/julia/src/c_api.jl`. After regeneration, verify that `c_api.jl` contains declarations for all 4 new functions: `quiver_database_begin_transaction`, `quiver_database_commit`, `quiver_database_rollback`, `quiver_database_in_transaction`. The `in_transaction` function uses `bool*` out-param -- verify the generated type mapping uses `Ptr{Bool}` (not `Ptr{Cuchar}`). If the generator maps it incorrectly, manually fix just that declaration.

**Step 2: Create `bindings/julia/src/database_transaction.jl`** with these functions following the existing pattern in `database_delete.jl`:

- `begin_transaction!(db::Database)` -- calls `check(C.quiver_database_begin_transaction(db.ptr))`, returns nothing
- `commit!(db::Database)` -- calls `check(C.quiver_database_commit(db.ptr))`, returns nothing
- `rollback!(db::Database)` -- calls `check(C.quiver_database_rollback(db.ptr))`, returns nothing
- `in_transaction(db::Database)` -- uses `Ref{Bool}(false)` out-param, calls `check(C.quiver_database_in_transaction(db.ptr, out_active))`, returns `out_active[]`
- `transaction(fn, db::Database)` -- **CRITICAL: `fn` must be the FIRST parameter** for Julia's `do` block syntax to work (`transaction(db) do db ... end` desugars to `transaction(db -> ..., db)`). Implementation: calls `begin_transaction!(db)`, then `try result = fn(db); commit!(db); return result catch; try rollback!(db) catch end; rethrow() end`. Rollback failure is silently ignored (best-effort). Original exception re-raises unchanged.

**Step 3: Register the new file in `Quiver.jl`.** Add `include("database_transaction.jl")` after the `include("database_delete.jl")` line.

**Step 4: Create `bindings/julia/test/test_database_transaction.jl`** following the module/testset pattern in `test_database_delete.jl`. Use `tests/schemas/valid/collections.sql` schema. Tests must include:

1. **Begin, commit persists**: begin_transaction!, create element, commit!, verify element exists via read_scalar_strings
2. **Begin, rollback discards**: begin_transaction!, create element, rollback!, verify element does NOT exist
3. **Double begin error**: begin_transaction! twice, expect DatabaseException (do NOT assert exact message string)
4. **Commit without begin error**: commit! without begin, expect DatabaseException
5. **Rollback without begin error**: rollback! without begin, expect DatabaseException
6. **in_transaction state**: verify false before begin, true after begin, false after commit
7. **Transaction block auto-commits**: `result = transaction(db) do db; create_element!(...); 42; end`, verify result == 42, verify element persists
8. **Transaction block rollback on exception**: transaction block that throws after create, verify element does NOT persist, verify exception re-raises
9. **Multi-operation batch**: transaction block with multiple create_element! + update calls, verify all data persists after block completes

Each test must create its own `:memory:` database and close it at the end. Use `@test_throws DatabaseException` for error cases.

**Step 5: Run Julia tests.** Execute `bindings/julia/test/test.bat` and verify all tests pass including the new transaction tests. All existing tests must also pass (no regression).
  </action>
  <verify>
Run `bindings/julia/test/test.bat`. All tests pass, including new transaction tests. Verify `c_api.jl` contains the 4 transaction function declarations.
  </verify>
  <done>
Julia users can call `begin_transaction!`, `commit!`, `rollback!`, `in_transaction`, and use `transaction(db) do db...end` blocks. All 9 transaction test cases pass. All existing Julia tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dart FFI regeneration + transaction binding + tests</name>
  <files>
    bindings/dart/lib/src/ffi/bindings.dart
    bindings/dart/lib/src/database_transaction.dart
    bindings/dart/lib/src/database.dart
    bindings/dart/lib/quiver_db.dart
    bindings/dart/test/database_transaction_test.dart
  </files>
  <action>
**Step 1: Regenerate Dart FFI bindings.**
Run `bindings/dart/generator/generator.bat` to regenerate `bindings/dart/lib/src/ffi/bindings.dart`. After regeneration, verify that `bindings.dart` contains declarations for all 4 new functions. The `in_transaction` function uses `bool*` -- verify Dart maps this to `ffi.Bool` type (Dart 3.1+). If `.dart_tool/hooks_runner/` or `.dart_tool/lib/` exist from stale cache, clear them first (per CLAUDE.md Dart Notes).

**Step 2: Create `bindings/dart/lib/src/database_transaction.dart`** as a `part of 'database.dart'` extension, following the pattern in `database_delete.dart`:

```dart
part of 'database.dart';

/// Transaction control operations for Database.
extension DatabaseTransaction on Database {
  void beginTransaction() {
    _ensureNotClosed();
    check(bindings.quiver_database_begin_transaction(_ptr));
  }

  void commit() {
    _ensureNotClosed();
    check(bindings.quiver_database_commit(_ptr));
  }

  void rollback() {
    _ensureNotClosed();
    check(bindings.quiver_database_rollback(_ptr));
  }

  bool inTransaction() {
    _ensureNotClosed();
    final arena = Arena();
    try {
      final outActive = arena<Bool>();
      check(bindings.quiver_database_in_transaction(_ptr, outActive));
      return outActive.value;
    } finally {
      arena.releaseAll();
    }
  }

  T transaction<T>(T Function(Database) fn) {
    _ensureNotClosed();
    beginTransaction();
    try {
      final result = fn(this);
      commit();
      return result;
    } catch (e) {
      try {
        rollback();
      } catch (_) {
        // Best-effort rollback; ignore failure
      }
      rethrow;
    }
  }
}
```

Note: `beginTransaction`, `commit`, `rollback` do NOT need an Arena because they take no string parameters -- they only pass `_ptr` (a Pointer). Only `inTransaction` needs an Arena for the `Bool*` output parameter.

**Step 3: Register the new file.**
- Add `part 'database_transaction.dart';` in `bindings/dart/lib/src/database.dart` after the existing part declarations.
- Add `DatabaseTransaction` to the `show` list in `bindings/dart/lib/quiver_db.dart`.

**Step 4: Create `bindings/dart/test/database_transaction_test.dart`** following the pattern in `database_delete_test.dart`. Use `tests/schemas/valid/collections.sql` schema. Tests:

1. **Begin, commit persists**: beginTransaction, createElement, commit, verify via readScalarStrings
2. **Begin, rollback discards**: beginTransaction, createElement, rollback, verify element absent
3. **Double begin error**: beginTransaction twice, expect throws DatabaseException
4. **Commit without begin error**: commit without begin, expect throws DatabaseException
5. **Rollback without begin error**: rollback without begin, expect throws DatabaseException
6. **inTransaction state**: false before begin, true after begin, false after commit
7. **Transaction block auto-commits**: `final result = db.transaction((db) { db.createElement(...); return 42; })`, verify result == 42, verify element persists
8. **Transaction block rollback on exception**: transaction block that throws, verify element absent, verify exception propagates
9. **Multi-operation batch**: transaction block with multiple createElement + updateScalarInteger, verify all data persists

Each test uses try/finally with db.close(). Use `expect(() => ..., throwsA(isA<DatabaseException>()))` for error cases.

**Step 5: Run Dart tests.** Execute `bindings/dart/test/test.bat` and verify all tests pass. All existing tests must also pass.
  </action>
  <verify>
Run `bindings/dart/test/test.bat`. All tests pass, including new transaction tests. Verify `bindings.dart` contains the 4 transaction function declarations.
  </verify>
  <done>
Dart users can call `db.beginTransaction()`, `db.commit()`, `db.rollback()`, `db.inTransaction()`, and use `db.transaction((db) {...})` blocks. All 9 transaction test cases pass. All existing Dart tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 3: Lua transaction binding + tests + CLAUDE.md update</name>
  <files>
    src/lua_runner.cpp
    tests/test_lua_runner.cpp
    CLAUDE.md
  </files>
  <action>
**Step 1: Add Lua transaction bindings in `src/lua_runner.cpp`.**
In the `bind_database()` method, add transaction bindings inside the `lua.new_usertype<Database>(...)` call. Place them in a new Group comment block (e.g., "Group 10: Transactions") before the closing parenthesis of `new_usertype`. Add these 5 lambda bindings:

```cpp
// Group 10: Transactions
"begin_transaction",
[](Database& self) { self.begin_transaction(); },
"commit",
[](Database& self) { self.commit(); },
"rollback",
[](Database& self) { self.rollback(); },
"in_transaction",
[](Database& self) { return self.in_transaction(); },
"transaction",
[](Database& self, sol::protected_function fn) -> sol::object {
    self.begin_transaction();
    auto result = fn(std::ref(self));
    if (!result.valid()) {
        sol::error err = result;
        try { self.rollback(); } catch (...) {}
        throw std::runtime_error(err.what());
    }
    self.commit();
    if (result.return_count() > 0) {
        return result.get<sol::object>(0);
    }
    return sol::make_object(result.lua_state(), sol::lua_nil);
},
```

Key details:
- Use `sol::protected_function` (NOT `sol::function`) -- this gives pcall behavior so Lua errors are captured rather than thrown as C++ exceptions.
- The transaction wrapper: begin, call fn, if invalid rollback+throw, else commit. Extract return value from result.
- `std::ref(self)` passes the Database reference to the Lua function.
- On error: extract error message via `sol::error`, try rollback (best-effort, catch all), then `throw std::runtime_error(err.what())` which sol2 converts back to a Lua error. This re-raises the original message per user decision.
- Single return value only (no multi-return passthrough) per user decision.

**Step 2: Add Lua transaction test cases in `tests/test_lua_runner.cpp`.**
Add test cases to the existing LuaRunner test fixture. Follow the existing test naming pattern (e.g., `TEST_F(LuaRunnerTest, ...)`). Tests:

1. **TransactionCommit**: begin_transaction, create element, commit, read and verify via assert
2. **TransactionRollback**: begin_transaction, create element, rollback, verify element absent
3. **TransactionDoubleBeginError**: begin_transaction twice, expect Lua error (use EXPECT_THROW or check lua.run() throws)
4. **TransactionCommitWithoutBeginError**: commit without begin, expect error
5. **TransactionRollbackWithoutBeginError**: rollback without begin, expect error
6. **TransactionInTransaction**: check in_transaction returns false, begin, returns true, commit, returns false
7. **TransactionBlockAutoCommit**: `local result = db:transaction(function(db) db:create_element(...) return 42 end)`, assert result == 42, verify element persists
8. **TransactionBlockRollbackOnError**: transaction block with error(), verify element absent, verify error propagates
9. **TransactionBlockMultiOps**: transaction block with multiple creates, verify all persist

Use the existing test fixture's database setup pattern. Use `:memory:` databases with `collections.sql` schema. For error tests, use `EXPECT_THROW(lua.run(...), std::runtime_error)`.

**Step 3: Build and test.**
Build the project: `cmake --build build --config Debug`
Run C++ tests: `./build/bin/quiver_tests.exe` (includes LuaRunner tests)
Verify all tests pass including new transaction tests. All existing tests must pass unchanged.

**Step 4: Verify/update CLAUDE.md cross-layer table.**
Check the "Representative Cross-Layer Examples" table in CLAUDE.md. The table already has Transaction rows (begin_transaction, commit, rollback, in_transaction) from Phase 2 planning. Verify the entries are correct and match the actual implementation. If the `transaction` convenience wrapper needs a row, add it:

| Category | C++ | C API | Julia | Dart | Lua |
|----------|-----|-------|-------|------|-----|
| Transaction | N/A | N/A | `transaction(db) do db...end` | `db.transaction((db) {...})` | `db:transaction(function(db)...end)` |

Also verify that the "Binding-Only Convenience Methods" section mentions the transaction convenience wrappers if it has a table for such methods.
  </action>
  <verify>
Run `cmake --build build --config Debug && ./build/bin/quiver_tests.exe`. All C++ and LuaRunner tests pass, including 9 new transaction test cases. Verify CLAUDE.md has correct cross-layer entries.
  </verify>
  <done>
Lua users can call `db:begin_transaction()`, `db:commit()`, `db:rollback()`, `db:in_transaction()`, and use `db:transaction(function(db)...end)` blocks. All 9 Lua transaction test cases pass. All existing C++/Lua tests pass unchanged. CLAUDE.md cross-layer table is accurate.
  </done>
</task>

</tasks>

<verification>
After all three tasks complete:
1. Run `scripts/build-all.bat` to build everything and run all tests (C++ core, C API, Julia, Dart)
2. Verify zero test regressions across all test suites
3. Confirm each binding has: 4 raw transaction functions + 1 convenience transaction block
4. Confirm error messages from misuse (double begin, commit without begin) propagate from C++ unchanged -- bindings do not craft their own messages
5. Confirm transaction block return value passthrough works in all three bindings
6. Confirm rollback-on-exception re-raises the original exception unchanged in all three bindings
</verification>

<success_criteria>
- All 6 requirements (BIND-01 through BIND-06) satisfied
- Julia: begin_transaction!, commit!, rollback!, in_transaction, transaction(db) do...end all work
- Dart: beginTransaction(), commit(), rollback(), inTransaction(), transaction((db){...}) all work
- Lua: begin_transaction(), commit(), rollback(), in_transaction(), transaction(function(db)...end) all work
- 27 new transaction tests total (9 per binding) all pass
- Zero regressions in existing test suites
- CLAUDE.md cross-layer table updated
</success_criteria>

<output>
After completion, create `.planning/phases/03-language-bindings/03-01-SUMMARY.md`
</output>
