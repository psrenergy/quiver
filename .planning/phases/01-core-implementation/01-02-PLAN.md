---
phase: 01-core-implementation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bindings/dart/lib/src/database_read.dart
  - bindings/dart/test/database_read_test.dart
  - bindings/python/src/quiverdb/database.py
  - bindings/python/tests/test_database_read_element.py
autonomous: true
requirements: [READ-01, READ-02]

must_haves:
  truths:
    - "Dart caller can call db.readElementById('Collection', id) and receive a flat Map<String, Object?> with all scalar, vector column, and set column values as top-level keys"
    - "Python caller can call db.read_element_by_id('Collection', id) and receive a flat dict with all scalar, vector column, and set column values as top-level keys"
    - "Nonexistent element ID returns empty map/dict in both Dart and Python"
    - "Multi-column vectors have each column as a separate top-level key (not nested under group name)"
    - "Empty vector/set groups produce empty lists in the result"
    - "id is excluded from the result; label is included as a regular scalar"
  artifacts:
    - path: "bindings/dart/lib/src/database_read.dart"
      provides: "readElementById Dart method"
      contains: "readElementById"
    - path: "bindings/python/src/quiverdb/database.py"
      provides: "read_element_by_id Python method"
      contains: "def read_element_by_id"
  key_links:
    - from: "bindings/dart/lib/src/database_read.dart"
      to: "listScalarAttributes, listVectorGroups, listSetGroups"
      via: "metadata queries to discover attributes then typed by-id reads"
      pattern: "readElementById"
    - from: "bindings/python/src/quiverdb/database.py"
      to: "list_scalar_attributes, list_vector_groups, list_set_groups"
      via: "metadata queries to discover attributes then typed by-id reads"
      pattern: "read_element_by_id"
---

<objective>
Implement `read_element_by_id` as a binding-level composition function in Dart and Python.

Purpose: Per user decision (01-CONTEXT.md), `read_element_by_id` is implemented at the binding level by composing existing C API calls -- no new C++/C API types needed. This plan covers the Dart and Python implementations with tests.

Output: Working `readElementById` in Dart and `read_element_by_id` in Python, tested against `collections.sql` and `all_types.sql` schemas.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-implementation/01-CONTEXT.md

# Implementation reference (existing composite helpers to follow as pattern)
@bindings/dart/lib/src/database_read.dart
@bindings/python/src/quiverdb/database.py

# Test schemas
@tests/schemas/valid/collections.sql
@tests/schemas/valid/all_types.sql

<interfaces>
<!-- Existing composite helpers that read_element_by_id composes and supersedes -->

From bindings/dart/lib/src/database_read.dart (Dart patterns):
```dart
// Existing helpers -- readElementById merges all three into one flat Map
Map<String, Object?> readAllScalarsById(String collection, int id);
Map<String, List<Object>> readAllVectorsById(String collection, int id);
Map<String, List<Object>> readAllSetsById(String collection, int id);

// Dart also has DateTime convenience:
DateTime? readScalarDateTimeById(String collection, String attribute, int id);
List<DateTime> readVectorDateTimesById(String collection, String attribute, int id);
List<DateTime> readSetDateTimesById(String collection, String attribute, int id);

// Metadata used to discover attributes:
// listScalarAttributes(collection) -> List<ScalarMetadata>
// listVectorGroups(collection) -> List<GroupMetadata>
// listSetGroups(collection) -> List<GroupMetadata>

// Data type enum: quiver_data_type_t.QUIVER_DATA_TYPE_INTEGER/FLOAT/STRING/DATE_TIME
// _getValueDataType(valueColumns) helper already exists
```

From bindings/python/src/quiverdb/database.py (Python patterns):
```python
# Existing helpers -- read_element_by_id merges all three into one flat dict
def read_all_scalars_by_id(self, collection: str, id: int) -> dict
def read_all_vectors_by_id(self, collection: str, id: int) -> dict
def read_all_sets_by_id(self, collection: str, id: int) -> dict

# Python also has DateTime convenience:
def read_scalar_date_time_by_id(self, collection, attribute, id) -> datetime | None
def read_vector_date_time_by_id(self, collection, attribute, id) -> list[datetime]
def read_set_date_time_by_id(self, collection, attribute, id) -> list[datetime]

# Metadata:
# self.list_scalar_attributes(collection) -> list[ScalarMetadata]
# self.list_vector_groups(collection) -> list[GroupMetadata]
# self.list_set_groups(collection) -> list[GroupMetadata]
# ScalarMetadata.data_type: 0=INTEGER, 1=FLOAT, 2=STRING, 3=DATE_TIME
# GroupMetadata.value_columns: list[ScalarMetadata]
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement readElementById in Dart binding and add tests</name>
  <files>bindings/dart/lib/src/database_read.dart, bindings/dart/test/database_read_test.dart</files>
  <action>
**In `bindings/dart/lib/src/database_read.dart`:**

Add `readElementById` after the existing `readAllSetsById` method (around line 861). Follow the exact pattern of existing composite helpers but produce a FLAT Map:

```dart
/// Reads all scalar, vector, and set attribute values for an element by ID.
/// Returns a flat map with attribute/column names as keys.
/// Multi-column vector/set groups have each column as a separate top-level key.
/// DateTime columns are converted to DateTime objects.
/// Returns an empty map if the element does not exist.
/// The `id` field is excluded (caller already knows it).
Map<String, Object?> readElementById(String collection, int id) {
  _ensureNotClosed();

  final result = <String, Object?>{};

  // 1. Scalars (skip "id" -- caller already knows it)
  for (final attribute in listScalarAttributes(collection)) {
    final name = attribute.name;
    if (name == 'id') continue;
    switch (attribute.dataType) {
      case quiver_data_type_t.QUIVER_DATA_TYPE_INTEGER:
        result[name] = readScalarIntegerById(collection, name, id);
      case quiver_data_type_t.QUIVER_DATA_TYPE_FLOAT:
        result[name] = readScalarFloatById(collection, name, id);
      case quiver_data_type_t.QUIVER_DATA_TYPE_STRING:
        result[name] = readScalarStringById(collection, name, id);
      case quiver_data_type_t.QUIVER_DATA_TYPE_DATE_TIME:
        result[name] = readScalarDateTimeById(collection, name, id);
    }
  }

  // Early exit for nonexistent element (label is NOT NULL, null means no row)
  if (result.containsKey('label') && result['label'] == null) {
    return {};
  }

  // 2. Vectors -- each column is a separate top-level key
  for (final group in listVectorGroups(collection)) {
    for (final col in group.valueColumns) {
      final name = col.name;
      switch (col.dataType) {
        case quiver_data_type_t.QUIVER_DATA_TYPE_INTEGER:
          result[name] = readVectorIntegersById(collection, name, id);
        case quiver_data_type_t.QUIVER_DATA_TYPE_FLOAT:
          result[name] = readVectorFloatsById(collection, name, id);
        case quiver_data_type_t.QUIVER_DATA_TYPE_STRING:
          result[name] = readVectorStringsById(collection, name, id);
        case quiver_data_type_t.QUIVER_DATA_TYPE_DATE_TIME:
          result[name] = readVectorDateTimesById(collection, name, id);
      }
    }
  }

  // 3. Sets -- each column is a separate top-level key
  for (final group in listSetGroups(collection)) {
    for (final col in group.valueColumns) {
      final name = col.name;
      switch (col.dataType) {
        case quiver_data_type_t.QUIVER_DATA_TYPE_INTEGER:
          result[name] = readSetIntegersById(collection, name, id);
        case quiver_data_type_t.QUIVER_DATA_TYPE_FLOAT:
          result[name] = readSetFloatsById(collection, name, id);
        case quiver_data_type_t.QUIVER_DATA_TYPE_STRING:
          result[name] = readSetStringsById(collection, name, id);
        case quiver_data_type_t.QUIVER_DATA_TYPE_DATE_TIME:
          result[name] = readSetDateTimesById(collection, name, id);
      }
    }
  }

  return result;
}
```

**Key decisions per CONTEXT.md (Dart naming: `readElementById`):**
- `id` excluded, `label` included
- DATE_TIME: use `readScalarDateTimeById` etc. for native Dart DateTime
- NULL scalars: `null` in the map
- Nonexistent ID: check `label == null` after scalars, return empty `{}`
- Multi-column vectors/sets: each column is its own key
- Enum FK: raw integer values

**In `bindings/dart/test/database_read_test.dart`:**

Add a new `group('Read Element By ID', ...)` block. Add near the end of the file but before the closing of any outer group. Follow existing Dart test patterns with `try/finally` for cleanup:

Test 1: Element with all categories -- Use `collections.sql`. Create Configuration first (required FK), then Collection element with scalars + vector data + set data. Call `readElementById`. Verify:
- `result['label']` == expected label
- `result['some_integer']` == expected integer
- `result['some_float']` == expected float
- `result['value_int']` is a List of integers (vector column)
- `result['value_float']` is a List of floats (vector column)
- `result['tag']` is a List of strings (set column)
- `result.containsKey('id')` is false
- No group-name keys like `values` or `tags`

Test 2: Nonexistent element ID -- Use `collections.sql`. Verify `readElementById(collection, 9999)` returns empty map.

Test 3: Scalars only -- Use `basic.sql`. Create Configuration, read back. Verify only scalar keys present.
  </action>
  <verify>
    <automated>bindings/dart/test/test.bat</automated>
  </verify>
  <done>Dart `db.readElementById("Collection", id)` returns a flat Map with all scalar values (including native DateTime), vector column lists, and set column lists as top-level keys. `id` excluded, `label` included. Empty map for nonexistent IDs. Three passing Dart tests confirm behavior.</done>
</task>

<task type="auto">
  <name>Task 2: Implement read_element_by_id in Python binding and add tests</name>
  <files>bindings/python/src/quiverdb/database.py, bindings/python/tests/test_database_read_element.py</files>
  <action>
**In `bindings/python/src/quiverdb/database.py`:**

Add `read_element_by_id` in the "Convenience helpers" section, after the existing `read_all_sets_by_id` method (around line 1325). Follow the exact pattern of existing composite helpers but produce a FLAT dict:

```python
def read_element_by_id(self, collection: str, id: int) -> dict:
    """Read all scalar, vector, and set values for an element by ID.

    Returns a flat dict with attribute/column names as keys.
    Multi-column vector/set groups have each column as a separate top-level key.
    DATE_TIME attributes are parsed to datetime objects.
    Returns an empty dict if the element does not exist.
    The 'id' field is excluded (caller already knows it).
    """
    self._ensure_open()
    result = {}

    # 1. Scalars (skip "id" -- caller already knows it)
    for attr in self.list_scalar_attributes(collection):
        name = attr.name
        if name == "id":
            continue
        if attr.data_type == 0:  # INTEGER
            result[name] = self.read_scalar_integer_by_id(collection, name, id)
        elif attr.data_type == 1:  # FLOAT
            result[name] = self.read_scalar_float_by_id(collection, name, id)
        elif attr.data_type == 3:  # DATE_TIME
            result[name] = self.read_scalar_date_time_by_id(collection, name, id)
        else:  # STRING (2)
            result[name] = self.read_scalar_string_by_id(collection, name, id)

    # Early exit for nonexistent element (label is NOT NULL, None means no row)
    if "label" in result and result["label"] is None:
        return {}

    # 2. Vectors -- each column is a separate top-level key
    for group in self.list_vector_groups(collection):
        for col in group.value_columns:
            name = col.name
            dt = col.data_type
            if dt == 0:  # INTEGER
                result[name] = self.read_vector_integers_by_id(collection, name, id)
            elif dt == 1:  # FLOAT
                result[name] = self.read_vector_floats_by_id(collection, name, id)
            elif dt == 3:  # DATE_TIME
                result[name] = self.read_vector_date_time_by_id(collection, name, id)
            else:  # STRING (2)
                result[name] = self.read_vector_strings_by_id(collection, name, id)

    # 3. Sets -- each column is a separate top-level key
    for group in self.list_set_groups(collection):
        for col in group.value_columns:
            name = col.name
            dt = col.data_type
            if dt == 0:  # INTEGER
                result[name] = self.read_set_integers_by_id(collection, name, id)
            elif dt == 1:  # FLOAT
                result[name] = self.read_set_floats_by_id(collection, name, id)
            elif dt == 3:  # DATE_TIME
                result[name] = self.read_set_date_time_by_id(collection, name, id)
            else:  # STRING (2)
                result[name] = self.read_set_strings_by_id(collection, name, id)

    return result
```

**Key decisions per CONTEXT.md (Python naming: `read_element_by_id`):**
- `id` excluded, `label` included
- DATE_TIME: use `read_scalar_date_time_by_id` etc. for native Python `datetime`
- NULL scalars: `None` in the dict
- Nonexistent ID: check `label is None` after scalars, return empty `{}`
- Multi-column vectors/sets: each column is its own key
- Enum FK: raw integer values
- Note: This is a regular method, NOT `@property` (per project conventions)

**Create `bindings/python/tests/test_database_read_element.py`:**

Create a new test file (following the existing pattern from `test_database_read_scalar.py` etc.). Use pytest fixtures from `conftest.py`:

```python
"""Tests for read_element_by_id convenience method."""
from __future__ import annotations

import pytest

from quiverdb import Database, Element


class TestReadElementById:
    """Tests for Database.read_element_by_id."""

    def test_read_element_with_all_categories(self, collections_db: Database) -> None:
        """Element with scalars, multi-column vectors, and sets."""
        # Create prerequisite Configuration
        collections_db.create_element("Configuration", label="cfg")
        # Create Collection element with all data types
        elem_id = collections_db.create_element(
            "Collection",
            label="Item1",
            some_integer=42,
            some_float=3.14,
            value_int=[10, 20, 30],
            value_float=[1.1, 2.2, 3.3],
            tag=["alpha", "beta"],
        )

        result = collections_db.read_element_by_id("Collection", elem_id)

        # Scalars
        assert result["label"] == "Item1"
        assert result["some_integer"] == 42
        assert result["some_float"] == pytest.approx(3.14)

        # Vector columns (flat, not nested under group name)
        assert result["value_int"] == [10, 20, 30]
        assert result["value_float"] == pytest.approx([1.1, 2.2, 3.3])

        # Set column
        assert sorted(result["tag"]) == ["alpha", "beta"]

        # id is excluded
        assert "id" not in result

    def test_nonexistent_element_returns_empty_dict(self, collections_db: Database) -> None:
        """Nonexistent ID returns empty dict, no error."""
        collections_db.create_element("Configuration", label="cfg")
        result = collections_db.read_element_by_id("Collection", 9999)
        assert result == {}

    def test_scalars_only_no_vectors_or_sets(self, db: Database) -> None:
        """Schema with only scalar attributes (basic.sql Configuration)."""
        db.create_element("Configuration", label="Config1", integer_attribute=7)
        result = db.read_element_by_id("Configuration", 1)

        assert result["label"] == "Config1"
        assert result["integer_attribute"] == 7
        assert "id" not in result
```

Note: Use `collections_db` fixture for tests needing vectors/sets. Use `db` fixture (which uses `basic.sql`) for the scalars-only test. Both fixtures are defined in `conftest.py`.
  </action>
  <verify>
    <automated>bindings/python/test/test.bat</automated>
  </verify>
  <done>Python `db.read_element_by_id("Collection", id)` returns a flat dict with all scalar values (including native datetime for DATE_TIME), vector column lists, and set column lists as top-level keys. `id` excluded, `label` included. Empty dict for nonexistent IDs. Dart `db.readElementById` has same behavior. Three passing tests each in Dart and Python confirm behavior.</done>
</task>

</tasks>

<verification>
1. Run Dart tests: `bindings/dart/test/test.bat`
2. Run Python tests: `bindings/python/test/test.bat`
3. Verify no regressions: both test suites should pass all existing tests plus the new ones
</verification>

<success_criteria>
- Dart: `db.readElementById("Collection", id)` returns flat Map with scalar, vector column, and set column values as top-level keys
- Python: `db.read_element_by_id("Collection", id)` returns flat dict with same structure
- Both handle nonexistent IDs by returning empty map/dict
- Both exclude `id` from result and include `label`
- Multi-column vector/set groups have each column as separate top-level key
- All new and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-implementation/01-02-SUMMARY.md`
</output>
