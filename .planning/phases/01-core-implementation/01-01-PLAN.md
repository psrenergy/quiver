---
phase: 01-core-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lua_runner.cpp
  - tests/test_lua_runner.cpp
  - bindings/julia/src/database_read.jl
  - bindings/julia/test/test_database_read.jl
autonomous: true
requirements: [READ-01, READ-02]

must_haves:
  truths:
    - "Lua caller can call db:read_element_by_id('Collection', id) and receive a flat table with all scalar, vector column, and set column values as top-level keys"
    - "Julia caller can call read_element_by_id(db, 'Collection', id) and receive a flat Dict{String,Any} with all scalar, vector column, and set column values as top-level keys"
    - "Nonexistent element ID returns empty table/dict in both Lua and Julia"
    - "Multi-column vectors have each column as a separate top-level key (not nested under group name)"
    - "Empty vector/set groups produce empty arrays in the result"
    - "id is excluded from the result; label is included as a regular scalar"
  artifacts:
    - path: "src/lua_runner.cpp"
      provides: "read_element_by_id Lua binding"
      contains: "read_element_by_id"
    - path: "bindings/julia/src/database_read.jl"
      provides: "read_element_by_id Julia function"
      contains: "function read_element_by_id"
  key_links:
    - from: "src/lua_runner.cpp"
      to: "Database::list_scalar_attributes, list_vector_groups, list_set_groups"
      via: "metadata queries to discover attributes then typed by-id reads"
      pattern: "read_element_by_id"
    - from: "bindings/julia/src/database_read.jl"
      to: "list_scalar_attributes, list_vector_groups, list_set_groups"
      via: "metadata queries to discover attributes then typed by-id reads"
      pattern: "read_element_by_id"
---

<objective>
Implement `read_element_by_id` as a binding-level composition function in Lua and Julia.

Purpose: Per user decision (01-CONTEXT.md), `read_element_by_id` is implemented at the binding level by composing existing C API calls -- no new C++/C API types needed. This plan covers the Lua (C++ hosted) and Julia implementations with tests.

Output: Working `read_element_by_id` in Lua and Julia bindings, tested against `collections.sql` and `all_types.sql` schemas.
</objective>

<execution_context>
@C:/Users/rsampaio/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rsampaio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-implementation/01-CONTEXT.md

# Implementation reference (existing composite helpers to follow as pattern)
@src/lua_runner.cpp
@bindings/julia/src/database_read.jl

# Test schemas
@tests/schemas/valid/collections.sql
@tests/schemas/valid/all_types.sql

<interfaces>
<!-- Existing composite helpers that read_element_by_id composes and supersedes -->

From src/lua_runner.cpp (Lua binding patterns):
```cpp
// Existing helpers -- read_element_by_id merges all three into one flat table
static sol::table read_all_scalars_by_id_lua(Database& db, const std::string& collection, int64_t id, sol::this_state s);
static sol::table read_all_vectors_by_id_lua(Database& db, const std::string& collection, int64_t id, sol::this_state s);
static sol::table read_all_sets_by_id_lua(Database& db, const std::string& collection, int64_t id, sol::this_state s);

// Metadata used to discover attributes:
// db.list_scalar_attributes(collection) -> vector<ScalarMetadata>  (name, data_type)
// db.list_vector_groups(collection) -> vector<GroupMetadata>  (group_name, value_columns[])
// db.list_set_groups(collection) -> vector<GroupMetadata>  (group_name, value_columns[])

// Typed by-id reads used for each attribute:
// db.read_scalar_integer_by_id(collection, name, id) -> optional<int64_t>
// db.read_scalar_float_by_id(collection, name, id) -> optional<double>
// db.read_scalar_string_by_id(collection, name, id) -> optional<string>
// db.read_vector_integers_by_id(collection, name, id) -> vector<int64_t>
// db.read_vector_floats_by_id(collection, name, id) -> vector<double>
// db.read_vector_strings_by_id(collection, name, id) -> vector<string>
// db.read_set_integers_by_id(collection, name, id) -> vector<int64_t>
// db.read_set_floats_by_id(collection, name, id) -> vector<double>
// db.read_set_strings_by_id(collection, name, id) -> vector<string>
```

From bindings/julia/src/database_read.jl (Julia patterns):
```julia
# Existing helpers -- read_element_by_id merges all three into one flat Dict
function read_all_scalars_by_id(db, collection, id) -> Dict{String,Any}
function read_all_vectors_by_id(db, collection, id) -> Dict{String,Vector{Any}}
function read_all_sets_by_id(db, collection, id) -> Dict{String,Vector{Any}}

# Julia also has DATE_TIME convenience:
function read_scalar_date_time_by_id(db, collection, attribute, id)
function read_vector_date_time_by_id(db, collection, attribute, id)
function read_set_date_time_by_id(db, collection, attribute, id)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement read_element_by_id in Lua binding and add tests</name>
  <files>src/lua_runner.cpp, tests/test_lua_runner.cpp</files>
  <action>
**In `src/lua_runner.cpp`:**

1. Add a new static method `read_element_by_id_lua` near the existing `read_all_scalars_by_id_lua` function (around line 708). Follow the exact same pattern but produce a FLAT table merging all categories:

```cpp
static sol::table
read_element_by_id_lua(Database& db, const std::string& collection, int64_t id, sol::this_state s) {
    sol::state_view lua(s);
    auto result = lua.create_table();

    // 1. Scalars (same as read_all_scalars_by_id_lua but exclude "id" key)
    for (const auto& attribute : db.list_scalar_attributes(collection)) {
        if (attribute.name == "id") continue;  // caller already knows id
        switch (attribute.data_type) {
        case DataType::Integer: {
            auto val = db.read_scalar_integer_by_id(collection, attribute.name, id);
            result[attribute.name] = val.has_value() ? sol::make_object(lua, *val) : sol::lua_nil;
            break;
        }
        case DataType::Real: {
            auto val = db.read_scalar_float_by_id(collection, attribute.name, id);
            result[attribute.name] = val.has_value() ? sol::make_object(lua, *val) : sol::lua_nil;
            break;
        }
        case DataType::Text:
        case DataType::DateTime: {
            auto val = db.read_scalar_string_by_id(collection, attribute.name, id);
            result[attribute.name] = val.has_value() ? sol::make_object(lua, *val) : sol::lua_nil;
            break;
        }
        }
    }

    // 2. Vectors -- each column is a separate top-level key
    for (const auto& group : db.list_vector_groups(collection)) {
        for (const auto& col : group.value_columns) {
            auto vec = lua.create_table();
            switch (col.data_type) {
            case DataType::Integer: {
                auto values = db.read_vector_integers_by_id(collection, col.name, id);
                for (size_t i = 0; i < values.size(); ++i) vec[i + 1] = values[i];
                break;
            }
            case DataType::Real: {
                auto values = db.read_vector_floats_by_id(collection, col.name, id);
                for (size_t i = 0; i < values.size(); ++i) vec[i + 1] = values[i];
                break;
            }
            case DataType::Text:
            case DataType::DateTime: {
                auto values = db.read_vector_strings_by_id(collection, col.name, id);
                for (size_t i = 0; i < values.size(); ++i) vec[i + 1] = values[i];
                break;
            }
            }
            result[col.name] = vec;
        }
    }

    // 3. Sets -- each column is a separate top-level key
    for (const auto& group : db.list_set_groups(collection)) {
        for (const auto& col : group.value_columns) {
            auto set = lua.create_table();
            switch (col.data_type) {
            case DataType::Integer: {
                auto values = db.read_set_integers_by_id(collection, col.name, id);
                for (size_t i = 0; i < values.size(); ++i) set[i + 1] = values[i];
                break;
            }
            case DataType::Real: {
                auto values = db.read_set_floats_by_id(collection, col.name, id);
                for (size_t i = 0; i < values.size(); ++i) set[i + 1] = values[i];
                break;
            }
            case DataType::Text:
            case DataType::DateTime: {
                auto values = db.read_set_strings_by_id(collection, col.name, id);
                for (size_t i = 0; i < values.size(); ++i) set[i + 1] = values[i];
                break;
            }
            }
            result[col.name] = set;
        }
    }

    return result;
}
```

2. Register the function in `bind_database()` (near line 163, after `read_all_sets_by_id`):
```cpp
bind.set_function("read_element_by_id", &read_element_by_id_lua);
```

**Key decisions per CONTEXT.md:**
- `id` is excluded (caller already knows it)
- `label` is included as a regular scalar
- DATE_TIME columns: return raw strings (Lua has no native DateTime)
- NULL scalars: set `sol::lua_nil`
- Nonexistent ID: returns empty table (no validation, scalar reads return nil which we still set, vector/set reads return empty arrays)
- Enum FK columns: return raw integer FK values (existing typed reads handle this)
- Multi-column vectors/sets: each column is its own top-level key, NOT nested under group name

**Note on nonexistent ID behavior:** When the ID does not exist, `list_scalar_attributes` still returns all attributes (it's schema-based, not data-based). Each `read_scalar_*_by_id` will return `nullopt`/nil. Vector/set reads will return empty arrays. So the result will be a table with all schema keys present but nil scalar values and empty array values. Per CONTEXT.md "Nonexistent element ID: return empty dict", we should return an empty table instead. Add a check: after building the scalar portion, if ALL scalar values are nil (or even simpler: check if the element exists by checking if `label` is nil after reading it), return an empty table immediately.

Actually, re-reading CONTEXT.md more carefully: "return empty dict (no validation query, no error)". The simplest approach consistent with "no validation query" is: read scalars first. If the label (which is NOT NULL in the schema) comes back as nil/nothing, the element does not exist -- return empty table immediately without reading vectors/sets. This avoids an extra query while still producing an empty dict for nonexistent IDs.

Implement this: after the scalar loop, check if the result table is empty or if `result["label"]` is nil. If so, return an empty table.

**In `tests/test_lua_runner.cpp`:**

Add tests in a new section near the existing `read_all_scalars_by_id` tests (around line 1713). Use `collections.sql` schema for multi-column vectors and `all_types.sql` for multiple vector/set type coverage:

Test 1: `ReadElementById_WithAllCategories` -- Use `collections.sql`. Create an element with scalars, multi-column vector data, and set data. Call `read_element_by_id`. Verify:
- `label` is present and correct
- `some_integer` and `some_float` are present and correct
- `value_int` and `value_float` (vector columns) are present as separate top-level arrays
- `tag` (set column) is present as a top-level array
- `id` is NOT present in the result
- No keys like `values` or `tags` (group names) -- only column names

Test 2: `ReadElementById_NonexistentId` -- Use `collections.sql`. Call `read_element_by_id` with ID 9999. Verify result is an empty table.

Test 3: `ReadElementById_ScalarsOnly` -- Use `basic.sql` (which has no vectors/sets). Create a Configuration element. Verify only scalar keys are returned, no vector/set keys.
  </action>
  <verify>
    <automated>cmake --build build --config Debug --target quiver_tests && ./build/bin/quiver_tests.exe --gtest_filter="*ReadElementById*"</automated>
  </verify>
  <done>Lua `db:read_element_by_id("Collection", id)` returns a flat table with all scalar values, vector column arrays, and set column arrays as top-level keys. `id` excluded, `label` included. Empty table returned for nonexistent IDs. Three passing Lua tests confirm behavior.</done>
</task>

<task type="auto">
  <name>Task 2: Implement read_element_by_id in Julia binding and add tests</name>
  <files>bindings/julia/src/database_read.jl, bindings/julia/test/test_database_read.jl</files>
  <action>
**In `bindings/julia/src/database_read.jl`:**

Add `read_element_by_id` after the existing `read_all_sets_by_id` function (around line 436). Follow the exact pattern of the existing composite helpers but produce a FLAT Dict:

```julia
function read_element_by_id(db::Database, collection::String, id::Int64)
    result = Dict{String, Any}()

    # 1. Scalars (skip "id" key -- caller already knows it)
    for attribute in list_scalar_attributes(db, collection)
        name = attribute.name
        if name == "id"
            continue
        end
        if attribute.data_type == C.QUIVER_DATA_TYPE_INTEGER
            result[name] = read_scalar_integer_by_id(db, collection, name, id)
        elseif attribute.data_type == C.QUIVER_DATA_TYPE_FLOAT
            result[name] = read_scalar_float_by_id(db, collection, name, id)
        elseif attribute.data_type == C.QUIVER_DATA_TYPE_DATE_TIME
            result[name] = read_scalar_date_time_by_id(db, collection, name, id)
        else
            result[name] = read_scalar_string_by_id(db, collection, name, id)
        end
    end

    # Early exit for nonexistent element (label is NOT NULL, so nothing means no row)
    if haskey(result, "label") && result["label"] === nothing
        return Dict{String, Any}()
    end

    # 2. Vectors -- each column is a separate top-level key
    for group in list_vector_groups(db, collection)
        for col in group.value_columns
            name = col.name
            if col.data_type == C.QUIVER_DATA_TYPE_INTEGER
                result[name] = read_vector_integers_by_id(db, collection, name, id)
            elseif col.data_type == C.QUIVER_DATA_TYPE_FLOAT
                result[name] = read_vector_floats_by_id(db, collection, name, id)
            elseif col.data_type == C.QUIVER_DATA_TYPE_DATE_TIME
                result[name] = read_vector_date_time_by_id(db, collection, name, id)
            else
                result[name] = read_vector_strings_by_id(db, collection, name, id)
            end
        end
    end

    # 3. Sets -- each column is a separate top-level key
    for group in list_set_groups(db, collection)
        for col in group.value_columns
            name = col.name
            if col.data_type == C.QUIVER_DATA_TYPE_INTEGER
                result[name] = read_set_integers_by_id(db, collection, name, id)
            elseif col.data_type == C.QUIVER_DATA_TYPE_FLOAT
                result[name] = read_set_floats_by_id(db, collection, name, id)
            elseif col.data_type == C.QUIVER_DATA_TYPE_DATE_TIME
                result[name] = read_set_date_time_by_id(db, collection, name, id)
            else
                result[name] = read_set_strings_by_id(db, collection, name, id)
            end
        end
    end

    return result
end
```

**Key decisions per CONTEXT.md:**
- `id` is excluded, `label` included as regular scalar
- DATE_TIME columns: use `read_scalar_date_time_by_id` etc. to return native DateTime objects (Julia convention)
- NULL scalars: include key with `nothing` value
- Nonexistent ID: check if `label` is `nothing` after scalar reads, return empty Dict
- Multi-column vectors/sets: each column is its own top-level key
- Enum FK columns: raw integer FK values (existing behavior)
- This is NOT a mutating function, so no `!` suffix (it only reads)

**In `bindings/julia/test/test_database_read.jl`:**

Add a new `@testset "Read Element By ID"` block. Locate the existing test structure and add near the end of the file. Tests should follow existing patterns in this file:

Test 1: Element with all categories -- Use `collections.sql`. Create Configuration + Collection element with scalars, vector data, set data. Call `read_element_by_id`. Verify:
- `result["label"]` == expected label string
- `result["some_integer"]` == expected integer
- `result["some_float"]` == expected float
- `result["value_int"]` is an array of integers (vector column, not nested under group)
- `result["value_float"]` is an array of floats (vector column, not nested under group)
- `result["tag"]` is an array of strings (set column)
- `haskey(result, "id")` is false

Test 2: Nonexistent element ID -- Use `collections.sql`. Call `read_element_by_id(db, "Collection", Int64(9999))`. Verify `isempty(result)`.

Test 3: Scalars only -- Use `basic.sql` (Configuration has no vectors/sets). Create element, read back, verify only scalar keys present.
  </action>
  <verify>
    <automated>bindings/julia/test/test.bat</automated>
  </verify>
  <done>Julia `read_element_by_id(db, "Collection", id)` returns a flat Dict{String,Any} with all scalar values (including native DateTime for DATE_TIME columns), vector column arrays, and set column arrays as top-level keys. `id` excluded, `label` included. Empty Dict for nonexistent IDs. Three passing Julia tests confirm behavior.</done>
</task>

</tasks>

<verification>
1. Build C++ and run Lua tests: `cmake --build build --config Debug --target quiver_tests && ./build/bin/quiver_tests.exe --gtest_filter="*ReadElementById*"`
2. Run Julia tests: `bindings/julia/test/test.bat`
3. Verify no regressions in existing tests: `./build/bin/quiver_tests.exe` and `bindings/julia/test/test.bat` should pass all existing tests
</verification>

<success_criteria>
- Lua: `db:read_element_by_id("Collection", id)` returns flat table with scalar, vector column, and set column values as top-level keys
- Julia: `read_element_by_id(db, "Collection", id)` returns flat Dict with same structure
- Both handle nonexistent IDs by returning empty table/dict
- Both exclude `id` from result and include `label`
- Multi-column vector/set groups have each column as separate top-level key
- All new and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-implementation/01-01-SUMMARY.md`
</output>
