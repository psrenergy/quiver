---
phase: 03-cpp-naming-error-standardization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/database_impl.h
  - src/database.cpp
  - src/database_create.cpp
  - src/database_read.cpp
  - src/database_update.cpp
  - src/database_delete.cpp
  - src/database_metadata.cpp
  - src/database_time_series.cpp
  - src/database_relations.cpp
  - src/database_internal.h
  - CLAUDE.md
autonomous: true

must_haves:
  truths:
    - "All exceptions use std::runtime_error with one of exactly 3 message patterns"
    - "Precondition failures use 'Cannot {operation}: {reason}' format"
    - "Not-found errors use '{Entity} not found: {identifier}' format"
    - "Operation failures use 'Failed to {operation}: {reason}' format"
    - "All read/update operations validate collection existence via require_collection"
    - "All C++ tests pass after error message standardization"
  artifacts:
    - path: "src/database_impl.h"
      provides: "Standardized require_collection error message"
      contains: "Cannot.*collection not found"
    - path: "src/database_read.cpp"
      provides: "require_collection calls for vector/set reads"
      contains: "require_collection"
    - path: "CLAUDE.md"
      provides: "Documented naming convention and error message patterns"
      contains: "verb_.*category.*type"
  key_links:
    - from: "src/database_impl.h"
      to: "src/database_read.cpp"
      via: "require_collection called by all read operations"
      pattern: "impl_->require_collection"
    - from: "src/database_impl.h"
      to: "src/database_update.cpp"
      via: "require_collection called by all update operations"
      pattern: "impl_->require_collection"
---

<objective>
Standardize all ~65 exception throw sites across the C++ source to use exactly 3 message patterns. Add missing `require_collection` validation to vector/set read operations. Update CLAUDE.md with the documented naming convention and error message patterns.

Purpose: Every error message in the C++ layer follows a predictable, parseable format. Downstream layers (C API, bindings) can rely on consistent error structure.
Output: All throw sites standardized; CLAUDE.md documents the conventions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cpp-naming-error-standardization/03-RESEARCH.md
@.planning/phases/03-cpp-naming-error-standardization/03-01-SUMMARY.md
@src/database_impl.h
@src/database_internal.h
@src/database.cpp
@src/database_create.cpp
@src/database_read.cpp
@src/database_update.cpp
@src/database_delete.cpp
@src/database_metadata.cpp
@src/database_time_series.cpp
@src/database_relations.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Standardize require_collection and add missing collection validation</name>
  <files>
    src/database_impl.h
    src/database_read.cpp
  </files>
  <action>
    **Step 1: Fix require_collection message format in database_impl.h**

    Current `require_collection` throws: `"Collection not found in schema: " + collection`
    Change to follow Pattern 2 (Not found): `"Collection not found: " + collection`

    This also makes it match the "Cannot {operation}:" prefix from `require_schema` which is called first. The combined effect for a missing collection becomes:
    - Missing schema: `"Cannot read_scalar_integers: no schema loaded"`
    - Missing collection: `"Collection not found: Items"` (note: require_collection does NOT include the operation name in the "not found" part -- the operation context comes from require_schema if schema is also missing)

    Actually, looking at the current code more carefully: `require_collection` calls `require_schema` first, then throws its own error. The require_collection message should include the operation for consistency. Update to:
    `"Cannot " + operation + ": collection not found: " + collection`
    This makes it Pattern 1 (Precondition failure) which is correct -- a missing collection IS a precondition failure.

    **Step 2: Add require_collection to vector/set read operations in database_read.cpp**

    Currently, vector and set read methods (all 6 "all elements" variants and all 6 "by id" variants) call `require_schema` directly instead of `require_collection`. Find each of these 12 methods and replace `impl_->require_schema("method_name")` with `impl_->require_collection(collection, "method_name")`.

    The scalar read methods ALREADY use `require_collection` -- vector/set reads should match this pattern.

    Methods to update in database_read.cpp:
    - `read_vector_integers`, `read_vector_floats`, `read_vector_strings`
    - `read_vector_integers_by_id`, `read_vector_floats_by_id`, `read_vector_strings_by_id`
    - `read_set_integers`, `read_set_floats`, `read_set_strings`
    - `read_set_integers_by_id`, `read_set_floats_by_id`, `read_set_strings_by_id`

    For each, change the pattern from:
    ```cpp
    impl_->require_schema("read_vector_integers");
    ```
    to:
    ```cpp
    impl_->require_collection(collection, "read_vector_integers");
    ```
  </action>
  <verify>
    1. `grep -n "require_schema" src/database_read.cpp` returns zero hits (all converted to require_collection)
    2. `grep -n "require_collection" src/database_read.cpp` returns hits for every read method
    3. `grep "Collection not found" src/database_impl.h` shows the new format with operation name
    4. Build succeeds: `cmake --build build --config Debug`
  </verify>
  <done>
    require_collection message standardized to "Cannot {op}: collection not found: {name}". All 12 vector/set read methods use require_collection instead of require_schema. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Standardize all error messages to 3 patterns and update CLAUDE.md</name>
  <files>
    src/database.cpp
    src/database_create.cpp
    src/database_update.cpp
    src/database_delete.cpp
    src/database_metadata.cpp
    src/database_time_series.cpp
    src/database_relations.cpp
    src/database_internal.h
    CLAUDE.md
  </files>
  <action>
    **Step 1: Standardize all throw sites to exactly 3 patterns.**

    Go through each file and rewrite every `throw std::runtime_error(...)` to use one of these 3 patterns:

    **Pattern 1 -- Precondition failure**: `"Cannot {operation}: {reason}"`
    Use when: Schema not loaded, collection not found, empty input, invalid arguments.
    Examples:
    - `"Cannot create_element: no schema loaded"` (from require_schema)
    - `"Cannot create_element: element must have at least one scalar attribute"`
    - `"Cannot update_element: element must have at least one attribute to update"`

    **Pattern 2 -- Not found**: `"{Entity} not found: {identifier}"`
    Use when: Looking up a specific entity by name/id that doesn't exist.
    Examples:
    - `"Scalar attribute not found: 'value' in collection 'Items'"`
    - `"Vector group not found: 'values' in collection 'Items'"`
    - `"Schema file not found: path/to/schema.sql"`
    - `"Migrations path not found: path/to/migrations"`
    - `"Vector table not found: Items_vector_values"`
    - `"Time series files table not found: Items_time_series_files"`

    **Pattern 3 -- Operation failure**: `"Failed to {operation}: {reason}"`
    Use when: An operation was attempted but failed due to external factors (I/O, SQL error, etc).
    Examples:
    - `"Failed to open database: {sqlite_error}"`
    - `"Failed to execute statement: {sqlite_error}"`
    - `"Failed to begin transaction: {error}"`
    - `"Failed to resolve label '{label}' to ID in table '{table}'"`

    **Specific file-by-file changes:**

    **src/database.cpp** (~16 throw sites): Most already follow Pattern 3 ("Failed to ..."). Review each:
    - Lifecycle errors (open, prepare, execute) -> Pattern 3
    - Schema/migration path errors -> Pattern 2 ("not found")
    - Validation errors (empty schema, not a directory) -> Pattern 1 ("Cannot ...")

    **src/database_create.cpp** (~10 throw sites):
    - Input validation ("must have at least one...") -> Pattern 1: `"Cannot create_element: ..."`
    - SQL failures -> Pattern 3: `"Failed to create_element: ..."`
    - Lookups ("not found") -> Pattern 2

    **src/database_update.cpp** (~5 throw sites):
    - Input validation -> Pattern 1
    - SQL failures -> Pattern 3

    **src/database_delete.cpp**: Already minimal, update as needed.

    **src/database_metadata.cpp** (~11 throw sites):
    - Attribute/group not found -> Pattern 2
    - Precondition checks -> Pattern 1

    **src/database_time_series.cpp** (~9 throw sites):
    - Table not found -> Pattern 2
    - Precondition checks -> Pattern 1
    - SQL failures -> Pattern 3

    **src/database_relations.cpp** (~7 throw sites):
    - Attribute not found -> Pattern 2
    - Not a foreign key -> Pattern 1: `"Cannot update_scalar_relation: attribute '{attr}' is not a foreign key in collection '{coll}'"`
    - SQL failures -> Pattern 3

    **src/database_internal.h** (~1 throw site):
    - `find_dimension_column` -> Pattern 2 if "not found"

    **Important:** Do NOT change error messages in `src/database_impl.h` (already handled in Task 1). Do NOT change error messages in `src/c/database.cpp` (C API, Phase 5).

    **Step 2: Update CLAUDE.md**

    Add/update the following sections in CLAUDE.md:

    1. Under "## C++ Patterns", add a subsection "### Naming Convention" documenting:
       - The `verb_[category]_[type][_by_id]` pattern
       - Allowed verbs: create, read, update, delete, get, list, has, query, describe, export, import
       - The `_by_id` rule: only for reads where both "all" and "single" variants exist
       - Singular vs plural type names

    2. Update the existing "### Error Handling" subsection to document the 3 patterns:
       - Pattern 1: `"Cannot {operation}: {reason}"` -- precondition failures
       - Pattern 2: `"{Entity} not found: {identifier}"` -- entity lookups
       - Pattern 3: `"Failed to {operation}: {reason}"` -- operation failures
  </action>
  <verify>
    1. Build succeeds: `cmake --build build --config Debug`
    2. C++ tests pass: `./build/bin/quiver_tests.exe`
    3. Audit: `grep -rn "throw std::runtime_error" src/database*.cpp src/database*.h` -- every message starts with "Cannot ", "{X} not found:", or "Failed to "
    4. CLAUDE.md contains the naming convention and error pattern documentation
  </verify>
  <done>
    All ~65 throw sites across 9 source files follow exactly 3 message patterns. CLAUDE.md documents the naming convention and error message patterns. All C++ tests pass.
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build --config Debug` succeeds
2. C++ tests: `./build/bin/quiver_tests.exe` all pass
3. Error pattern audit: Every `throw std::runtime_error(...)` in src/database*.cpp and src/database*.h uses one of exactly 3 patterns:
   - `"Cannot {operation}: {reason}"`
   - `"{Entity} not found: {identifier}"`
   - `"Failed to {operation}: {reason}"`
4. No stray patterns: Zero throw sites use "Element must have", "Blob not implemented", or other ad-hoc formats without the standardized prefix
5. require_collection: All vector/set read operations in database_read.cpp call require_collection (not just require_schema)
6. CLAUDE.md: Contains naming convention and error pattern documentation
</verification>

<success_criteria>
- All 65 throw sites follow 3 canonical patterns
- Vector/set reads validate collection existence (not just schema existence)
- CLAUDE.md documents naming convention and error patterns
- All C++ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-cpp-naming-error-standardization/03-02-SUMMARY.md`
</output>
